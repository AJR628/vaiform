<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Studio - Vaiform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Unified Header and Auth -->
    <script type="module">
        import { createUnifiedHeader, initializeHeader } from "/components/header.js";
        import { initializeAuth } from "/components/auth-utils.js";
        
        // Load unified header
        document.getElementById('unified-header').innerHTML = createUnifiedHeader();
        initializeHeader();
        
        // Initialize auth after a short delay to ensure Firebase is ready
        setTimeout(() => {
            initializeAuth();
        }, 100);
    </script>
    
    <!-- Firebase SDK - Load the same way as main site -->
    <script type="module" src="./js/firebaseClient.js"></script>
    <!-- Auth bridge: expose auth & wire token provider before page code -->
    <script type="module" src="./auth-bridge.js"></script>
    <script type="module" src="/js/credits-ui.js?v=20250920b"></script>
    <script type="module">
        // Make credits functions globally available
        import { updateCreditsDisplay, fetchAndUpdateCredits } from '/js/credits-ui.js?v=20250920b';
        window.updateCreditsDisplay = updateCreditsDisplay;
        window.fetchAndUpdateCredits = fetchAndUpdateCredits;
    </script>
    <script type="module" src="./frontend.js"></script>
    <link rel="stylesheet" href="/creative.css" />
    <!-- Caption rendering now uses server-side PNG overlay - no fonts needed -->
    <style>
        .loading { opacity: 0.6; pointer-events: none; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        
        /* Force dark mode for content boxes */
        .dark .content-box {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        .dark .content-box h2 {
            color: #ffffff !important;
        }
        
        /* Force dark mode for quote result box */
        .dark #quote-result {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for quote text display */
        .dark #quote-text-display {
            color: #ffffff !important;
        }
        
        /* Force dark mode for quote edit textarea */
        .dark #quote-edit {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for remix area */
        .dark #remix-area {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for remix area heading */
        .dark #remix-area h3 {
            color: #d1d5db !important; /* gray-300 */
        }
        
        /* Force dark mode for remix assets container */
        .dark #remix-assets {
            background-color: transparent !important;
        }
        
        /* Force dark mode for AI result preview */
        .dark #ai-result-preview {
            background-color: #111827 !important; /* gray-900 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for render preview box */
        .dark #render-preview {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for preview text elements */
        .dark #preview-quote {
            color: #ffffff !important;
        }
        
        .dark #preview-asset,
        .dark #preview-caption-style,
        .dark #preview-voiceover {
            color: #9ca3af !important; /* gray-400 */
        }
        
        /* Force dark mode for remix input text */
        .dark #remix-input {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
    </style>
    <!-- Respect saved theme before paint - default to dark -->
    <script>
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "light") {
            document.documentElement.classList.remove("dark");
        } else {
            document.documentElement.classList.add("dark");
        }
    </script>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">
    <!-- Unified Header -->
    <div id="unified-header"></div>

    <div class="max-w-6xl mx-auto p-6 space-y-8">
        <!-- Header -->
        <div class="flex items-center justify-between">
            <h1 class="text-3xl font-bold">Creative Studio</h1>
        </div>

        <!-- Quote Generation Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Generate Quote</h2>
            
            <div class="flex gap-4 items-center">
                <input
                    type="text"
                    id="quote-text"
                    value="Create a motivational quote about success"
                    placeholder="Describe what kind of quote you want..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <div class="text-xs text-gray-500 dark:text-gray-400 w-20 text-right" id="quote-char-count">0/200</div>
                <select id="quote-tone" class="bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                    <option value="default">Default</option>
                    <option value="motivational">Motivational</option>
                    <option value="witty">Witty</option>
                    <option value="poetic">Poetic</option>
                    <option value="bold">Bold</option>
                    <option value="calm">Calm</option>
                </select>
                <button
                    id="generate-quote-btn"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded"
                >
                    Generate Quote
                </button>
                <button
                    id="use-text-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 rounded text-white"
                    title="Use the exact text above as your quote"
                >
                    Use This Text
                </button>
            </div>

            <div id="quote-error" class="error text-sm hidden"></div>

            <div id="quote-result" class="bg-gray-100 dark:bg-gray-800 rounded p-4 space-y-3 hidden border border-gray-200 dark:border-gray-700">
                <div class="flex items-start justify-between gap-3">
                    <div class="flex-1">
                        <div id="quote-text-display" class="text-lg font-medium text-gray-900 dark:text-white"></div>
                        <textarea id="quote-edit" class="w-full bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm hidden text-gray-900 dark:text-white"></textarea>
                    </div>
                    <div class="flex flex-col gap-2 items-end">
                        <div id="regen-info" class="text-xs text-gray-400">Regens left: 10</div>
                        <div class="flex gap-2">
                            <button id="edit-quote-btn" class="px-3 py-1 bg-gray-600 dark:bg-neutral-700 hover:bg-gray-700 dark:hover:bg-neutral-600 rounded text-sm text-white">Edit</button>
                            <button id="save-quote-btn" class="px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-sm hidden text-white">Save</button>
                            <button id="cancel-quote-btn" class="px-3 py-1 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-sm hidden text-white">Cancel</button>
                        </div>
                    </div>
                </div>
                <div id="quote-author" class="text-sm text-gray-400 hidden"></div>
                <div id="quote-tone-tag" class="text-xs text-blue-400 hidden"></div>
                
                <!-- Remix buttons (Pro only) -->
                <div id="remix-buttons" class="flex gap-2 hidden">
                    <button id="regenerate-btn" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Regenerate
                    </button>
                    <button id="rephrase-btn" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Rephrase
                    </button>
                    <button id="tone-shift-btn" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Change Tone
                    </button>
                </div>
            </div>
        </div>

        <!-- Asset Selection Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Choose Background</h2>
            
            <!-- Asset Type Tabs -->
            <div class="flex gap-2">
                <button id="images-tab" class="px-4 py-2 rounded bg-blue-600 text-white" data-type="images">
                    Images
                </button>
                <button id="videos-tab" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white" data-type="videos">
                    Videos
                </button>
                <button id="ai-tab" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white hidden" data-type="ai">
                    AI Images
                </button>
            </div>

            <!-- Remix Area -->
            <div id="remix-area" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-4 hidden border border-gray-200 dark:border-gray-700">
                <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Remix References (up to 2)</h3>
                <div id="remix-assets" class="flex gap-4">
                    <!-- Remix assets will be added here -->
                </div>
                <!-- AI result preview slot -->
                <div id="ai-result-block" class="mt-3 hidden">
                    <div class="flex flex-col items-center gap-2">
                        <div id="ai-ref-preview" class="flex gap-2 justify-center"></div>
                        <div id="ai-result-preview" class="relative w-full rounded overflow-hidden border border-gray-600 bg-black" style="aspect-ratio: 9/16;"></div>
                        <div class="mt-2">
                            <button id="ai-save-use-btn" class="px-3 py-1 bg-green-600 hover:bg-green-500 text-white text-xs rounded">Save & Use</button>
                        </div>
                    </div>
                </div>
                <!-- Inline AI prompt + style for ideogram remix -->
                <div class="mt-3 flex flex-wrap items-center gap-3">
                    <input
                        type="text"
                        id="ai-prompt"
                        value="A serene mountain landscape at sunset"
                        placeholder="Describe what to create from these references..."
                        class="flex-1 min-w-[16rem] bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm text-gray-900 dark:text-white"
                    />
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-400">Realistic</span>
                        <input type="range" id="ai-style-slider" min="0" max="1" step="0.1" value="0.5" class="w-24" />
                        <span class="text-xs text-gray-400">Creative</span>
                    </div>
                </div>
                <div class="mt-3 flex items-center gap-2">
                    <button
                        id="clear-remix-btn"
                        class="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-xs rounded"
                    >
                        Clear All
                    </button>
                    <button
                        id="remix-generate-btn"
                        class="px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded"
                        title="Generate a new AI image using the selected references"
                    >
                        20 Credits
                    </button>
                </div>
            </div>

            <!-- Search Controls -->
            <div id="search-controls" class="flex gap-4 items-center">
                <input
                    type="text"
                    id="asset-query"
                    value="nature"
                    placeholder="Search for images/videos..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <button
                    id="search-assets-btn"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded text-white"
                >
                    Search
                </button>
                <button
                    id="upload-asset-btn"
                    class="px-3 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-white"
                    title="Upload your own image or video"
                >
                    üìÅ
                </button>
                <input
                    type="file"
                    id="asset-upload-input"
                    accept="image/*,video/*"
                    class="hidden"
                />
            </div>

            <!-- AI Images Controls removed (inline controls are now in remix-area) -->
            <div id="ai-error" class="error text-sm hidden"></div>

            <div id="asset-error" class="error text-sm hidden"></div>

            <!-- Asset Grid (3 rows √ó 4 columns ‚âà 12 results) -->
            <div id="asset-grid" class="grid grid-cols-4 gap-4">
                <!-- Assets will be populated here -->
            </div>

            <!-- Pagination Controls -->
            <div id="pagination-container" class="flex justify-between items-center mt-4 hidden">
                <button
                    id="prev-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    ‚Üê Previous
                </button>
                <span id="page-info" class="text-sm text-gray-600 dark:text-gray-400">Page 1</span>
                <button
                    id="next-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    Next ‚Üí
                </button>
            </div>

            <!-- Free Plan Notice -->
            <div id="free-notice" class="text-center text-sm text-gray-400 hidden">
                Showing 12 curated assets. 
                <span class="text-blue-400"> Upgrade to Pro</span> for larger pages and AI images.
            </div>
        </div>

        <!-- Caption Style Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Caption Style</h2>
            
            <div class="grid grid-cols-2 gap-4">
                <!-- Font Family -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Font</label>
                    <select id="caption-font" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="system">System</option>
                        <option value="bold">Bold</option>
                        <option value="cinematic">Cinematic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                
                <!-- Font Weight -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Weight</label>
                    <select id="caption-weight" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                    </select>
                </div>
                
                <!-- Size -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Size: <span id="size-value">80px</span></label>
                    <input
                        type="range"
                        id="caption-size"
                        min="0"
                        max="100"
                        value="60"
                        class="w-full"
                    />
                </div>
                
                <!-- Opacity -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Opacity: <span id="opacity-value">80%</span></label>
                    <input
                        type="range"
                        id="caption-opacity"
                        min="30"
                        max="100"
                        value="80"
                        class="w-full"
                    />
                </div>
                
                <!-- Placement -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Placement</label>
                    <select id="caption-placement" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="top">Top</option>
                        <option value="middle">Middle</option>
                        <option value="bottom" selected>Bottom</option>
                    </select>
                </div>
                
                <!-- Background Box -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Background</label>
                    <div class="flex items-center gap-4">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="caption-background" class="rounded" />
                            <span class="text-sm">Show box</span>
                        </label>
                        <div class="flex-1">
                            <label class="block text-xs text-gray-400 mb-1">Box opacity: <span id="bg-opacity-value">50%</span></label>
                            <input
                                type="range"
                                id="caption-bg-opacity"
                                min="0"
                                max="100"
                                value="50"
                                class="w-full"
                            />
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Voiceover Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Voiceover</h2>
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Voice</label>
                    <div class="flex gap-2">
                        <select id="voiceover-voice" class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                            <option value="">Loading voices...</option>
                        </select>
                        <button id="retry-voices-btn" onclick="loadVoices()" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm">
                            üîÑ
                        </button>
                    </div>
                </div>
                <div class="flex items-end gap-2">
                    <button
                        id="preview-voice-btn"
                        class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white"
                        disabled
                    >
                        Preview Voice
                    </button>
                    <audio id="voice-preview-audio" class="hidden" controls></audio>
                </div>
            </div>
            <div id="voice-preview-status" class="text-sm text-gray-400 hidden"></div>
        </div>

        <!-- Render Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Create Short</h2>
            
            <!-- Live Preview Canvas -->
            <div id="live-preview-container" class="hidden">
                <div class="text-sm text-gray-400 mb-2">Live Preview:</div>
                <!-- Fix A: Give the preview wrapper a predictable size -->
                <div class="relative mx-auto bg-black rounded-lg overflow-hidden" style="width: 360px; aspect-ratio: 9 / 16;">
                    <canvas id="live-preview-canvas" class="w-full h-full block"></canvas>
                    <!-- TASK 4: Fix overlay container to match canvas CSS size -->
                    <div class="absolute inset-0 pointer-events-none" id="caption-overlay" style="width: 100%; height: 100%;"></div>
                </div>
            </div>
            
            <div id="render-preview" class="bg-gray-100 dark:bg-gray-800 rounded p-4 hidden border border-gray-200 dark:border-gray-700">
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">Preview:</div>
                <div id="preview-quote" class="text-lg font-medium mb-2 text-gray-900 dark:text-white"></div>
                <div id="preview-asset" class="text-sm text-gray-600 dark:text-gray-400"></div>
                <div id="preview-caption-style" class="text-sm text-gray-600 dark:text-gray-400"></div>
                <div id="preview-voiceover" class="text-sm text-gray-600 dark:text-gray-400"></div>
            </div>
            
            <button
                id="render-btn"
                class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-lg font-medium hidden"
            >
                Render Short
            </button>
        </div>
    </div>

    <script type="module">
        import { BACKEND as BACKEND_FROM_CONFIG } from '/config.js';

        const API_BASE_FALLBACK = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        // Hard-force the backend origin to Replit to avoid Netlify handling /cdn
        const API_BASE_FIXED = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        function getApiBase(){
            return API_BASE_FIXED.replace(/\/$/, '');
        }

        // --- Auth ready (wait for Firebase to finish initializing exactly once) ---
        window.__authReady = window.__authReady || new Promise((resolve) => {
          try {
            // If firebase auth is already available, attach listener; otherwise poll briefly
            const attach = () => {
              if (window.firebase && window.firebase.auth) {
                window.firebase.auth().onAuthStateChanged((user) => {
                  window.__currentUser = user || null;
                  resolve(user || null);
                });
                return true;
              }
              return false;
            };
            if (!attach()) {
              const t = setInterval(() => {
                if (attach()) clearInterval(t);
              }, 50);
              setTimeout(() => { clearInterval(t); resolve(null); }, 5000); // worst-case resolve
            }
          } catch {
            resolve(null);
          }
        });

        // --- Caption sizing constants (HOISTED) ---
        const UI_MIN_PX = 48;     // slider min visual (increased to prevent text disappearing)
        const UI_MID_PX = 72;     // slider mid visual (more reasonable middle)
        const UI_MAX_PX = 120;    // slider max visual (capped to prevent overflow)
        const API_MIN_PX = 32;    // backend clamp lower bound
        const API_MAX_PX = 200;   // backend clamp upper bound (increased to match server limit)

        // --- Caption size mapping (define BEFORE any usage)
        function mapSliderToPx(sliderVal) {
          // linear map slider value to pixel range, then clamp to API bounds
          const raw = Number(sliderVal);
          let uiPx;
          
          if (!isFinite(raw)) {
            uiPx = UI_MID_PX; // fallback to middle
          } else {
            const v = Math.max(0, Math.min(100, raw));
            if (v <= 50) {             // 0..50  -> UI_MIN_PX..UI_MID_PX
              const t = v / 50;
              uiPx = UI_MIN_PX + t * (UI_MID_PX - UI_MIN_PX);
            } else {                   // 50..100 -> UI_MID_PX..UI_MAX_PX
            const t = (v - 50) / 50;
              uiPx = UI_MID_PX + t * (UI_MAX_PX - UI_MID_PX);
          }
          }
          
          return Math.max(API_MIN_PX, Math.min(API_MAX_PX, Math.round(uiPx)));
        }

        function getCaptionPx() {
            const el = document.getElementById('caption-size');
            return mapSliderToPx(el ? el.value : 50);
        }
        
        // Font size clamping to prevent overflow with binary search for better responsiveness
        function fitFontPx(targetFontPx, text, W = 1080, H = 1920) {
            const min = 24, max = 160;
            const padPctTop = 0.08, padPctBottom = 0.08;
            const maxWidthPct = 0.90; // increased from 0.85
            const lineHeight = 1.05; // reduced from 1.1
            const maxTextWidth = W * maxWidthPct;
            const maxTextHeight = H * (1 - padPctTop - padPctBottom);
            
            function measureFits(fontPx) {
                // Simple word wrapping simulation
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine ? `${currentLine} ${word}` : word;
                    // Rough width estimation (fontPx * 0.6 is approximate)
                    const estimatedWidth = testLine.length * fontPx * 0.6;
                    
                    if (estimatedWidth <= maxTextWidth && currentLine) {
                        currentLine = testLine;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                const totalHeight = lines.length * fontPx * lineHeight;
                return totalHeight <= maxTextHeight;
            }
            
            let lo = min, hi = Math.min(max, targetFontPx), best = lo;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1; // binary search
                if (measureFits(mid)) { 
                    best = mid; 
                    lo = mid + 1; 
                } else { 
                    hi = mid - 1; 
                }
            }
            
            if (best !== targetFontPx) {
                console.log(`[caption] Font size ${targetFontPx}px fitted to ${best}px for better responsiveness`);
            }
            
            return best;
        }

        // Fix D: Preview geometry helper using proper CSS/backing separation
        function getPreviewGeometry(canvas) {
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const cssW = canvas.clientWidth;  // CSS size
            const cssH = canvas.clientHeight; // CSS size
            const backingW = canvas.width;    // Backing store size
            const backingH = canvas.height;   // Backing store size
            const scaleX = cssW / 1080; // CSS size to PNG native size
            const scaleY = cssH / 1920;
            
            return { dpr, cssW, cssH, backingW, backingH, scaleX, scaleY };
        }

        // expose for other code
          window.getCaptionPx = getCaptionPx;
        window.__captionSizeMapping = { mapSliderToPx, API_MIN_PX, API_MAX_PX, UI_MIN_PX, UI_MID_PX, UI_MAX_PX };

        // --- Auth-aware login warning function ---
        async function ensureLoggedInOrWarn() {
          const warnEl = document.getElementById('asset-error'); // the red text element
          if (!warnEl) return true; // nothing to do
          const user = await window.__authReady;
          const isLoggedIn = !!user;
          if (isLoggedIn) {
            warnEl.style.display = 'none'; // hide when logged in
          }
          return isLoggedIn;
        }

        // --- Helper to get active asset type ---
        function getActiveAssetType() {
          const activeTab = document.querySelector('[data-type].bg-blue-600') ||
                            document.querySelector('[data-type]');
          return activeTab?.dataset.type || 'images'; // fallback to images (default tab)
        }

        // --- High-quality Pexels preview URL helper ---
        function bestPexelsPreviewUrl(photo, targetWidth = 720, targetHeight = 1280) {
          if (!photo || !photo.src) return null;
          
          const src = photo.src;
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
          
          // Prefer portrait, then large2x, then large, fallback to original/medium
          let baseUrl = src.portrait || src.large2x || src.large || src.original || src.medium;
          
          if (!baseUrl) return null;
          
          // Add Pexels optimization parameters for high-quality preview
          const params = new URLSearchParams({
            auto: 'compress',
            cs: 'tinysrgb',
            dpr: dpr.toString(),
            fit: 'crop',
            w: targetWidth.toString(),
            h: targetHeight.toString()
          });
          
          return `${baseUrl}?${params.toString()}`;
        }

        // === Pexels Preview Quality + Trace Helpers ===
        function _isHiResPreviewUrl(url) {
          if (!url) return false;
          // Must NOT be just h=350; should include fit=crop and explicit w/h and dpr
          return /fit=crop/.test(url) && /[?&]w=\d+/.test(url) && /[?&]h=\d+/.test(url);
        }
        
        function _pexelsPreviewUrlFromPhoto(photo, needW, needH, headroom = 1.2) {
          const base =
            (photo?.src?.portrait) ||
            (photo?.src?.large2x) ||
            (photo?.src?.large) ||
            (photo?.src?.original) ||
            (photo?.src?.medium);
          if (!base) return null;
          const join = base.includes('?') ? '&' : '?';
          const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
          const w = Math.ceil(needW * headroom);
          const h = Math.ceil(needH * headroom);
          return `${base}${join}auto=compress&cs=tinysrgb&fit=crop&dpr=${dpr}&w=${w}&h=${h}`;
        }
        
        // Fix B: Updated HiDPI canvas setup using sizeCanvasToCSS
        function _setupHiDPICanvas(canvas, cssW, cssH) {
          // Use the new sizing function
          if (!sizeCanvasToCSS(canvas)) {
            // Fallback to manual setup if sizeCanvasToCSS fails
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width  = Math.round(cssW * dpr);
            canvas.height = Math.round(cssH * dpr);
            canvas.style.width  = `${cssW}px`;
            canvas.style.height = `${cssH}px`;
          }
          
          const ctx = canvas.getContext('2d');
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          return { ctx, dpr };
        }
        
        // Visual breadcrumb on the canvas so we know who drew last
        const DEBUG_CANVAS = false;
        function _tapCanvas(label) {
          if (!DEBUG_CANVAS) return;
          try {
            const c = document.getElementById('live-preview-canvas');
            if (!c) return;
            const x = c.getContext('2d');
            x.save();
            x.font = '12px system-ui';
            x.fillStyle = 'rgba(255,255,255,.95)';
            x.strokeStyle = 'rgba(0,0,0,.6)';
            x.strokeText(label, 8, 18);
            x.fillText(label, 8, 18);
            x.restore();
          } catch {}
        }

        // Legacy function - now calls the new helper
        function pexelsPreviewUrl(photo, needW, needH, headroom = 1.2) {
          return _pexelsPreviewUrlFromPhoto(photo, needW, needH, headroom);
        }

        // --- Pexels hi-res intercept helpers (preview-only) ---
        function _buildHiResPexelsUrlFromBase(baseUrl, needW, needH) {
          try {
            const u = new URL(baseUrl);
            if (u.hostname !== 'images.pexels.com') return baseUrl;
            // We always prefer fit=crop + explicit w/h + dpr
            const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
            u.searchParams.set('auto', 'compress');
            u.searchParams.set('cs', 'tinysrgb');
            u.searchParams.set('fit', 'crop');
            u.searchParams.set('dpr', String(dpr));
            u.searchParams.set('w', String(Math.ceil(needW * 1.2)));
            u.searchParams.set('h', String(Math.ceil(needH * 1.2)));
            // remove stray h=350 if present
            return u.toString();
          } catch { return baseUrl; }
        }

        // Given whatever the app thinks is the preview URL, ensure it is hi-res for the canvas draw.
        function _ensureHiResPreviewUrl(rawUrl, canvas) {
          if (!rawUrl) return rawUrl;
          const needW = canvas.width || canvas.clientWidth;
          const needH = canvas.height || canvas.clientHeight;
          return _buildHiResPexelsUrlFromBase(rawUrl, needW, needH);
        }

        // Fix A: Use predictable wrapper dimensions
        function layoutPreviewDims() {
          const box = document.querySelector('#live-preview-container .relative');
          if (box) {
            // Use the fixed wrapper dimensions
            const cssW = box.clientWidth || 360; // fallback to our fixed width
            const cssH = Math.round(cssW * 16 / 9); // lock to 9:16 portrait
            return { cssW, cssH };
          }
          // Fallback to default dimensions
          return { cssW: 360, cssH: 640 };
        }

        function drawCover(ctx, img, cssW, cssH) {
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.max(cssW / iw, cssH / ih); // COVER (fill + crop)
          const dw = iw * scale, dh = ih * scale;
          const dx = (cssW - dw) / 2, dy = (cssH - dh) / 2;
          ctx.clearRect(0, 0, cssW, cssH);
          ctx.drawImage(img, dx, dy, dw, dh);
        }

        function setupHiDPICanvas(canvas, cssW, cssH) {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          canvas.width  = Math.round(cssW * dpr);
          canvas.height = Math.round(cssH * dpr);
          canvas.style.width  = `${cssW}px`;
          canvas.style.height = `${cssH}px`;
          const ctx = canvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          return { ctx, dpr };
        }

        // --- High-quality canvas drawing helper with HiDPI support ---
        function drawPreviewOnCanvas(canvas, ctx, img, targetWidth = 400, targetHeight = 711) {
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
          
          // Set up HiDPI canvas
          canvas.width = targetWidth * dpr;
          canvas.height = targetHeight * dpr;
          canvas.style.width = `${targetWidth}px`;
          canvas.style.height = `${targetHeight}px`;
          
          // Enable high-quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // Set transform for HiDPI
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          
          // Calculate cover-fit dimensions (fill canvas without distortion)
          const imgAspect = img.naturalWidth / img.naturalHeight;
          const canvasAspect = targetWidth / targetHeight;
          
          let drawWidth, drawHeight, drawX, drawY;
          
          if (imgAspect > canvasAspect) {
            // Image is wider - fit height, crop width
            drawHeight = targetHeight;
            drawWidth = drawHeight * imgAspect;
            drawX = (targetWidth - drawWidth) / 2;
            drawY = 0;
          } else {
            // Image is taller - fit width, crop height
            drawWidth = targetWidth;
            drawHeight = drawWidth / imgAspect;
            drawX = 0;
            drawY = (targetHeight - drawHeight) / 2;
          }
          
          // Draw the image with cover-fit
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        // --- Race protection for preview loading ---
        let _previewReqId = 0;
        let _currentPexelsPhoto = null; // Track current photo for resize re-rendering

        async function _drawBackground(url, canvas, cssW, cssH, who='drawBackground') {
          const my = ++_previewReqId;
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.decoding = 'async';
          img.src = url;
          await img.decode();
          if (my !== _previewReqId) return;
          const ctx = canvas.getContext('2d');
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.max(cssW/iw, cssH/ih);
          const dw = iw*scale, dh = ih*scale;
          const dx = (cssW - dw)/2, dy = (cssH - dh)/2;
          ctx.clearRect(0,0,cssW,cssH);
          ctx.drawImage(img, dx, dy, dw, dh);
          window._currentPreviewUrl = url;
          _tapCanvas(`${who}`);
        }

        // --- Debounced caption overlay refresh (prevents blocking assets) ---
        let overlayRefreshTimer = null;
        function queueCaptionOverlayRefresh() {
          if (overlayRefreshTimer) clearTimeout(overlayRefreshTimer);
          overlayRefreshTimer = setTimeout(() => {
            try {
              // Call existing caption overlay update function
              if (typeof updateCaptionOverlay === 'function' && currentQuote?.text) {
                updateCaptionOverlay(currentQuote.text.trim(), true);
              }
            } catch (e) {
              console.warn('[caption-overlay] preview failed (non-fatal)', e);
            }
          }, 120); // 120ms debounce to reduce server load
        }

        // Safe placeholder if real loader is attached later
        window.loadVoices = window.loadVoices || (async function () {
          console.debug('[voice] loadVoices placeholder (no-op)');
          // If you have a real loader like populateVoicesDropdown(), call it here instead:
          // return populateVoicesDropdown();
        });

        // Helper for clearer logging
        window.__log = (...args) => console.log('[assets]', ...args);

        // Global state
        let currentLimits = null;
        let currentQuote = null;
        let selectedAsset = null;
        let currentAssetType = 'images';
        let currentAssetPage = 1;
        let hasMoreAssets = false;
        let currentCredits = 0;
        let remixAssets = [];
        let assetCache = new Map(); // Cache for pagination
        let uploadedAssets = [];
        let availableVoices = [];
        let currentVoiceId = null;

        // Helper functions - PNG overlay system
        let captionOverlayState = null;
        let captionDebounceTimer = null;
        
        // Debounced caption preview generator
        function debouncedPreview(delay = 200) {
            clearTimeout(captionDebounceTimer);
            captionDebounceTimer = setTimeout(() => {
                if (currentQuote?.text?.trim()) {
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            }, delay);
        }
        
        function maybeGenerateCaptionPreview() {
            const txt = currentQuote?.text?.trim() || '';
            if (txt.length && selectedAsset) {
                debouncedPreview();
            }
        }
        
        async function updateCaptionOverlay(text = '', show = true) {
            const overlay = document.getElementById('caption-overlay');
            if (!overlay) return;
            
            // Check if container is visible first
            const container = document.getElementById('live-preview-container');
            if (!container || container.classList.contains('hidden')) {
                console.log('[caption-overlay] Container not visible, skipping overlay');
                return;
            }
            
            // Fix C: Check if canvas has real dimensions, but don't retry infinitely
            const canvas = document.getElementById('live-preview-canvas');
            if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                console.log('[caption-overlay] Canvas not ready, skipping overlay');
                return;
            }
            
            // Clear existing overlay
            overlay.innerHTML = '';
            
            if (!show || !text?.trim()) {
                captionOverlayState = null;
                return;
            }

            // Get caption style parameters from UI
            const sizePx = window.getCaptionPx(); // Use original mapped size logic
            const opacityPct = parseInt(document.getElementById('caption-opacity')?.value || '85', 10);
            const placement = (document.getElementById('caption-placement')?.value || 'bottom').toLowerCase();
            const showBoxToggle = document.getElementById('caption-background')?.checked || false;
            const boxOpacityPct = parseInt(document.getElementById('caption-bg-opacity')?.value || '50', 10);
            const selectedWeight = document.getElementById('caption-weight')?.value || 'bold';
            
            console.log('[preview-scaling]', { 
                mappedSizePx: sizePx
            });

            // Map UI selection to server placement format
            function placementToServerFormat(placement) {
                switch ((placement || 'bottom').toLowerCase()) {
                    case 'top':    return { placement: 'top',    yPct: 0.15 }; // 15% from top
                    case 'middle': return { placement: 'center', yPct: 0.50 }; // center
                    case 'bottom': 
                    default:       return { placement: 'bottom', yPct: 0.85 }; // 85% from top
                }
            }
            
            // Validate yPct to prevent extreme values
            function validateYPct(yPct) {
                const clamped = Math.max(0.05, Math.min(0.95, Number(yPct)));
                if (clamped !== Number(yPct)) {
                    console.warn(`[caption] yPct ${yPct} clamped to ${clamped} to prevent off-screen positioning`);
                }
                return clamped;
            }
            
            const placementData = placementToServerFormat(placement);
            const validatedYPct = validateYPct(placementData.yPct);
            
            console.log('[caption-debug] Placement mapping:', {
                uiPlacement: placement,
                serverPlacement: placementData.placement,
                yPct: validatedYPct
            });
            
            // Map UI font selection to server font names (only use registered fonts)
            const fontMapping = {
                'system': { family: 'DejaVuSans', weightCss: 'normal' },
                'bold': { family: 'DejaVuSans', weightCss: 'bold' },
                'cinematic': { family: 'DejaVuSans', weightCss: 'bold' }, // Fallback to DejaVu until we add more fonts
                'minimal': { family: 'DejaVuSans', weightCss: 'normal' }
            };
            
            const selectedFont = document.getElementById('caption-font')?.value || 'system';
            const fontConfig = fontMapping[selectedFont] || fontMapping['system'];
            
            const captionStyle = {
                text: text.trim(),
                sizePx: sizePx, // Use fitted size
                fontFamily: fontConfig.family,
                weight: fontConfig.weightCss,
                color: "#FFFFFF",
                opacity: opacityPct / 100,
                shadow: true,
                showBox: showBoxToggle,
                boxColor: `rgba(0,0,0,${boxOpacityPct/100})`,
                placement: placementData.placement, // Use placement for server compatibility
                yPct: validatedYPct,                // Use validated yPct for precise positioning
                lineHeight: 1.05, // reduced for better stacking
                padding: 24,
                maxWidthPct: 0.90, // increased for bigger text
                borderRadius: 16
            };
            
            console.log('[caption-debug] Final captionStyle:', {
                placement: captionStyle.placement,
                yPct: captionStyle.yPct,
                text: captionStyle.text.substring(0, 50) + '...'
            });

            // Debounce caption generation
            clearTimeout(captionDebounceTimer);
            captionDebounceTimer = setTimeout(async () => {
                try {
                    console.log('[caption-overlay] Generating PNG preview...');
                    
                    // Import the caption preview function
                    const { generateCaptionPreview, getLastCaptionPNG, createCaptionOverlay } = await import('./js/caption-preview.js');
                    
                    // Generate caption PNG
                    await generateCaptionPreview(captionStyle);
                    const result = getLastCaptionPNG();
                    captionOverlayState = result;
                    
                    console.log('[caption-overlay] PNG preview generated:', result);
                    
                    // Calculate preview scaling using geometry helper
                    const previewContainer = document.getElementById('live-preview-container');
                    const previewCanvas = document.getElementById('live-preview-canvas');
                    const geometry = getPreviewGeometry(previewCanvas);
                    
                    // Debug logging for scaling
                    console.debug('[preview-scaling]', {
                        cssW: geometry.cssW,
                        cssH: geometry.cssH,
                        backingW: geometry.backingW,
                        backingH: geometry.backingH,
                        dpr: geometry.dpr,
                        scaleX: geometry.scaleX,
                        scaleY: geometry.scaleY,
                        ovW: result.meta?.wPx || 1080,
                        ovH: result.meta?.hPx || 1920,
                        placement: captionStyle.placement,
                        yPct: result.meta?.yPct,
                        fontPx: result.meta?.fontPx
                    });
                    
                    // Create and position the overlay image with placement
                    createCaptionOverlay(result, overlay, { 
                        previewW: geometry.cssW, 
                        previewH: geometry.cssH,
                        placement: captionStyle.placement
                    });
                    
                    // Debug logging
                    console.log('[preview-scaling]', { 
                        previewW: geometry.cssW, 
                        previewH: geometry.cssH 
                    });
                    
                    console.log('[caption-overlay] PNG overlay created successfully');
                    
                    // Log font fallback info if available
                    if (result.meta?.fontFamilyUsed) {
                        console.log('[caption-overlay] Font used:', result.meta.fontFamilyUsed);
                    }
                    
                } catch (error) {
                    console.error('[caption-overlay] Failed to generate PNG:', error);
                    console.error('[caption-overlay] Error details:', error.message);
                    
                    // TASK 7: Disable HTML fallback to prevent mega-sized text issues
                    // The fallback was causing the "yo" situation mentioned in the task
                    console.log('[caption-overlay] PNG generation failed, not using HTML fallback');
                    overlay.innerHTML = ''; // Clear overlay instead of showing fallback text
                }
            }, 300); // 300ms debounce
        }
        // Regen helpers: only decrement on LLM actions
        window.VAI = window.VAI || {};
        VAI.state = VAI.state || { regensLeft: 10 };
        (function initRegens(){
            const info = document.getElementById('regen-info');
            if (!info) return;
            const m = String(info.textContent||'').match(/(\d+)/);
            const initial = m ? parseInt(m[1],10) : 10;
            if (!Number.isFinite(VAI.state.regensLeft)) VAI.state.regensLeft = initial;
            info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        })();
        function setRegensLeft(n){
            VAI.state.regensLeft = Math.max(0, Number(n||0));
            const info = document.getElementById('regen-info');
            if (info) info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        }
        function decRegens(){
            setRegensLeft((VAI.state.regensLeft|0) - 1);
        }
        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function setLoading(buttonId, loading) {
            const button = document.getElementById(buttonId);
            button.disabled = loading;
            button.textContent = loading ? 'Loading...' : button.textContent.replace('Loading...', '');
        }

        // Load credits using existing system
        async function refreshCredits(force = true, retries = 1) {
            if (!window.auth?.currentUser) { 
                updateCreditUI(0); 
                return; 
            }
            try {
                // Use the apiFetch from the imported module
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch("/credits", { method: "GET" });
                const credits = Number(data?.credits ?? 0);
                updateCreditUI(Number.isNaN(credits) ? 0 : credits);
            } catch (err) {
                if (retries > 0) return refreshCredits(false, retries - 1);
                console.warn("Credits fetch failed:", err);
            }
        }

        function updateCreditUI(credits) {
            currentCredits = typeof credits === "number" ? credits : 0;
            const creditDisplay = document.getElementById('credit-display');
            const creditCount = document.getElementById('credit-count');
            if (creditDisplay) creditDisplay.classList.remove("hidden");
            if (creditCount) creditCount.textContent = String(currentCredits);
        }

        // Quote generation
        async function generateQuote() {
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to generate quotes');
                return;
            }
            
            const text = document.getElementById('quote-text').value;
            const tone = document.getElementById('quote-tone').value;
            
            if (!text.trim()) return;
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/generate-quote', {
                    method: 'POST',
                    body: {
                        text,
                        tone: tone === 'default' ? undefined : tone,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    displayQuote(currentQuote); // keep textarea visible (no toggle)
                    decRegens();
                    
                    // Trigger caption preview immediately after quote generation
                    try {
                        updateCaptionOverlay(currentQuote.text.trim(), true);
                    } catch (e) {
                        console.warn('[caption-overlay] auto-preview failed (non-fatal)', e);
                    }
                } else {
                    showError('quote-error', data.reason || 'Failed to generate quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        function displayQuote(quote) {
            document.getElementById('quote-text-display').textContent = quote.text;
            const editEl = document.getElementById('quote-edit');
            editEl.value = quote.text;
            // Always keep the inlaid editor visible
            document.getElementById('quote-text-display').classList.add('hidden');
            editEl.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            
            // Trigger preview when quote is available
            if (selectedAsset) {
                updateLivePreview();
                updateCaptionOverlay(quote.text.trim(), true);
            }
            
            // Update char counter from textarea content
            try {
              const cc = document.getElementById('quote-char-count');
              if (cc) cc.textContent = `${Math.min(200, (editEl.value||'').length)}/200`;
            } catch {}
            document.getElementById('quote-author').textContent = quote.author ? `‚Äî ${quote.author}` : '';
            document.getElementById('quote-author').classList.toggle('hidden', !quote.author);
            document.getElementById('quote-tone-tag').textContent = quote.toneTag ? `Tone: ${quote.toneTag}` : '';
            document.getElementById('quote-tone-tag').classList.toggle('hidden', !quote.toneTag);
            document.getElementById('quote-result').classList.remove('hidden');
            // Always expose LLM iterate buttons when a quote is present
            const remix = document.getElementById('remix-buttons');
            if (remix) remix.classList.remove('hidden');
            updateRenderPreview();
        }

        // Asset loading with pagination and caching
        async function loadAssets(page = 1) {
            if (currentAssetType === 'ai') return;
            if (!window.auth?.currentUser) {
                showError('asset-error', 'Please log in to load assets');
                return;
            }
            
            setLoading('search-assets-btn', true);
            hideError('asset-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const perPage = 12; // fuller grid per request
                const query = document.getElementById('asset-query').value;
                const cacheKey = `${currentAssetType}-${query}-${page}`;
                
                // Check cache first
                if (assetCache.has(cacheKey)) {
                    const cachedData = assetCache.get(cacheKey);
                    displayAssets(cachedData.items);
                    hasMoreAssets = cachedData.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                    setLoading('search-assets-btn', false);
                    return;
                }
                
                const data = await apiFetch('/assets/options', {
                    method: 'POST',
                    body: {
                        type: currentAssetType,
                        query,
                        page,
                        perPage
                    }
                });
                
                if (data.ok) {
                    // Cache the results
                    assetCache.set(cacheKey, {
                        items: data.data.items,
                        nextPage: data.data.nextPage
                    });
                    
                    displayAssets(data.data.items);
                    hasMoreAssets = data.data.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                } else {
                    showError('asset-error', data.reason || 'Failed to load assets');
                }
            } catch (error) {
                showError('asset-error', error.message || 'Network error');
            } finally {
                setLoading('search-assets-btn', false);
            }
        }

        function displayAssets(assets) {
            const grid = document.getElementById('asset-grid');
            grid.innerHTML = '';
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function appendAssets(assets) {
            const grid = document.getElementById('asset-grid');
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function createAssetElement(asset) {
            const div = document.createElement('div');
            div.className = `relative border-2 rounded overflow-hidden transition-colors group ${
                selectedAsset?.id === asset.id ? 'border-blue-500' : 'border-gray-700'
            }`;
            
            let media;
            if (asset.provider === 'ai' || asset.type === 'ai-generated') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
            } else if (currentAssetType === 'images') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
            } else {
                media = `<video src="${asset.fileUrl}" class="w-full h-32 object-cover" muted playsinline preload="metadata" onerror="this.style.display='none'"></video>`;
            }
            
            const attribution = asset.provider === 'ai' 
                ? '<div class="text-purple-400 truncate">AI Generated</div>'
                : asset.photographer 
                    ? `<div class="text-gray-400 truncate">by ${asset.photographer}</div>`
                    : '';
            
            div.innerHTML = `
                ${media}
                <div class="p-2 text-xs">
                    <div class="truncate">${asset.query}</div>
                    ${attribution}
                </div>
                <!-- Action Buttons Overlay -->
                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-all duration-200 flex items-end justify-center pb-2 opacity-0 group-hover:opacity-100">
                    <div class="flex gap-2">
                        <button 
                            class="use-asset-btn px-3 py-1 bg-blue-600 hover:bg-blue-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Use
                        </button>
                        <button 
                            class="remix-asset-btn px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Remix
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners for the buttons
            const useBtn = div.querySelector('.use-asset-btn');
            const remixBtn = div.querySelector('.remix-asset-btn');
            
            useBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                useAsset(asset);
            });
            
            remixBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                addToRemix(asset);
            });
            
            return div;
        }

        function selectAsset(asset) {
            selectedAsset = asset;
            // Re-render grid to update selection
            loadAssets(1);
            updateRenderPreview();
            updateRenderButtonState();
            
            // Trigger caption preview immediately after asset selection
            maybeGenerateCaptionPreview();
        }

        function updatePagination() {
            const container = document.getElementById('pagination-container');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const pageInfo = document.getElementById('page-info');
            
            if (currentAssetType === 'ai') {
                container.classList.add('hidden');
                return;
            }
            
            container.classList.remove('hidden');
            prevBtn.disabled = currentAssetPage <= 1;
            nextBtn.disabled = !hasMoreAssets;
            pageInfo.textContent = `Page ${currentAssetPage}`;
        }

        // Use asset function
        async function useAsset(asset) {
            selectedAsset = asset;
            
            // Initialize window.state if needed
            if (!window.state) window.state = {};
            window.state.selectedAsset = asset;
            
            // Special handling for Pexels assets - high-quality preview
            if (asset.provider === 'pexels' && asset.src) {
                // Ensure the asset has the photo data for later use
                selectedAsset.photo = asset.src;
                await onPexelsUse(asset.src);
            }
            
            updateRenderPreview();
            updateRenderButtonState();
            
            // Trigger preview when asset is used
            if (currentQuote) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
            
            // Scroll to render section
            document.getElementById('render-preview').scrollIntoView({ behavior: 'smooth' });
        }

        // High-quality Pexels preview handler with race protection
        async function onPexelsUse(photo) {
            const reqId = ++_previewReqId;
            _currentPexelsPhoto = photo; // Track for resize re-rendering

            const canvas = document.getElementById('live-preview-canvas');
            const container = canvas.parentElement;
            const cssW = container.clientWidth;
            const cssH = Math.round(cssW * 16 / 9);

            _setupHiDPICanvas(canvas, cssW, cssH);

            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const previewUrl = _pexelsPreviewUrlFromPhoto(photo, cssW * dpr, cssH * dpr, 1.2);

            // Persist both URLs for later redraws (resize/caption)
            if (!window.state) window.state = {};
            window.state.selectedAsset = {
                ...(window.state.selectedAsset || {}),
                provider: 'pexels',
                id: photo?.id,
                thumbUrl: photo?.src?.medium,
                previewUrl
            };
            
            // Also update the global selectedAsset to keep them in sync
            selectedAsset.previewUrl = previewUrl;

            console.log('[pexels-use] previewUrl', previewUrl);
            await _drawBackground(window.state.selectedAsset.previewUrl, canvas, cssW, cssH, 'bg:pexels-use');

            // Add write-trap to detect accidental overwrites
            try {
                const sa = window.state.selectedAsset;
                let _pv = sa.previewUrl;
                Object.defineProperty(sa, 'previewUrl', {
                    get() { return _pv; },
                    set(v) {
                        if (!_isHiResPreviewUrl(v)) {
                            console.warn('[trap] previewUrl being set to NON-hires url:', v);
                        }
                        _pv = v;
                    }
                });
            } catch {}
        }

        // Add to remix function
        function addToRemix(asset) {
            if (remixAssets.length >= 2) {
                showError('asset-error', 'Maximum 2 remix references allowed');
                return;
            }
            
            if (remixAssets.find(a => a.id === asset.id)) {
                showError('asset-error', 'Asset already in remix references');
                return;
            }
            
            remixAssets.push(asset);
            updateRemixArea();
        }

        // Update remix area display
        function updateRemixArea() {
            const remixArea = document.getElementById('remix-area');
            const remixAssetsContainer = document.getElementById('remix-assets');
            
            if (remixAssets.length === 0) {
                remixArea.classList.add('hidden');
                return;
            }
            
            remixArea.classList.remove('hidden');
            remixAssetsContainer.innerHTML = '';
            
            remixAssets.slice(0,2).forEach((asset, index) => {
                const assetDiv = document.createElement('div');
                assetDiv.className = 'relative w-20 h-20 rounded overflow-hidden border border-gray-600';
                
                const media = asset.provider === 'ai' || asset.type === 'ai-generated'
                    ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`
                    : currentAssetType === 'images'
                        ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`
                        : `<video src="${asset.fileUrl}" class="w-full h-full object-cover" muted playsinline preload="metadata" onerror="this.style.display='none'"></video>`;
                
                assetDiv.innerHTML = `
                    ${media}
                    <button 
                        class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 hover:bg-red-500 text-white text-xs rounded-full flex items-center justify-center"
                        onclick="removeFromRemix(${index})"
                    >
                        √ó
                    </button>
                `;
                
                remixAssetsContainer.appendChild(assetDiv);
            });
        }

        // Remove from remix
        function removeFromRemix(index) {
            remixAssets.splice(index, 1);
            updateRemixArea();
        }

        // Handle file upload
        function handleFileUpload(files) {
            if (!files || !files[0]) return;
            const file = files[0];
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const uploadedAsset = {
                    id: `uploaded-${Date.now()}`,
                    fileUrl: e.target.result,
                    thumbUrl: e.target.result,
                    query: file.name,
                    provider: 'uploaded',
                    type: file.type.startsWith('video/') ? 'video' : 'image'
                };
                
                uploadedAssets.push(uploadedAsset);
                
                // Add to current grid
                const grid = document.getElementById('asset-grid');
                const assetElement = createAssetElement(uploadedAsset);
                grid.insertBefore(assetElement, grid.firstChild);
            };
            
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else if (file.type.startsWith('video/')) {
                reader.readAsDataURL(file);
            }
        }

        function updateRenderPreview() {
            const preview = document.getElementById('render-preview');
            const renderBtn = document.getElementById('render-btn');
            
            if (currentQuote && selectedAsset) {
                document.getElementById('preview-quote').textContent = currentQuote.text;
                document.getElementById('preview-asset').textContent = 
                    `Background: ${selectedAsset.provider === 'ai' ? 'AI Image' : selectedAsset.provider === 'uploaded' ? 'Uploaded' : `${currentAssetType} - ${selectedAsset.query}`}`;
                
                // Update caption style preview
                const font = document.getElementById('caption-font').value;
                const weight = document.getElementById('caption-weight').value;
                const size = window.getCaptionPx();
                const opacity = document.getElementById('caption-opacity').value;
                const placement = document.getElementById('caption-placement').value;
                const background = document.getElementById('caption-background').checked;
                
                document.getElementById('preview-caption-style').textContent = 
                    `Caption: ${font} ${weight}, ${size}px, ${opacity}% opacity, ${placement}${background ? ', with background' : ''}`;
                
                // Update voiceover preview
                const voiceId = document.getElementById('voiceover-voice').value;
                const selectedVoice = availableVoices.find(v => v.id === voiceId);
                const voiceName = selectedVoice ? selectedVoice.name : 'Not selected';
                document.getElementById('preview-voiceover').textContent = `Voice: ${voiceName}`;
                
                preview.classList.remove('hidden');
                renderBtn.classList.remove('hidden');
                document.getElementById('live-preview-container').classList.remove('hidden');
                
                // Wait a frame for the container to be visible, then update preview
                requestAnimationFrame(() => {
                    updateLivePreview();
                    if (currentQuote) {
                        updateCaptionOverlay(currentQuote.text.trim(), true);
                    }
                });
            } else {
                preview.classList.add('hidden');
                renderBtn.classList.add('hidden');
                document.getElementById('live-preview-container').classList.add('hidden');
            }
            updateRenderButtonState();
        }

        // Update caption style values
        function updateCaptionStyleValues() {
            const px = window.getCaptionPx();
            document.getElementById('size-value').textContent = `${px}px`;
            document.getElementById('opacity-value').textContent = document.getElementById('caption-opacity').value + '%';
            document.getElementById('bg-opacity-value').textContent = document.getElementById('caption-bg-opacity').value + '%';
            updateRenderPreview();
            updateLivePreview();
            try { updateCaptionOverlay((currentQuote?.text||'').trim(), true); } catch {}
        }

        // Fix B: Set the canvas backing store AFTER CSS size exists
        function sizeCanvasToCSS(canvas) {
            const wCSS = canvas.clientWidth;
            const hCSS = canvas.clientHeight;
            if (wCSS === 0 || hCSS === 0) return false;

            const dpr = window.devicePixelRatio || 1;
            const wBS = Math.round(wCSS * dpr);
            const hBS = Math.round(hCSS * dpr);

            if (canvas.width !== wBS || canvas.height !== hBS) {
                canvas.width = wBS;
                canvas.height = hBS;
            }
            return true;
        }

        // Fix C: Robust "wait for ready" without infinite loop
        async function waitForCanvasReady(canvas, { timeoutMs = 2000 } = {}) {
            const start = performance.now();

            return new Promise((resolve, reject) => {
                const check = () => {
                    const connected = canvas?.isConnected;
                    const rect = canvas?.getBoundingClientRect();
                    const container = document.getElementById('live-preview-container');
                    const containerVisible = container && !container.classList.contains('hidden');
                    const ready = connected && rect && rect.width > 0 && rect.height > 0 && containerVisible;

                    if (ready && sizeCanvasToCSS(canvas)) {
                        resolve(true);
                        return;
                    }
                    if (performance.now() - start > timeoutMs) {
                        reject(new Error('Canvas not ready: no size within timeout'));
                        return;
                    }
                    requestAnimationFrame(check);
                };
                check();
            });
        }

        // Fix E: Initialize preview system with proper canvas readiness check
        async function initPreviewSystem() {
            const canvas = document.getElementById('live-preview-canvas');
            const container = document.getElementById('live-preview-container');
            
            if (!canvas || !container) {
                console.warn('[preview-init] Canvas or container not found');
                return;
            }
            
            try {
                await waitForCanvasReady(canvas);
                console.log('[preview-init] Canvas ready, initializing preview system');
                // Trigger initial preview if we have content
                if (currentQuote?.text && selectedAsset) {
                    updateLivePreview();
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            } catch (e) {
                console.warn('[preview-init] giving up:', e.message);
                // Optional: fall back to a default 360x640 CSS size and retry once
            }
        }

        // Manual trigger function for debugging
        function forcePreviewUpdate() {
            console.log('[preview-debug] Forcing preview update');
            if (currentQuote && selectedAsset) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            } else {
                console.log('[preview-debug] Missing quote or asset:', { 
                    hasQuote: !!currentQuote, 
                    hasAsset: !!selectedAsset 
                });
            }
        }

        // Make it globally available for debugging
        window.forcePreviewUpdate = forcePreviewUpdate;

        // Initialize caption size UI (safe DOM ready wrapper)
        function initCaptionSizeUI(){
          const el = document.getElementById('caption-size');
          const label = document.getElementById('size-value');
          if (!el || !label) return;
          
          function update() {
            try {
              const px = getCaptionPx(); // use the hoisted function
            label.textContent = `${px}px`;
              // refresh preview overlay without blocking rest of UI
              queueCaptionOverlayRefresh();
              // also update other caption style values
              if (typeof updateCaptionStyleValues === 'function') {
                updateCaptionStyleValues();
              }
            } catch (err) {
              console.error('[caption-size] update failed:', err);
            }
          }

          el.addEventListener('input', update);
          update(); // initial paint
        }
        
        // --- robust page bootstrap (run after DOM is ready)
        document.addEventListener('DOMContentLoaded', async () => {
          // Wrap each init so one failure doesn't stop the others
          const safe = (label, fn) => { try { fn && fn(); } catch (e) { console.error(`[init] ${label} failed`, e); } };

          // PRIORITY: Initialize assets after auth is ready
          (async () => {
            try {
              console.log('[init] Starting asset browser initialization...');
              // Wait for auth to settle once, then decide what to do
              const ok = await ensureLoggedInOrWarn();
              // If logged in (or you want to allow anonymous browsing anyway), kick off first load
              if (ok) {
                const activeType = getActiveAssetType();   // 'images' | 'videos' | 'ai'
                const q = (document.getElementById('asset-query')?.value || 'nature').trim();
                const grid = document.getElementById(`${activeType}-grid`) ||
                             document.querySelector(`[data-grid="${activeType}"]`) ||
                             document.getElementById('asset-grid');
                
                console.log('[assets] Checking initial load:', { activeType, gridEmpty: grid?.childElementCount === 0, query: q });

            if (grid && grid.childElementCount === 0) {
                  console.log('[assets] Loading initial assets for', activeType);
              if (typeof loadAssets === 'function') {
                    currentAssetType = activeType; // Set the global state
                    await loadAssets(1); // Wait for assets to load
              } else {
                console.warn('[assets] loadAssets function not found');
              }
            }
              }
            } catch (e) {
              console.error('[init] Asset browser initialization failed:', e);
            }
          })();

          // Trigger caption preview if we have text and asset
          safe('caption-preview-init', () => maybeGenerateCaptionPreview());

          // SECONDARY: Initialize caption UI (non-blocking)
          safe('caption-size', () => (typeof initCaptionSizeUI === 'function') && initCaptionSizeUI());

          // Asset browser setup is now handled above in priority section

          // Re-load when switching tabs if nothing is shown yet
          safe('assets-tab-wiring', () => {
            const tabs = document.querySelectorAll('[data-type]');
            tabs.forEach(tab => {
              tab.addEventListener('click', () => {
                setTimeout(() => { // Small delay to let tab switching complete
                  const kind = tab.dataset.type; // 'images' | 'videos' | 'ai'
                  const grid = document.getElementById(`${kind}-grid`) ||
                               document.querySelector(`[data-grid="${kind}"]`) ||
                               document.getElementById('assets-grid');
                  const qEl  = document.getElementById('asset-query') ||
                               document.querySelector('[data-asset-query]') ||
                               document.querySelector('input[placeholder*="nature"]');
                  const query = (qEl?.value || 'nature').trim();

                  console.log('[assets] Tab clicked:', { kind, gridEmpty: grid?.childElementCount === 0, query });

                  if (grid && grid.childElementCount === 0) {
                    console.log('[assets] Loading assets for tab', kind);
                    if (typeof loadAssets === 'function') {
                      currentAssetType = kind; // Set the global state
                      loadAssets(1);
                    }
                  }
                }, 100);
              }, { passive: true });
            });
          });
        });

        // Update render button state based on validation
        function updateRenderButtonState() {
            const renderBtn = document.getElementById('render-btn');
            const hasValidAsset = selectedAsset && (selectedAsset.fileUrl || selectedAsset.url);
            const hasQuote = currentQuote;
            const isLoggedIn = window.auth?.currentUser;
            
            const canRender = hasValidAsset && hasQuote && isLoggedIn;
            renderBtn.disabled = !canRender;
            
            if (!canRender) {
                let reason = '';
                if (!isLoggedIn) reason = 'Please log in';
                else if (!hasQuote) reason = 'Please select a quote';
                else if (!hasValidAsset) reason = 'Please select a valid asset';
                
                renderBtn.title = reason;
            } else {
                renderBtn.title = 'Ready to render';
            }
        }

        // Fix C: Live preview functionality without infinite retry
        function updateLivePreview() {
            if (!currentQuote || !selectedAsset) return;
            
            const container = document.getElementById('live-preview-container');
            const canvas = document.getElementById('live-preview-canvas');
            
            // Check if container is visible first
            if (!container || container.classList.contains('hidden')) {
                console.log('[preview-scaling] Container not visible, skipping preview');
                return;
            }
            
            // Fix C: Check if canvas has real dimensions, but don't retry infinitely
            if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                console.log('[preview-scaling] Canvas not ready, skipping preview');
                return;
            }
            
            container.classList.remove('hidden');
            
            // If a <video> is present for preview, hide overlay to avoid double text
            try {
                const ov = document.getElementById('caption-overlay');
                const hasVideo = !!document.querySelector('#live-preview-container video, #preview-holder video');
                if (ov) ov.style.display = hasVideo ? 'none' : 'block';
            } catch {}

            // 9:16 CSS sizing + HiDPI backing
            const { cssW, cssH } = layoutPreviewDims();
            const { ctx } = _setupHiDPICanvas(canvas, cssW, cssH);

            // Choose the background URL from whatever the app thinks it should be
            let url = selectedAsset?.previewUrl || selectedAsset?.url || selectedAsset?.thumbUrl || selectedAsset?.fileUrl;
            
            // >>> Insert this one line to force hi-res for Pexels:
            url = _ensureHiResPreviewUrl(url, canvas);

            // Load & draw the background
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.decoding = 'async';
            img.src = url;
            
            img.onload = () => {
                // COVER draw (no stretching)
                drawCover(ctx, img, cssW, cssH);
                
                // Debug
                window._currentPreviewUrl = url;
                _tapCanvas('bg:updateLivePreview');
            };
        }

        function drawCaptionOverlay(ctx, canvasWidth, canvasHeight) {
            if (!currentQuote) return;
            
            const font = document.getElementById('caption-font').value;
            const weight = document.getElementById('caption-weight').value;
            const size = window.getCaptionPx();
            const opacity = parseInt(document.getElementById('caption-opacity').value) / 100;
            const placement = document.getElementById('caption-placement').value;
            const showBackground = document.getElementById('caption-background').checked;
            const bgOpacity = parseInt(document.getElementById('caption-bg-opacity').value) / 100;
            
            // Set font - ensure weight mapping matches FFmpeg
            const cssWeight = (String(weight).toLowerCase() === 'bold' || Number(weight) >= 600) ? 'bold' : 'normal';
            ctx.font = `${cssWeight} ${size}px ${getFontFamily(font)}`;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add stroke to match FFmpeg rendering
            ctx.lineWidth = 3;
            ctx.strokeStyle = `rgba(0, 0, 0, 0.85)`;
            ctx.miterLimit = 2;
            
            // Calculate text position
            let y;
            const padding = 20;
            switch (placement) {
                case 'top':
                    y = padding + size / 2;
                    break;
                case 'middle':
                    y = canvasHeight / 2;
                    break;
                case 'bottom':
                    y = canvasHeight - padding - size / 2;
                    break;
            }
            
            // Wrap text if needed
            const maxWidth = canvasWidth - 40;
            const words = currentQuote.text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw background if enabled
            if (showBackground) {
                const lineHeight = size * 1.2;
                const totalHeight = lines.length * lineHeight;
                const bgY = y - totalHeight / 2;
                const bgHeight = totalHeight + padding;
                const bgWidth = canvasWidth - 20;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${bgOpacity})`;
                ctx.fillRect(10, bgY - padding / 2, bgWidth, bgHeight);
            }
            
            // Draw text lines
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            const lineHeight = size * 1.2;
            const startY = y - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                const x = canvasWidth / 2;
                const y = startY + index * lineHeight;
                
                // Draw stroke first (matches FFmpeg layering)
                ctx.strokeText(line, x, y);
                // Draw fill text on top
                ctx.fillText(line, x, y);
            });
        }

        function getFontFamily(font) {
            const fontMap = {
                'system': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif',
                'bold': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif', 
                'cinematic': 'DejaVu Sans Local, Georgia, serif',
                'minimal': 'DejaVu Sans Local, Helvetica, Arial, sans-serif'
            };
            return fontMap[font] || 'DejaVu Sans Local, system-ui, sans-serif';
        }

        // Compute preview-fitted lines using canvas metrics to mirror overlay width
        function computeFittedTextForPreview(text, { font, weight, sizePx, previewWidthPx }) {
            try {
                const raw = String(text || '').trim();
                if (!raw) {
                    return '';
                }
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const family = "DejaVu Sans Local";
                const weightCss = (String(weight).toLowerCase() === 'bold') ? '700' : '400';
                const size = Math.max(10, Number(sizePx) || 48);
                ctx.font = `${weightCss} ${size}px ${family}`;
                
                // Match overlay: max content width ‚âà 92% of preview width
                const maxWidth = Math.max(20, Math.round((Number(previewWidthPx)||360) * 0.92));
                
                const words = raw.split(/\s+/);
                const lines = [];
                let cur = '';
                for (const w of words) {
                    const next = cur ? cur + ' ' + w : w;
                    const width = ctx.measureText(next).width;
                    if (width > maxWidth && cur) { lines.push(cur); cur = w; } else { cur = next; }
                }
                if (cur) lines.push(cur);
                
                const result = lines.join('\n');
                return result;
            } catch (error) {
                return String(text || '').trim();
            }
        }

        // Voice loading and preview functions
        window.loadVoices = async function loadVoices() {
            try {
                // Wait for auth to be ready
                if (!window.auth?.currentUser) {
                    // Wait a bit for auth to initialize
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (!window.auth?.currentUser) {
                        showError('voice-preview-status', 'Please log in to load voices');
                        return;
                    }
                }

                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/voice/voices', {
                    method: 'GET'
                });

                if (data.success) {
                    availableVoices = data.data.voices;
                    populateVoiceSelect();
                    hideError('voice-preview-status');
                } else {
                    showError('voice-preview-status', data.error || 'Failed to load voices');
                }
            } catch (error) {
                console.error('Voice loading error:', error);
                showError('voice-preview-status', error.message || 'Network error');
            }
        }

        function populateVoiceSelect() {
            const select = document.getElementById('voiceover-voice');
            const retryBtn = document.getElementById('retry-voices-btn');
            select.innerHTML = '';
            
            if (availableVoices.length === 0) {
                select.innerHTML = '<option value="">No voices available</option>';
                retryBtn.title = 'Retry loading voices';
                return;
            }

            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = `${voice.name} - ${voice.description}`;
                select.appendChild(option);
            });

            // Enable preview button and hide retry button
            document.getElementById('preview-voice-btn').disabled = false;
            retryBtn.style.display = 'none';
        }

        async function previewVoice() {
            const voiceSelect = document.getElementById('voiceover-voice');
            const voiceId = voiceSelect.value;
            
            if (!voiceId || voiceId === '') {
                showError('voice-preview-status', 'Please select a voice');
                return;
            }

            const statusEl = document.getElementById('voice-preview-status');
            const previewBtn = document.getElementById('preview-voice-btn');
            const audioEl = document.getElementById('voice-preview-audio');

            statusEl.classList.remove('hidden');
            statusEl.textContent = 'Generating preview...';
            previewBtn.disabled = true;

            try {
                console.log('Voice preview - voiceId:', voiceId);
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/voice/preview', {
                    method: 'POST',
                    body: {
                        voiceId,
                        text: 'Hello, this is a preview of my voice. How does it sound?'
                    }
                });
                
                console.log('Voice preview response:', data);

                if (data.success) {
                    audioEl.src = data.data.audio;
                    audioEl.classList.remove('hidden');
                    statusEl.textContent = 'Preview ready - click play to listen';
                    
                    // Auto-play the preview
                    audioEl.play().catch(e => {
                        console.log('Auto-play prevented:', e);
                        statusEl.textContent = 'Preview ready - click play to listen';
                    });
                } else {
                    showError('voice-preview-status', data.error || 'Failed to generate preview');
                }
            } catch (error) {
                showError('voice-preview-status', error.message || 'Network error');
            } finally {
                previewBtn.disabled = false;
            }
        }

        // Helper function for better error messages
        function summarizeCreateError(err) {
            try {
                const msg = String(err?.message || err);
                const json = JSON.parse(msg.replace(/^Error:\s*/, ''));
                const fe = json?.detail?.fieldErrors || {};
                if (fe.caption?.length) return `Caption: ${fe.caption.join(', ')}`;
            } catch {}
            return null;
        }


        // Helper functions for payload construction
        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        
        // Drop undefined keys before fetch; keeps payload clean
        function stripUndefined(obj) {
            return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined));
        }

        // Render short function
        async function renderShort() {
            if (!currentQuote || !selectedAsset) {
                alert('Please select a quote and an asset first');
                return;
            }

            if (!window.auth?.currentUser) {
                alert('Please log in to render shorts');
                return;
            }

            const renderBtn = document.getElementById('render-btn');
            const originalText = renderBtn.textContent;
            
            renderBtn.disabled = true;
            renderBtn.textContent = 'Rendering...';

            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Prepare the render payload with proper background structure
                const assetUrl = selectedAsset.fileUrl || selectedAsset.url;
                
                // Detect type from URL extension
                const detectTypeFromUrl = (url) => {
                    if (!url) return 'image'; // Default fallback
                    
                    try {
                        // Handle URLs with query parameters or fragments
                        const cleanUrl = url.split('?')[0].split('#')[0];
                        const ext = cleanUrl.toLowerCase().split('.').pop();
                        
                        console.log(`[typeDetection] URL: ${url}`);
                        console.log(`[typeDetection] Clean URL: ${cleanUrl}`);
                        console.log(`[typeDetection] Extension: ${ext}`);
                        
                        if (['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', '3gp', 'flv'].includes(ext)) {
                            return 'video';
                        }
                        if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg', 'tiff'].includes(ext)) {
                            return 'image';
                        }
                        
                        // Default fallback
                        console.log(`[typeDetection] Unknown extension: ${ext}, defaulting to image`);
                        return 'image';
                    } catch (error) {
                        console.error(`[typeDetection] Error parsing URL: ${error.message}`);
                        return 'image'; // Safe fallback
                    }
                };
                
                const detectedType = detectTypeFromUrl(assetUrl);
                
                console.log(`[render] Asset URL: ${assetUrl}`);
                console.log(`[render] Detected type: ${detectedType}`);
                
                const background = {
                    kind: selectedAsset.provider === 'ai' ? 'ai' : 
                          selectedAsset.provider === 'uploaded' ? 'upload' : 'stock',
                    type: detectedType, // Use detected type from URL
                    url: assetUrl, // Required URL
                    query: selectedAsset.query,
                    // Legacy fields for backward compatibility
                    imageUrl: selectedAsset.provider === 'uploaded' ? selectedAsset.fileUrl : undefined,
                    prompt: selectedAsset.provider === 'ai' ? selectedAsset.query : undefined
                };

                // Get caption style settings
                const captionStyle = {
                    font: document.getElementById('caption-font').value,
                    weight: document.getElementById('caption-weight').value,
                    sizePx: window.getCaptionPx(),
                    opacity: parseInt(document.getElementById('caption-opacity').value) / 100,
                    placement: document.getElementById('caption-placement').value,
                    showBox: document.getElementById('caption-background').checked,
                    boxOpacity: parseInt(document.getElementById('caption-bg-opacity').value) / 100
                };
                
                // --- BEGIN strictly-typed payload construction ---

                // 1) Get current quote text safely as a string
                const quoteText = ((currentQuote && currentQuote.text) || '').toString();

                // 2) Get mapped and clamped font size
                const sizePx = window.getCaptionPx();

                // 3) Find last generated overlay from preview step
                //    (caption-preview.js should already be writing this)
                const overlay = window.__lastCaptionOverlay;
                // overlay shape we expect: { dataUrl: 'data:image/png;base64,...', width, height, meta: {...} }
                const overlayDataUrl = overlay && typeof overlay.dataUrl === 'string' ? overlay.dataUrl : undefined;

                // 4) Voice handling (don't change existing selection logic‚Äîjust make sure we send strings)
                const voiceId = (currentVoiceId || '').toString();
                const wantVoiceover = !!currentVoiceId; // keep existing toggle, but normalize to boolean

                // 5) Background (use what the page already computed)
                const bg = background; // must be whatever your UI already sets up

                // 6) Build payload with correct conditional logic
                let payload = {
                  mode: 'quote',
                  template: 'calm',
                  durationSec: 8,
                  voiceover: wantVoiceover,
                  includeBottomCaption: true,
                  wantAttribution: true,
                  watermark: true,

                  // strings only
                  text: quoteText,
                  ttsText: wantVoiceover ? quoteText : '',

                  // keep existing background contract
                  background: bg,

                  // pass voice id only if voiceover is on (string type)
                  voiceId: wantVoiceover && voiceId ? voiceId : undefined,
                };

                // IMPORTANT: caption vs overlay ‚Äì never send caption as an object
                if (overlayDataUrl) {
                  payload.captionImage = overlayDataUrl;            // string data URL
                  // do NOT include payload.caption at all when overlay is present
                } else {
                  payload.caption = sizePx;                  // number (not object)
                  payload.captionMode = 'static';    // keep if you already send it
                  // Only include style if your backend expects it when no overlay:
                  payload.captionStyle = {
                    placement: captionStyle.placement || 'bottom',        // e.g. 'top' | 'center' | 'bottom'
                    align: 'center',                // if you have it
                    opacity: clamp(captionStyle.opacity || 0.8, 0, 1),            // 0..1 if applicable
                    weight: captionStyle.weight || 'bold',              // 'normal' | 'bold'
                    font: captionStyle.font || 'DejaVu Sans Local',                  // 'system' | 'bold' etc if used by API
                  };
                }

                // remove undefined keys so contract stays clean
                payload = stripUndefined(payload);

                // 7) Log minimal, type-focused debug
                console.debug('[render] payload.types', {
                  caption_type: typeof payload.caption,               // expect 'number' when no overlay, 'undefined' when overlay
                  captionImage_type: typeof payload.captionImage,     // 'string' when overlay present or 'undefined'
                  text_type: typeof payload.text,                     // 'string'
                  ttsText_type: typeof payload.ttsText,               // 'string'
                  voiceId_type: typeof payload.voiceId,               // 'string' or 'undefined'
                  hasOverlay: !!overlayDataUrl,                       // boolean for debugging
                  caption_value: payload.caption,                     // show actual value
                  mappedSizePx: sizePx,                            // show mapped font size
                });

                // --- END strictly-typed payload construction ---

                console.log('[render] Final payload:', payload);
                console.log('[render] Background object:', background);
                console.log('[render] Current voice ID:', currentVoiceId);

                // Final validation before sending
                if (background.url && background.type) {
                    const url = background.url.toLowerCase();
                    const isVideoUrl = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v'].some(ext => url.includes(`.${ext}`));
                    const isImageUrl = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].some(ext => url.includes(`.${ext}`));
                    
                    if (background.type === 'video' && !isVideoUrl) {
                        console.error('[validation] Type mismatch: type is video but URL is not a video');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                    if (background.type === 'image' && !isImageUrl) {
                        console.error('[validation] Type mismatch: type is image but URL is not an image');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                }

                const data = await apiFetch('/shorts/create', {
                    method: 'POST',
                    body: payload
                });

                if (data.success) {
                    // Success! Show the result
                    const result = data.data;
                    alert(`Short created successfully! Job ID: ${result.jobId}`);
                    
                    // Redirect to My Shorts page so user sees result immediately
                    try { window.location.href = `/my-shorts.html?new=${encodeURIComponent(result.jobId)}`; } catch {}
                    
                    // You could redirect to a results page or show the video here
                    // For now, we'll just show success
                    console.log('Render result:', result);
                } else {
                    alert(`Render failed: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Render error:', error); // includes stack trace
                
                const hint = summarizeCreateError(error);
                alert(`Render failed${hint ? ': ' + hint : ': ' + (error?.message || 'Unknown error')}`);
            } finally {
                renderBtn.disabled = false;
                renderBtn.textContent = originalText;
            }
        }

        // Remix quote function
        async function remixQuote(mode) {
            if (!currentQuote) return;
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to remix quotes');
                return;
            }
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/remix', {
                    method: 'POST',
                    body: {
                        // Prefer live textarea content so users don't need to hit Save first
                        originalText: (document.getElementById('quote-edit')?.value || currentQuote.text || '').trim(),
                        mode,
                        targetTone: mode === 'tone_shift' ? document.getElementById('quote-tone').value : undefined,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    displayQuote(currentQuote);
                    decRegens();
                    // Keep the editor visible with new text
                    try {
                      document.getElementById('quote-text-display').classList.add('hidden');
                      document.getElementById('quote-edit').classList.remove('hidden');
                      document.getElementById('save-quote-btn').classList.remove('hidden');
                      document.getElementById('cancel-quote-btn').classList.remove('hidden');
                      document.getElementById('edit-quote-btn').classList.add('hidden');
                    } catch {}
                } else {
                    showError('quote-error', data.reason || 'Failed to remix quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        // AI Image generation
        async function generateAiImage() {
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            // Check if user has sufficient credits (20 credits for AI generation)
            if (window.currentCredits < 20) {
                showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                return;
            }
            
            const prompt = document.getElementById('ai-prompt').value;
            const styleSlider = document.getElementById('ai-style-slider').value;
            
            if (!prompt.trim()) {
                showError('ai-error', 'Please enter a prompt');
                return;
            }
            
            setLoading('generate-ai-btn', true);
            hideError('ai-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Map slider value to style: 0-0.5 = realistic, 0.5-1 = cartoon
                const style = parseFloat(styleSlider) <= 0.5 ? 'realistic' : 'cartoon';
                
                // Map slider 0..1 ‚Üí ideogram style_type: closer to Realistic at 0, Creative at 1
                const creative = parseFloat(styleSlider);
                const styleType = creative < 0.33 ? 'Photographic' : (creative > 0.66 ? 'Illustration' : 'None');

                const data = await apiFetch('/generate', {
                    method: 'POST',
                    body: {
                        prompt,
                        style, // retained for compatibility
                        count: 1,
                        // ideogram params ride along; backend adapter maps them
                        params: { style_type: styleType },
                        options: {}
                    }
                });
                
                if (data?.ok === true && data?.data?.images) {
                    // Handle successful generation
                    const imgs = data.data.images || [];
                    const first = imgs[0];
                    const url = typeof first === 'string' ? first : (first?.url || first);
                    if (url) {
                        // Update credits display if successful (20 credits deducted by backend)
                        window.currentCredits -= 20;
                        if (window.updateCreditsDisplay) {
                            window.updateCreditsDisplay(window.currentCredits);
                        }
                        
                        const aiAsset = {
                            id: `ai-${Date.now()}`,
                            fileUrl: url,
                            thumbUrl: url,
                            width: 1080,
                            height: 1920,
                            query: prompt,
                            provider: 'ai',
                            type: 'ai-generated'
                        };
                        // Add to asset grid
                        const grid = document.getElementById('asset-grid');
                        const assetElement = createAssetElement(aiAsset);
                        grid.insertBefore(assetElement, grid.firstChild);
                        // Also show next to remix references if present
                        const aiBlock = document.getElementById('ai-result-block');
                        const aiPrev = document.getElementById('ai-result-preview');
                        if (aiBlock && aiPrev) {
                            aiPrev.innerHTML = `<img src="${aiAsset.thumbUrl}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
                            aiBlock.classList.remove('hidden');
                        }
                        // Auto-select the generated image
                        selectAsset(aiAsset);
                    } else {
                        showError('ai-error', 'No image URL returned');
                    }
                } else {
                    // Some backends use { ok:false, reason } envelope
                    showError('ai-error', (data && (data.reason || data.error)) || 'Failed to generate AI image');
                }
            } catch (error) {
                if (error?.reason === 'INSUFFICIENT_CREDITS') {
                    showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                } else {
                    showError('ai-error', error.message || 'Network error');
                }
            } finally {
                setLoading('generate-ai-btn', false);
            }
        }

        // Remix button handler: require at least 1 reference, prefer 2
        document.addEventListener('click', (e) => {
            const t = e.target;
            if (!t || t.id !== 'remix-generate-btn') return;
            e.preventDefault();
            
            // Check if user is logged in
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            // Check if user has sufficient credits (20 credits for AI generation)
            if (window.currentCredits < 20) {
                showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                return;
            }
            
            // Collect refs + prompt + style, then call generate endpoint
            const base = document.getElementById('ai-prompt');
            const prompt = (base?.value || '').trim();
            const styleSlider = document.getElementById('ai-style-slider');
            const sVal = parseFloat(styleSlider?.value || '0.5');
            const style = sVal < 0.33 ? 'realistic' : (sVal > 0.66 ? 'creative' : 'realistic');

            const refs = Array.from(document.querySelectorAll('#remix-assets img, #remix-assets video'))
              .map((el)=> el.getAttribute('src') || el.getAttribute('poster'))
              .filter(Boolean)
              .filter((v, i, arr) => arr.indexOf(v) === i)
              .slice(0,2);

            // Fallback to simple text-to-image if no refs
            if (refs.length < 2) {
              generateAiImage();
              return;
            }

            // Use existing assets API for AI image generation (single image)
            // We reuse the /assets/ai-images for now with count:1
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                // Compose a richer prompt mentioning references implicitly
                const styleMap = style === 'creative' ? 'illustration' : 'photographic';
                const data = await apiFetch('/assets/ai-images', { method:'POST', body: { prompt: `${prompt}`.trim(), style: style === 'creative' ? 'creative' : 'realistic', count: 1 } });
                console.log('[AI Image] Response:', data); // Debug log
                if (!data?.ok || !data?.data?.images || data.data.images.length === 0) {
                    console.error('[AI Image] Failed:', data);
                    showError('ai-error', 'AI image generation failed'); 
                    return; 
                }
                
                const firstImage = data.data.images[0];
                const url = firstImage?.url || null;
                if (!url) { showError('ai-error', 'No image URL in response'); return; }
                
                // Update credits display if successful
                if (data?.data?.creditsDeducted) {
                    window.currentCredits -= data.data.creditsDeducted;
                    if (window.updateCreditsDisplay) {
                        window.updateCreditsDisplay(window.currentCredits);
                    }
                }
                
                // Display result
                const aiBlock = document.getElementById('ai-result-block');
                const aiPrev = document.getElementById('ai-result-preview');
                if (aiBlock && aiPrev) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(url)}`;
                  aiPrev.innerHTML = `<img crossOrigin="anonymous" src="${proxied}" class="w-full h-full object-cover block" />`;
                  aiBlock.classList.remove('hidden');
                }
              } catch (err) {
                if (err?.reason === 'INSUFFICIENT_CREDITS') {
                    showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                } else {
                    showError('ai-error', err?.message || 'AI generation error');
                }
              }
            })();
        });

        // Save & Use handler: persists image URL and marks as selected background
        document.addEventListener('click', async (e) => {
            if (e.target?.id !== 'ai-save-use-btn') return;
            e.preventDefault();
            try {
              const imgEl = document.querySelector('#ai-result-preview img');
              const url = imgEl?.getAttribute('src');
              if (!url) return;
              const { apiFetch } = await import('./api.mjs');
              // Store the image in storage and get a tokenized URL
              const reg = await apiFetch('/uploads/register', { method:'POST', body:{ imageUrl: url } });
              const savedUrl = reg?.data?.url || url;
              // Mark selection locally and update preview immediately
              selectedAsset = { id: `ai-${Date.now()}`, provider: 'ai', query: (document.getElementById('ai-prompt')?.value||'').trim(), fileUrl: savedUrl, thumbUrl: savedUrl, width: 1080, height: 1920 };
              updateRenderPreview();
              updateRenderButtonState();
              // Also update dedicated preview nodes if present
              try {
                // Ensure we have a preview <img id="preview-img"> inside live preview
                let previewImg = document.getElementById('preview-img');
                if (!previewImg) {
                  const live = document.getElementById('live-preview-container');
                  if (live) {
                    live.classList.remove('hidden');
                    const holder = live.querySelector('.relative') || live;
                    // Force 9x16 preview aspect
                    try { holder.style.aspectRatio = '9 / 16'; } catch {}
                    try { if (!holder.style.background) holder.style.background = '#000'; } catch {}
                    // Clear holder if it only had a canvas (we'll still keep canvas for other flows)
                    // but append img above it so swap is visible immediately
                    previewImg = document.createElement('img');
                    previewImg.id = 'preview-img';
                    previewImg.style.width = '100%';
                    previewImg.style.height = '100%';
                    previewImg.style.display = 'block';
                    previewImg.style.objectFit = 'cover';
                    holder.prepend(previewImg);
                    // Hide canvas during static image preview to avoid black overlay
                    try { const c = holder.querySelector('#live-preview-canvas'); if (c) c.style.display = 'none'; } catch {}
                  }
                }
                if (previewImg) {
                  try { previewImg.crossOrigin = 'anonymous'; } catch {}
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewImg.src = proxied;
                }
                // Ensure overlay visible for still image preview
                try { const ov = document.getElementById('caption-overlay'); if (ov) ov.style.display = 'block'; } catch {}
                const previewBox = document.getElementById('short-preview');
                if (previewBox) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewBox.style.backgroundImage = `url("${proxied}")`;
                  previewBox.setAttribute('data-bg', proxied);
                }
                window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentBackgroundUrl = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
              } catch {}
              // Feedback
              try { showToast('‚úÖ Saved to My Images and selected'); } catch {}
            } catch (err) {
              console.warn('Save & Use failed:', err);
            }
        });

        // Event listeners
        document.getElementById('generate-quote-btn').onclick = generateQuote;
        document.getElementById('use-text-btn').onclick = () => {
            const input = document.getElementById('quote-text').value.trim();
            if (!input) return;
            currentQuote = { text: input };
            displayQuote(currentQuote);
            // Ensure visible in view mode on use
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.classList.add('hidden');
            disp.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            // do not reset regen counter here
            // Persist immediately so it can be used for the short without extra clicks
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                await apiFetch('/quotes/save', { method:'POST', body:{ text: input, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
                try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = input; } catch {}
              } catch (e) {
                console.warn('Use This Text save failed:', e?.message || e);
              }
            })();
            
            // Trigger caption preview immediately after using text
            try {
                updateCaptionOverlay(input, true);
            } catch (e) {
                console.warn('[caption-overlay] auto-preview failed (non-fatal)', e);
            }
        };
        document.getElementById('search-assets-btn').onclick = () => {
            assetCache.clear(); // Clear cache on new search
            loadAssets(1);
        };
        document.getElementById('prev-page-btn').onclick = () => loadAssets(currentAssetPage - 1);
        document.getElementById('next-page-btn').onclick = () => loadAssets(currentAssetPage + 1);
        try { document.getElementById('generate-ai-btn').onclick = generateAiImage; } catch {}
        document.getElementById('upload-asset-btn').onclick = () => {
            document.getElementById('asset-upload-input').click();
        };
        document.getElementById('asset-upload-input').onchange = (e) => handleFileUpload(e.target.files);
        document.getElementById('clear-remix-btn').onclick = () => {
            remixAssets = [];
            updateRemixArea();
        };
        document.getElementById('render-btn').onclick = renderShort;
        
        // Caption style event listeners
        document.getElementById('caption-font').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-weight').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        // Legacy caption-size handler removed - now handled by initCaptionSizeUI()
        document.getElementById('caption-opacity').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        document.getElementById('caption-placement').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-background').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-bg-opacity').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        
        // Voiceover event listeners
        document.getElementById('voiceover-voice').onchange = () => {
            const voiceSelect = document.getElementById('voiceover-voice');
            currentVoiceId = voiceSelect.value || null;
            updateRenderPreview();
        };
        document.getElementById('preview-voice-btn').onclick = previewVoice;

        // Remix button event listeners (success-only decrement handled inside)
        try { document.getElementById('regenerate-btn').onclick = () => remixQuote('regenerate'); } catch {}
        try { document.getElementById('rephrase-btn').onclick = () => remixQuote('rephrase'); } catch {}
        try { document.getElementById('tone-shift-btn').onclick = () => remixQuote('tone_shift'); } catch {}

        // Inline edit handlers
        try { document.getElementById('edit-quote-btn').onclick = () => {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.value = (currentQuote?.text || '').trim();
            disp.classList.add('hidden');
            ta.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            // While editing, hide caption overlay
            updateCaptionOverlay('', false);
        }; } catch {}
        try { document.getElementById('cancel-quote-btn').onclick = () => {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            // remain in edit mode but clear contents
            ta.value = '';
            updateCaptionOverlay('', false);
            // do not change regen counter
        }; } catch {}
        document.getElementById('save-quote-btn').onclick = async () => {
            const ta = document.getElementById('quote-edit');
            const newText = ta.value.trim().slice(0, 200);
            if (!newText) return;
            currentQuote = { ...(currentQuote||{}), text: newText };
            document.getElementById('quote-text-display').textContent = newText;
            // do not reset regen counter on save
            // switch to locked/solid view after save
            ta.classList.add('hidden');
            document.getElementById('quote-text-display').classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            updateRenderPreview();
            updateCaptionOverlay(newText, true);

            // Persist to backend so it can be used in the short without CORS issues
            try {
              const { apiFetch } = await import('./api.mjs');
              await apiFetch('/quotes/save', { method: 'POST', body: { text: newText, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
              try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = newText; } catch {}
            } catch (e) {
              console.warn('Quote save failed (non-fatal):', e?.message || e);
            }
        };

        // Character counter for input
        document.getElementById('quote-text').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
        });

        // Also update counter when typing inside the inlaid editor
        document.getElementById('quote-edit').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
            // live overlay while editing
            try { updateCaptionOverlay(v, true); } catch {}
        });

        // Resize listener for zoom/resize scenarios - re-render preview
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (selectedAsset) {
                    if (_currentPexelsPhoto && selectedAsset?.provider === 'pexels') {
                        // Preserve existing previewUrl when updating selectedAsset
                        const existingPreviewUrl = selectedAsset.previewUrl;
                        selectedAsset = { ...selectedAsset, ..._currentPexelsPhoto };
                        if (existingPreviewUrl) {
                            selectedAsset.previewUrl = existingPreviewUrl;
                        }
                        onPexelsUse(_currentPexelsPhoto);
                    } else {
                        // For non-Pexels assets, just redraw the preview
                        updateLivePreview();
                    }
                }
            }, 150); // Debounce resize events
        });

        // Tab switching
        document.querySelectorAll('[data-type]').forEach(tab => {
            tab.onclick = async () => {
                currentAssetType = tab.dataset.type;
                
                // Update tab styles
                document.querySelectorAll('[data-type]').forEach(t => {
                    t.className = 'px-4 py-2 rounded bg-gray-700';
                });
                tab.className = 'px-4 py-2 rounded bg-blue-600';
                
                // Show/hide controls
                const searchControls = document.getElementById('search-controls');
                const aiControls = document.getElementById('ai-controls');
                
                if (currentAssetType === 'ai') {
                    try { searchControls.classList.add('hidden'); } catch {}
                    try { aiControls && aiControls.classList.remove('hidden'); } catch {}
                } else {
                    try { searchControls.classList.remove('hidden'); } catch {}
                    try { aiControls && aiControls.classList.add('hidden'); } catch {}
                }
                
                // Clear cache and reset pagination for new type
                assetCache.clear();
                currentAssetPage = 1;
                
                // Load assets for new type with auth check
                if (currentAssetType !== 'ai') {
                    const ok = await ensureLoggedInOrWarn();
                    if (ok) {
                        try { 
                            await loadAssets(1); 
                        } catch (e) { 
                            console.warn('[assets] tab load failed', e); 
                        }
                    }
                }
            };
        });

        // Theme toggle functionality
        function initTheme() {
            const themeToggle = document.getElementById('theme-toggle');
            if (!themeToggle) return;

            // Set initial theme
            if (localStorage.getItem("theme") === "dark") {
                document.documentElement.classList.add("dark");
                themeToggle.textContent = "üåô";
            } else {
                document.documentElement.classList.remove("dark");
                themeToggle.textContent = "‚òÄÔ∏è";
            }

            // Theme toggle event listener
            themeToggle.addEventListener("click", () => {
                const isDark = document.documentElement.classList.toggle("dark");
                localStorage.setItem("theme", isDark ? "dark" : "light");
                themeToggle.textContent = isDark ? "üåô" : "‚òÄÔ∏è";
            });
        }

        // Initialize authentication using existing system
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme first
            initTheme();
            
            // Wait for auth system to be ready
            const checkAuth = () => {
                if (window.auth && window.onAuthStateChanged) {
                    // Listen for auth state changes
                    window.onAuthStateChanged(window.auth, async (user) => {
                        const loggedIn = !!user;
                        
                        // Update UI visibility
                        document.querySelectorAll(".logged-in")?.forEach(el => el.classList.toggle("hidden", !loggedIn));
                        document.querySelectorAll(".logged-out")?.forEach(el => el.classList.toggle("hidden", loggedIn));

                        if (!loggedIn) {
                            updateCreditUI(0);
                            updateRenderButtonState();
                            return;
                        }

                        try {
                            // Give api.mjs a brief moment to obtain the token via the bridge
                            if (window.__vaiform_diag__?.tokenWait) { 
                                await window.__vaiform_diag__.tokenWait(4000); 
                            }
                            await refreshCredits(true);
                            
                            // Update render button state after auth changes
                            updateRenderButtonState();
                            
                            // Load voices with a small delay to ensure auth is fully ready
                            setTimeout(() => {
                                loadVoices();
                            }, 500);
                        } catch (e) {
                            console.error("Failed to refresh credits:", e);
                        }
                    });
                } else {
                    // Retry in 100ms if auth not ready yet
                    setTimeout(checkAuth, 100);
                }
            };
            
            checkAuth();

            // Initialize quote editor for manual entry from the start
            try {
                const seedInput = document.getElementById('quote-text');
                const seed = (seedInput?.value || '').trim();
                // Use default caption if no seed text provided
                const defaultCaption = seed || 'Success is the result of persistent effort and unwavering belief in yourself.';
                currentQuote = { text: defaultCaption };
                displayQuote(currentQuote);
                // Switch to edit mode by default so users can type immediately
                const disp = document.getElementById('quote-text-display');
                const ta = document.getElementById('quote-edit');
                disp.classList.add('hidden');
                ta.classList.remove('hidden');
                document.getElementById('save-quote-btn').classList.remove('hidden');
                document.getElementById('cancel-quote-btn').classList.remove('hidden');
                document.getElementById('edit-quote-btn').classList.add('hidden');
                // Do not reset regen counter on init
                // Fix E: Initialize preview system after content is ready
                try { 
                    initPreviewSystem();
                    
                    // Fix E: Add ResizeObserver for canvas resizing
                    const canvas = document.getElementById('live-preview-canvas');
                    const container = document.getElementById('live-preview-container');
                    if (canvas && container) {
                        new ResizeObserver(() => {
                            if (sizeCanvasToCSS(canvas)) {
                                // Trigger preview update on resize
                                if (currentQuote?.text && selectedAsset) {
                                    updateLivePreview();
                                    updateCaptionOverlay(currentQuote.text.trim(), true);
                                }
                            }
                        }).observe(container);
                    }
                } catch (e) {
                    console.warn('[preview-init] failed:', e);
                }
                
                // Seed char counter
                const n = Math.min(200, defaultCaption.length);
                const cc = document.getElementById('quote-char-count');
                if (cc) cc.textContent = `${n}/200`;
            } catch {}
        });

        // Fix E: Ensure the first render actually fires
        window.addEventListener('load', () => {
            console.log('[preview-init] Page loaded, initializing preview');
            initPreviewSystem();
            
            // Also trigger preview if we already have both quote and asset
            if (currentQuote && selectedAsset) {
                console.log('[preview-init] Both quote and asset available, triggering preview');
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
        });
        
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('[preview-init] Tab visible, reinitializing preview');
                initPreviewSystem();
                
                // Also trigger preview if we already have both quote and asset
                if (currentQuote && selectedAsset) {
                    console.log('[preview-init] Both quote and asset available, triggering preview');
                    updateLivePreview();
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            }
        });
    </script>


</body>
</html>
