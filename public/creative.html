<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Studio - Vaiform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Unified Header and Auth -->
    <script type="module">
        import { createUnifiedHeader, initializeHeader } from "./components/header.js";
        import { initializeAuth } from "./components/auth-utils.js";
        
        // Load unified header
        document.getElementById('unified-header').innerHTML = createUnifiedHeader();
        initializeHeader();
        
        // Initialize auth after a short delay to ensure Firebase is ready
        setTimeout(() => {
            initializeAuth();
        }, 100);
    </script>
    
    <!-- Firebase SDK - Load the same way as main site -->
    <script type="module" src="./js/firebaseClient.js"></script>
    <!-- Auth bridge: expose auth & wire token provider before page code -->
    <script type="module" src="./auth-bridge.js"></script>
    <script type="module" src="./frontend.js"></script>
    <link rel="stylesheet" href="/creative.css" />
    <!-- Load DejaVu Sans font to match FFmpeg rendering -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DejaVu+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'DejaVu Sans Local';
            src: local('DejaVu Sans'), local('DejaVuSans'), url('https://fonts.gstatic.com/s/dejavusans/v1/DejaVuSans.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'DejaVu Sans Local';
            src: local('DejaVu Sans Bold'), local('DejaVuSans-Bold'), url('https://fonts.gstatic.com/s/dejavusans/v1/DejaVuSans-Bold.woff2') format('woff2');
            font-weight: bold;
            font-style: normal;
        }
    </style>
    <style>
        .loading { opacity: 0.6; pointer-events: none; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        
        /* Force dark mode for content boxes */
        .dark .content-box {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        .dark .content-box h2 {
            color: #ffffff !important;
        }
    </style>
    <!-- Respect saved theme before paint - default to dark -->
    <script>
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "light") {
            document.documentElement.classList.remove("dark");
        } else {
            document.documentElement.classList.add("dark");
        }
    </script>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">
    <!-- Unified Header -->
    <div id="unified-header"></div>

    <div class="max-w-6xl mx-auto p-6 space-y-8">
        <!-- Header -->
        <div class="flex items-center justify-between">
            <h1 class="text-3xl font-bold">Creative Studio</h1>
        </div>

        <!-- Quote Generation Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Generate Quote</h2>
            
            <div class="flex gap-4 items-center">
                <input
                    type="text"
                    id="quote-text"
                    value="Create a motivational quote about success"
                    placeholder="Describe what kind of quote you want..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <div class="text-xs text-gray-500 dark:text-gray-400 w-20 text-right" id="quote-char-count">0/200</div>
                <select id="quote-tone" class="bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                    <option value="default">Default</option>
                    <option value="motivational">Motivational</option>
                    <option value="witty">Witty</option>
                    <option value="poetic">Poetic</option>
                    <option value="bold">Bold</option>
                    <option value="calm">Calm</option>
                </select>
                <button
                    id="generate-quote-btn"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded"
                >
                    Generate Quote
                </button>
                <button
                    id="use-text-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 rounded text-white"
                    title="Use the exact text above as your quote"
                >
                    Use This Text
                </button>
            </div>

            <div id="quote-error" class="error text-sm hidden"></div>

            <div id="quote-result" class="bg-gray-100 dark:bg-gray-800 rounded p-4 space-y-3 hidden border border-gray-200 dark:border-gray-700">
                <div class="flex items-start justify-between gap-3">
                    <div class="flex-1">
                        <div id="quote-text-display" class="text-lg font-medium text-gray-900 dark:text-white"></div>
                        <textarea id="quote-edit" class="w-full bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm hidden text-gray-900 dark:text-white"></textarea>
                    </div>
                    <div class="flex flex-col gap-2 items-end">
                        <div id="regen-info" class="text-xs text-gray-400">Regens left: 10</div>
                        <div class="flex gap-2">
                            <button id="edit-quote-btn" class="px-3 py-1 bg-gray-600 dark:bg-neutral-700 hover:bg-gray-700 dark:hover:bg-neutral-600 rounded text-sm text-white">Edit</button>
                            <button id="save-quote-btn" class="px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-sm hidden text-white">Save</button>
                            <button id="cancel-quote-btn" class="px-3 py-1 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-sm hidden text-white">Cancel</button>
                        </div>
                    </div>
                </div>
                <div id="quote-author" class="text-sm text-gray-400 hidden"></div>
                <div id="quote-tone-tag" class="text-xs text-blue-400 hidden"></div>
                
                <!-- Remix buttons (Pro only) -->
                <div id="remix-buttons" class="flex gap-2 hidden">
                    <button id="regenerate-btn" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Regenerate
                    </button>
                    <button id="rephrase-btn" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Rephrase
                    </button>
                    <button id="tone-shift-btn" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Change Tone
                    </button>
                </div>
            </div>
        </div>

        <!-- Asset Selection Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Choose Background</h2>
            
            <!-- Asset Type Tabs -->
            <div class="flex gap-2">
                <button id="images-tab" class="px-4 py-2 rounded bg-blue-600 text-white" data-type="images">
                    Images
                </button>
                <button id="videos-tab" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white" data-type="videos">
                    Videos
                </button>
                <button id="ai-tab" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white hidden" data-type="ai">
                    AI Images
                </button>
            </div>

            <!-- Remix Area -->
            <div id="remix-area" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-4 hidden border border-gray-200 dark:border-gray-700">
                <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Remix References (up to 2)</h3>
                <div id="remix-assets" class="flex gap-4">
                    <!-- Remix assets will be added here -->
                </div>
                <!-- AI result preview slot -->
                <div id="ai-result-block" class="mt-3 hidden">
                    <div class="flex flex-col items-center gap-2">
                        <div id="ai-ref-preview" class="flex gap-2 justify-center"></div>
                        <div id="ai-result-preview" class="relative w-full rounded overflow-hidden border border-gray-600 bg-black" style="aspect-ratio: 9/16;"></div>
                        <div class="mt-2">
                            <button id="ai-save-use-btn" class="px-3 py-1 bg-green-600 hover:bg-green-500 text-white text-xs rounded">Save & Use</button>
                        </div>
                    </div>
                </div>
                <!-- Inline AI prompt + style for ideogram remix -->
                <div class="mt-3 flex flex-wrap items-center gap-3">
                    <input
                        type="text"
                        id="ai-prompt"
                        value="A serene mountain landscape at sunset"
                        placeholder="Describe what to create from these references..."
                        class="flex-1 min-w-[16rem] bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm text-gray-900 dark:text-white"
                    />
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-400">Realistic</span>
                        <input type="range" id="ai-style-slider" min="0" max="1" step="0.1" value="0.5" class="w-24" />
                        <span class="text-xs text-gray-400">Creative</span>
                    </div>
                </div>
                <div class="mt-3 flex items-center gap-2">
                    <button
                        id="clear-remix-btn"
                        class="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-xs rounded"
                    >
                        Clear All
                    </button>
                    <button
                        id="remix-generate-btn"
                        class="px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded"
                        title="Generate a new AI image using the selected references"
                    >
                        Remix with AI
                    </button>
                </div>
            </div>

            <!-- Search Controls -->
            <div id="search-controls" class="flex gap-4 items-center">
                <input
                    type="text"
                    id="asset-query"
                    value="nature"
                    placeholder="Search for images/videos..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <button
                    id="search-assets-btn"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded text-white"
                >
                    Search
                </button>
                <button
                    id="upload-asset-btn"
                    class="px-3 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-white"
                    title="Upload your own image or video"
                >
                    📁
                </button>
                <input
                    type="file"
                    id="asset-upload-input"
                    accept="image/*,video/*"
                    class="hidden"
                />
            </div>

            <!-- AI Images Controls removed (inline controls are now in remix-area) -->
            <div id="ai-error" class="error text-sm hidden"></div>

            <div id="asset-error" class="error text-sm hidden"></div>

            <!-- Asset Grid (3 rows × 4 columns ≈ 12 results) -->
            <div id="asset-grid" class="grid grid-cols-4 gap-4">
                <!-- Assets will be populated here -->
            </div>

            <!-- Pagination Controls -->
            <div id="pagination-container" class="flex justify-between items-center mt-4 hidden">
                <button
                    id="prev-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    ← Previous
                </button>
                <span id="page-info" class="text-sm text-gray-600 dark:text-gray-400">Page 1</span>
                <button
                    id="next-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    Next →
                </button>
            </div>

            <!-- Free Plan Notice -->
            <div id="free-notice" class="text-center text-sm text-gray-400 hidden">
                Showing 12 curated assets. 
                <span class="text-blue-400"> Upgrade to Pro</span> for larger pages and AI images.
            </div>
        </div>

        <!-- Caption Style Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Caption Style</h2>
            
            <div class="grid grid-cols-2 gap-4">
                <!-- Font Family -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Font</label>
                    <select id="caption-font" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="system">System</option>
                        <option value="bold">Bold</option>
                        <option value="cinematic">Cinematic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                
                <!-- Font Weight -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Weight</label>
                    <select id="caption-weight" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                    </select>
                </div>
                
                <!-- Size -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Size: <span id="size-value">48px</span></label>
                    <input
                        type="range"
                        id="caption-size"
                        min="28"
                        max="72"
                        value="48"
                        class="w-full"
                    />
                </div>
                
                <!-- Opacity -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Opacity: <span id="opacity-value">80%</span></label>
                    <input
                        type="range"
                        id="caption-opacity"
                        min="30"
                        max="100"
                        value="80"
                        class="w-full"
                    />
                </div>
                
                <!-- Placement -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Placement</label>
                    <select id="caption-placement" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="top">Top</option>
                        <option value="middle">Middle</option>
                        <option value="bottom">Bottom</option>
                    </select>
                </div>
                
                <!-- Background Box -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Background</label>
                    <div class="flex items-center gap-4">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="caption-background" class="rounded" />
                            <span class="text-sm">Show box</span>
                        </label>
                        <div class="flex-1">
                            <label class="block text-xs text-gray-400 mb-1">Box opacity: <span id="bg-opacity-value">50%</span></label>
                            <input
                                type="range"
                                id="caption-bg-opacity"
                                min="0"
                                max="100"
                                value="50"
                                class="w-full"
                            />
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Voiceover Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Voiceover</h2>
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Voice</label>
                    <div class="flex gap-2">
                        <select id="voiceover-voice" class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                            <option value="">Loading voices...</option>
                        </select>
                        <button id="retry-voices-btn" onclick="loadVoices()" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm">
                            🔄
                        </button>
                    </div>
                </div>
                <div class="flex items-end gap-2">
                    <button
                        id="preview-voice-btn"
                        class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white"
                        disabled
                    >
                        Preview Voice
                    </button>
                    <audio id="voice-preview-audio" class="hidden" controls></audio>
                </div>
            </div>
            <div id="voice-preview-status" class="text-sm text-gray-400 hidden"></div>
        </div>

        <!-- Render Section -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Create Short</h2>
            
            <!-- Live Preview Canvas -->
            <div id="live-preview-container" class="hidden">
                <div class="text-sm text-gray-400 mb-2">Live Preview:</div>
                <div class="relative w-full max-w-md mx-auto bg-black rounded-lg overflow-hidden">
                    <canvas id="live-preview-canvas" class="w-full h-auto"></canvas>
                    <div class="absolute inset-0 pointer-events-none" id="caption-overlay"></div>
                </div>
            </div>
            
            <div id="render-preview" class="bg-gray-100 dark:bg-gray-800 rounded p-4 hidden border border-gray-200 dark:border-gray-700">
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">Preview:</div>
                <div id="preview-quote" class="text-lg font-medium mb-2 text-gray-900 dark:text-white"></div>
                <div id="preview-asset" class="text-sm text-gray-600 dark:text-gray-400"></div>
                <div id="preview-caption-style" class="text-sm text-gray-600 dark:text-gray-400"></div>
                <div id="preview-voiceover" class="text-sm text-gray-600 dark:text-gray-400"></div>
            </div>
            
            <button
                id="render-btn"
                class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-lg font-medium hidden"
            >
                Render Short
            </button>
        </div>
    </div>

    <script type="module">
        import { BACKEND as BACKEND_FROM_CONFIG } from '/config.js';

        const API_BASE_FALLBACK = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        // Hard-force the backend origin to Replit to avoid Netlify handling /cdn
        const API_BASE_FIXED = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        function getApiBase(){
            return API_BASE_FIXED.replace(/\/$/, '');
        }
        // Global state
        let currentLimits = null;
        let currentQuote = null;
        let selectedAsset = null;
        let currentAssetType = 'images';
        let currentAssetPage = 1;
        let hasMoreAssets = false;
        let currentCredits = 0;
        let remixAssets = [];
        let assetCache = new Map(); // Cache for pagination
        let uploadedAssets = [];
        let availableVoices = [];
        let currentVoiceId = null;

        // Helper functions
        function updateCaptionOverlay(text = '', show = true){
            const overlay = document.getElementById('caption-overlay');
            if (!overlay) return;
            if (!show || !text) { overlay.innerHTML = ''; return; }
            const safe = String(text);
            const fontSel = document.getElementById('caption-font');
            const weightSel = document.getElementById('caption-weight');
            const sizeRange = document.getElementById('caption-size');
            const opRange = document.getElementById('caption-opacity');
            const placeSel = document.getElementById('caption-placement');
            const showBox = document.getElementById('caption-background');
            const boxOpRange = document.getElementById('caption-bg-opacity');

            const fontMap = {
              // Include DejaVu Sans first to better match FFmpeg drawtext default
              System: '\"DejaVu Sans\", \"DejaVuSans\", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif',
              system: '\"DejaVu Sans\", \"DejaVuSans\", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif',
              Minimal: '\"DejaVu Sans\", Helvetica, Arial, sans-serif',
              minimal: '\"DejaVu Sans\", Helvetica, Arial, sans-serif',
              Cinematic: 'Georgia, serif',
              cinematic: 'Georgia, serif'
            };
            const font = (fontSel?.value || 'system');
            const fontFamily = fontMap[font] || fontMap.system;
            const fontWeight = (weightSel?.value || 'Normal');
            const sizePx = parseInt(sizeRange?.value || '48', 10);
            const textOpacity = Math.max(0, Math.min(1, (parseInt(opRange?.value || '80', 10) / 100)));
            const placement = (placeSel?.value || 'bottom').toLowerCase();
            const wantBox = !!(showBox && showBox.checked);
            const boxOpacity = Math.max(0, Math.min(1, (parseInt(boxOpRange?.value || '50', 10) / 100)));

            let vertStyle = 'bottom:0; top:auto;';
            if (placement === 'top') vertStyle = 'top:0; bottom:auto;';
            if (placement === 'middle') vertStyle = 'top:50%; transform:translateY(-50%);';

            const boxStyle = wantBox ? `background: rgba(0,0,0,${boxOpacity}); padding: 6px 10px; border-radius: 8px;` : '';

            overlay.innerHTML = `
                <div style="position:absolute; left:0; right:0; ${vertStyle} padding:12px 16px;">
                  <div style="max-width: 92%; margin: 0 auto; text-align: center; color: rgba(255,255,255,${textOpacity}); font-weight: ${fontWeight}; font-size: ${sizePx}px; font-family: ${fontFamily}; text-shadow: 0 2px 6px rgba(0,0,0,0.6); ${boxStyle}">
                    ${safe}
                  </div>
                </div>`;
        }
        // Regen helpers: only decrement on LLM actions
        window.VAI = window.VAI || {};
        VAI.state = VAI.state || { regensLeft: 10 };
        (function initRegens(){
            const info = document.getElementById('regen-info');
            if (!info) return;
            const m = String(info.textContent||'').match(/(\d+)/);
            const initial = m ? parseInt(m[1],10) : 10;
            if (!Number.isFinite(VAI.state.regensLeft)) VAI.state.regensLeft = initial;
            info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        })();
        function setRegensLeft(n){
            VAI.state.regensLeft = Math.max(0, Number(n||0));
            const info = document.getElementById('regen-info');
            if (info) info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        }
        function decRegens(){
            setRegensLeft((VAI.state.regensLeft|0) - 1);
        }
        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function setLoading(buttonId, loading) {
            const button = document.getElementById(buttonId);
            button.disabled = loading;
            button.textContent = loading ? 'Loading...' : button.textContent.replace('Loading...', '');
        }

        // Load credits using existing system
        async function refreshCredits(force = true, retries = 1) {
            if (!window.auth?.currentUser) { 
                updateCreditUI(0); 
                return; 
            }
            try {
                // Use the apiFetch from the imported module
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch("/credits", { method: "GET" });
                const credits = Number(data?.credits ?? 0);
                updateCreditUI(Number.isNaN(credits) ? 0 : credits);
            } catch (err) {
                if (retries > 0) return refreshCredits(false, retries - 1);
                console.warn("Credits fetch failed:", err);
            }
        }

        function updateCreditUI(credits) {
            currentCredits = typeof credits === "number" ? credits : 0;
            const creditDisplay = document.getElementById('credit-display');
            const creditCount = document.getElementById('credit-count');
            if (creditDisplay) creditDisplay.classList.remove("hidden");
            if (creditCount) creditCount.textContent = String(currentCredits);
        }

        // Quote generation
        async function generateQuote() {
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to generate quotes');
                return;
            }
            
            const text = document.getElementById('quote-text').value;
            const tone = document.getElementById('quote-tone').value;
            
            if (!text.trim()) return;
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/generate-quote', {
                    method: 'POST',
                    body: {
                        text,
                        tone: tone === 'default' ? undefined : tone,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    displayQuote(currentQuote); // keep textarea visible (no toggle)
                    decRegens();
                } else {
                    showError('quote-error', data.reason || 'Failed to generate quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        function displayQuote(quote) {
            document.getElementById('quote-text-display').textContent = quote.text;
            const editEl = document.getElementById('quote-edit');
            editEl.value = quote.text;
            // Always keep the inlaid editor visible
            document.getElementById('quote-text-display').classList.add('hidden');
            editEl.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            // Update char counter from textarea content
            try {
              const cc = document.getElementById('quote-char-count');
              if (cc) cc.textContent = `${Math.min(200, (editEl.value||'').length)}/200`;
            } catch {}
            document.getElementById('quote-author').textContent = quote.author ? `— ${quote.author}` : '';
            document.getElementById('quote-author').classList.toggle('hidden', !quote.author);
            document.getElementById('quote-tone-tag').textContent = quote.toneTag ? `Tone: ${quote.toneTag}` : '';
            document.getElementById('quote-tone-tag').classList.toggle('hidden', !quote.toneTag);
            document.getElementById('quote-result').classList.remove('hidden');
            // Always expose LLM iterate buttons when a quote is present
            const remix = document.getElementById('remix-buttons');
            if (remix) remix.classList.remove('hidden');
            updateRenderPreview();
        }

        // Asset loading with pagination and caching
        async function loadAssets(page = 1) {
            if (currentAssetType === 'ai') return;
            if (!window.auth?.currentUser) {
                showError('asset-error', 'Please log in to load assets');
                return;
            }
            
            setLoading('search-assets-btn', true);
            hideError('asset-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const perPage = 12; // fuller grid per request
                const query = document.getElementById('asset-query').value;
                const cacheKey = `${currentAssetType}-${query}-${page}`;
                
                // Check cache first
                if (assetCache.has(cacheKey)) {
                    const cachedData = assetCache.get(cacheKey);
                    displayAssets(cachedData.items);
                    hasMoreAssets = cachedData.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                    setLoading('search-assets-btn', false);
                    return;
                }
                
                const data = await apiFetch('/assets/options', {
                    method: 'POST',
                    body: {
                        type: currentAssetType,
                        query,
                        page,
                        perPage
                    }
                });
                
                if (data.ok) {
                    // Cache the results
                    assetCache.set(cacheKey, {
                        items: data.data.items,
                        nextPage: data.data.nextPage
                    });
                    
                    displayAssets(data.data.items);
                    hasMoreAssets = data.data.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                } else {
                    showError('asset-error', data.reason || 'Failed to load assets');
                }
            } catch (error) {
                showError('asset-error', error.message || 'Network error');
            } finally {
                setLoading('search-assets-btn', false);
            }
        }

        function displayAssets(assets) {
            const grid = document.getElementById('asset-grid');
            grid.innerHTML = '';
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function appendAssets(assets) {
            const grid = document.getElementById('asset-grid');
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function createAssetElement(asset) {
            const div = document.createElement('div');
            div.className = `relative border-2 rounded overflow-hidden transition-colors group ${
                selectedAsset?.id === asset.id ? 'border-blue-500' : 'border-gray-700'
            }`;
            
            let media;
            if (asset.provider === 'ai' || asset.type === 'ai-generated') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" />`;
            } else if (currentAssetType === 'images') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" />`;
            } else {
                media = `<video src="${asset.fileUrl}" class="w-full h-32 object-cover" muted playsinline></video>`;
            }
            
            const attribution = asset.provider === 'ai' 
                ? '<div class="text-purple-400 truncate">AI Generated</div>'
                : asset.photographer 
                    ? `<div class="text-gray-400 truncate">by ${asset.photographer}</div>`
                    : '';
            
            div.innerHTML = `
                ${media}
                <div class="p-2 text-xs">
                    <div class="truncate">${asset.query}</div>
                    ${attribution}
                </div>
                <!-- Action Buttons Overlay -->
                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-all duration-200 flex items-end justify-center pb-2 opacity-0 group-hover:opacity-100">
                    <div class="flex gap-2">
                        <button 
                            class="use-asset-btn px-3 py-1 bg-blue-600 hover:bg-blue-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Use
                        </button>
                        <button 
                            class="remix-asset-btn px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Remix
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners for the buttons
            const useBtn = div.querySelector('.use-asset-btn');
            const remixBtn = div.querySelector('.remix-asset-btn');
            
            useBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                useAsset(asset);
            });
            
            remixBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                addToRemix(asset);
            });
            
            return div;
        }

        function selectAsset(asset) {
            selectedAsset = asset;
            // Re-render grid to update selection
            loadAssets(1);
            updateRenderPreview();
            updateRenderButtonState();
        }

        function updatePagination() {
            const container = document.getElementById('pagination-container');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const pageInfo = document.getElementById('page-info');
            
            if (currentAssetType === 'ai') {
                container.classList.add('hidden');
                return;
            }
            
            container.classList.remove('hidden');
            prevBtn.disabled = currentAssetPage <= 1;
            nextBtn.disabled = !hasMoreAssets;
            pageInfo.textContent = `Page ${currentAssetPage}`;
        }

        // Use asset function
        function useAsset(asset) {
            selectedAsset = asset;
            updateRenderPreview();
            updateRenderButtonState();
            // Scroll to render section
            document.getElementById('render-preview').scrollIntoView({ behavior: 'smooth' });
        }

        // Add to remix function
        function addToRemix(asset) {
            if (remixAssets.length >= 2) {
                showError('asset-error', 'Maximum 2 remix references allowed');
                return;
            }
            
            if (remixAssets.find(a => a.id === asset.id)) {
                showError('asset-error', 'Asset already in remix references');
                return;
            }
            
            remixAssets.push(asset);
            updateRemixArea();
        }

        // Update remix area display
        function updateRemixArea() {
            const remixArea = document.getElementById('remix-area');
            const remixAssetsContainer = document.getElementById('remix-assets');
            
            if (remixAssets.length === 0) {
                remixArea.classList.add('hidden');
                return;
            }
            
            remixArea.classList.remove('hidden');
            remixAssetsContainer.innerHTML = '';
            
            remixAssets.slice(0,2).forEach((asset, index) => {
                const assetDiv = document.createElement('div');
                assetDiv.className = 'relative w-20 h-20 rounded overflow-hidden border border-gray-600';
                
                const media = asset.provider === 'ai' || asset.type === 'ai-generated'
                    ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" />`
                    : currentAssetType === 'images'
                        ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" />`
                        : `<video src="${asset.fileUrl}" class="w-full h-full object-cover" muted playsinline></video>`;
                
                assetDiv.innerHTML = `
                    ${media}
                    <button 
                        class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 hover:bg-red-500 text-white text-xs rounded-full flex items-center justify-center"
                        onclick="removeFromRemix(${index})"
                    >
                        ×
                    </button>
                `;
                
                remixAssetsContainer.appendChild(assetDiv);
            });
        }

        // Remove from remix
        function removeFromRemix(index) {
            remixAssets.splice(index, 1);
            updateRemixArea();
        }

        // Handle file upload
        function handleFileUpload(files) {
            if (!files || !files[0]) return;
            const file = files[0];
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const uploadedAsset = {
                    id: `uploaded-${Date.now()}`,
                    fileUrl: e.target.result,
                    thumbUrl: e.target.result,
                    query: file.name,
                    provider: 'uploaded',
                    type: file.type.startsWith('video/') ? 'video' : 'image'
                };
                
                uploadedAssets.push(uploadedAsset);
                
                // Add to current grid
                const grid = document.getElementById('asset-grid');
                const assetElement = createAssetElement(uploadedAsset);
                grid.insertBefore(assetElement, grid.firstChild);
            };
            
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else if (file.type.startsWith('video/')) {
                reader.readAsDataURL(file);
            }
        }

        function updateRenderPreview() {
            const preview = document.getElementById('render-preview');
            const renderBtn = document.getElementById('render-btn');
            
            if (currentQuote && selectedAsset) {
                document.getElementById('preview-quote').textContent = currentQuote.text;
                document.getElementById('preview-asset').textContent = 
                    `Background: ${selectedAsset.provider === 'ai' ? 'AI Image' : selectedAsset.provider === 'uploaded' ? 'Uploaded' : `${currentAssetType} - ${selectedAsset.query}`}`;
                
                // Update caption style preview
                const font = document.getElementById('caption-font').value;
                const weight = document.getElementById('caption-weight').value;
                const size = document.getElementById('caption-size').value;
                const opacity = document.getElementById('caption-opacity').value;
                const placement = document.getElementById('caption-placement').value;
                const background = document.getElementById('caption-background').checked;
                
                document.getElementById('preview-caption-style').textContent = 
                    `Caption: ${font} ${weight}, ${size}px, ${opacity}% opacity, ${placement}${background ? ', with background' : ''}`;
                
                // Update voiceover preview
                const voiceId = document.getElementById('voiceover-voice').value;
                const selectedVoice = availableVoices.find(v => v.id === voiceId);
                const voiceName = selectedVoice ? selectedVoice.name : 'Not selected';
                document.getElementById('preview-voiceover').textContent = `Voice: ${voiceName}`;
                
                preview.classList.remove('hidden');
                renderBtn.classList.remove('hidden');
                updateLivePreview();
            } else {
                preview.classList.add('hidden');
                renderBtn.classList.add('hidden');
                document.getElementById('live-preview-container').classList.add('hidden');
            }
            updateRenderButtonState();
        }

        // Update caption style values
        function updateCaptionStyleValues() {
            document.getElementById('size-value').textContent = document.getElementById('caption-size').value + 'px';
            document.getElementById('opacity-value').textContent = document.getElementById('caption-opacity').value + '%';
            document.getElementById('bg-opacity-value').textContent = document.getElementById('caption-bg-opacity').value + '%';
            updateRenderPreview();
            updateLivePreview();
            try { updateCaptionOverlay((currentQuote?.text||'').trim(), true); } catch {}
        }

        // Update render button state based on validation
        function updateRenderButtonState() {
            const renderBtn = document.getElementById('render-btn');
            const hasValidAsset = selectedAsset && (selectedAsset.fileUrl || selectedAsset.url);
            const hasQuote = currentQuote;
            const isLoggedIn = window.auth?.currentUser;
            
            const canRender = hasValidAsset && hasQuote && isLoggedIn;
            renderBtn.disabled = !canRender;
            
            if (!canRender) {
                let reason = '';
                if (!isLoggedIn) reason = 'Please log in';
                else if (!hasQuote) reason = 'Please select a quote';
                else if (!hasValidAsset) reason = 'Please select a valid asset';
                
                renderBtn.title = reason;
            } else {
                renderBtn.title = 'Ready to render';
            }
        }

        // Live preview functionality
        function updateLivePreview() {
            if (!currentQuote || !selectedAsset) return;
            
            const container = document.getElementById('live-preview-container');
            const canvas = document.getElementById('live-preview-canvas');
            const ctx = canvas.getContext('2d');
            
            container.classList.remove('hidden');
            
            // If a <video> is present for preview, hide overlay to avoid double text
            try {
                const ov = document.getElementById('caption-overlay');
                const hasVideo = !!document.querySelector('#live-preview-container video, #preview-holder video');
                if (ov) ov.style.display = hasVideo ? 'none' : 'block';
            } catch {}

            // Load the asset image
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                // Set canvas size (maintain aspect ratio, max width 400px)
                const maxWidth = 400;
                const aspectRatio = img.height / img.width;
                const canvasWidth = Math.min(maxWidth, img.width);
                const canvasHeight = canvasWidth * aspectRatio;
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                // Draw the image only; caption is handled by HTML overlay to avoid double text
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
            };
            
            try {
                const raw = selectedAsset.thumbUrl || selectedAsset.fileUrl;
                const proxied = raw && /^https:\/\/firebasestorage\.googleapis\.com\//.test(raw)
                  ? `${getApiBase()}/cdn?u=${encodeURIComponent(raw)}`
                  : raw;
                img.crossOrigin = 'anonymous';
                img.src = proxied;
            } catch {
                img.src = selectedAsset.thumbUrl || selectedAsset.fileUrl;
            }
        }

        function drawCaptionOverlay(ctx, canvasWidth, canvasHeight) {
            if (!currentQuote) return;
            
            const font = document.getElementById('caption-font').value;
            const weight = document.getElementById('caption-weight').value;
            const size = parseInt(document.getElementById('caption-size').value);
            const opacity = parseInt(document.getElementById('caption-opacity').value) / 100;
            const placement = document.getElementById('caption-placement').value;
            const showBackground = document.getElementById('caption-background').checked;
            const bgOpacity = parseInt(document.getElementById('caption-bg-opacity').value) / 100;
            
            // Set font - ensure weight mapping matches FFmpeg
            const cssWeight = (String(weight).toLowerCase() === 'bold' || Number(weight) >= 600) ? 'bold' : 'normal';
            ctx.font = `${cssWeight} ${size}px ${getFontFamily(font)}`;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add stroke to match FFmpeg rendering
            ctx.lineWidth = 3;
            ctx.strokeStyle = `rgba(0, 0, 0, 0.85)`;
            ctx.miterLimit = 2;
            
            // Calculate text position
            let y;
            const padding = 20;
            switch (placement) {
                case 'top':
                    y = padding + size / 2;
                    break;
                case 'middle':
                    y = canvasHeight / 2;
                    break;
                case 'bottom':
                    y = canvasHeight - padding - size / 2;
                    break;
            }
            
            // Wrap text if needed
            const maxWidth = canvasWidth - 40;
            const words = currentQuote.text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw background if enabled
            if (showBackground) {
                const lineHeight = size * 1.2;
                const totalHeight = lines.length * lineHeight;
                const bgY = y - totalHeight / 2;
                const bgHeight = totalHeight + padding;
                const bgWidth = canvasWidth - 20;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${bgOpacity})`;
                ctx.fillRect(10, bgY - padding / 2, bgWidth, bgHeight);
            }
            
            // Draw text lines
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            const lineHeight = size * 1.2;
            const startY = y - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                const x = canvasWidth / 2;
                const y = startY + index * lineHeight;
                
                // Draw stroke first (matches FFmpeg layering)
                ctx.strokeText(line, x, y);
                // Draw fill text on top
                ctx.fillText(line, x, y);
            });
        }

        function getFontFamily(font) {
            const fontMap = {
                'system': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif',
                'bold': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif', 
                'cinematic': 'DejaVu Sans Local, Georgia, serif',
                'minimal': 'DejaVu Sans Local, Helvetica, Arial, sans-serif'
            };
            return fontMap[font] || 'DejaVu Sans Local, system-ui, sans-serif';
        }

        // Compute preview-fitted lines using canvas metrics to mirror overlay width
        function computeFittedTextForPreview(text, { font, weight, sizePx, previewWidthPx }) {
            try {
                const raw = String(text || '').trim();
                if (!raw) {
                    return '';
                }
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const family = "DejaVu Sans Local";
                const weightCss = (String(weight).toLowerCase() === 'bold') ? '700' : '400';
                const size = Math.max(10, Number(sizePx) || 48);
                ctx.font = `${weightCss} ${size}px ${family}`;
                
                // Match overlay: max content width ≈ 92% of preview width
                const maxWidth = Math.max(20, Math.round((Number(previewWidthPx)||360) * 0.92));
                
                const words = raw.split(/\s+/);
                const lines = [];
                let cur = '';
                for (const w of words) {
                    const next = cur ? cur + ' ' + w : w;
                    const width = ctx.measureText(next).width;
                    if (width > maxWidth && cur) { lines.push(cur); cur = w; } else { cur = next; }
                }
                if (cur) lines.push(cur);
                
                const result = lines.join('\n');
                return result;
            } catch (error) {
                return String(text || '').trim();
            }
        }

        // Voice loading and preview functions
        window.loadVoices = async function loadVoices() {
            try {
                // Wait for auth to be ready
                if (!window.auth?.currentUser) {
                    // Wait a bit for auth to initialize
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (!window.auth?.currentUser) {
                        showError('voice-preview-status', 'Please log in to load voices');
                        return;
                    }
                }

                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/voice/voices', {
                    method: 'GET'
                });

                if (data.success) {
                    availableVoices = data.data.voices;
                    populateVoiceSelect();
                    hideError('voice-preview-status');
                } else {
                    showError('voice-preview-status', data.error || 'Failed to load voices');
                }
            } catch (error) {
                console.error('Voice loading error:', error);
                showError('voice-preview-status', error.message || 'Network error');
            }
        }

        function populateVoiceSelect() {
            const select = document.getElementById('voiceover-voice');
            const retryBtn = document.getElementById('retry-voices-btn');
            select.innerHTML = '';
            
            if (availableVoices.length === 0) {
                select.innerHTML = '<option value="">No voices available</option>';
                retryBtn.title = 'Retry loading voices';
                return;
            }

            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = `${voice.name} - ${voice.description}`;
                select.appendChild(option);
            });

            // Enable preview button and hide retry button
            document.getElementById('preview-voice-btn').disabled = false;
            retryBtn.style.display = 'none';
        }

        async function previewVoice() {
            const voiceSelect = document.getElementById('voiceover-voice');
            const voiceId = voiceSelect.value;
            
            if (!voiceId || voiceId === '') {
                showError('voice-preview-status', 'Please select a voice');
                return;
            }

            const statusEl = document.getElementById('voice-preview-status');
            const previewBtn = document.getElementById('preview-voice-btn');
            const audioEl = document.getElementById('voice-preview-audio');

            statusEl.classList.remove('hidden');
            statusEl.textContent = 'Generating preview...';
            previewBtn.disabled = true;

            try {
                console.log('Voice preview - voiceId:', voiceId);
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/voice/preview', {
                    method: 'POST',
                    body: {
                        voiceId,
                        text: 'Hello, this is a preview of my voice. How does it sound?'
                    }
                });
                
                console.log('Voice preview response:', data);

                if (data.success) {
                    audioEl.src = data.data.audio;
                    audioEl.classList.remove('hidden');
                    statusEl.textContent = 'Preview ready - click play to listen';
                    
                    // Auto-play the preview
                    audioEl.play().catch(e => {
                        console.log('Auto-play prevented:', e);
                        statusEl.textContent = 'Preview ready - click play to listen';
                    });
                } else {
                    showError('voice-preview-status', data.error || 'Failed to generate preview');
                }
            } catch (error) {
                showError('voice-preview-status', error.message || 'Network error');
            } finally {
                previewBtn.disabled = false;
            }
        }

        // Render short function
        async function renderShort() {
            if (!currentQuote || !selectedAsset) {
                alert('Please select a quote and an asset first');
                return;
            }

            if (!window.auth?.currentUser) {
                alert('Please log in to render shorts');
                return;
            }

            const renderBtn = document.getElementById('render-btn');
            const originalText = renderBtn.textContent;
            
            renderBtn.disabled = true;
            renderBtn.textContent = 'Rendering...';

            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Prepare the render payload with proper background structure
                const assetUrl = selectedAsset.fileUrl || selectedAsset.url;
                
                // Detect type from URL extension
                const detectTypeFromUrl = (url) => {
                    if (!url) return 'image'; // Default fallback
                    
                    try {
                        // Handle URLs with query parameters or fragments
                        const cleanUrl = url.split('?')[0].split('#')[0];
                        const ext = cleanUrl.toLowerCase().split('.').pop();
                        
                        console.log(`[typeDetection] URL: ${url}`);
                        console.log(`[typeDetection] Clean URL: ${cleanUrl}`);
                        console.log(`[typeDetection] Extension: ${ext}`);
                        
                        if (['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', '3gp', 'flv'].includes(ext)) {
                            return 'video';
                        }
                        if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg', 'tiff'].includes(ext)) {
                            return 'image';
                        }
                        
                        // Default fallback
                        console.log(`[typeDetection] Unknown extension: ${ext}, defaulting to image`);
                        return 'image';
                    } catch (error) {
                        console.error(`[typeDetection] Error parsing URL: ${error.message}`);
                        return 'image'; // Safe fallback
                    }
                };
                
                const detectedType = detectTypeFromUrl(assetUrl);
                
                console.log(`[render] Asset URL: ${assetUrl}`);
                console.log(`[render] Detected type: ${detectedType}`);
                
                const background = {
                    kind: selectedAsset.provider === 'ai' ? 'ai' : 
                          selectedAsset.provider === 'uploaded' ? 'upload' : 'stock',
                    type: detectedType, // Use detected type from URL
                    url: assetUrl, // Required URL
                    query: selectedAsset.query,
                    // Legacy fields for backward compatibility
                    imageUrl: selectedAsset.provider === 'uploaded' ? selectedAsset.fileUrl : undefined,
                    prompt: selectedAsset.provider === 'ai' ? selectedAsset.query : undefined
                };

                // Get caption style settings
                const captionStyle = {
                    font: document.getElementById('caption-font').value,
                    weight: document.getElementById('caption-weight').value,
                    sizePx: parseInt(document.getElementById('caption-size').value),
                    opacity: parseInt(document.getElementById('caption-opacity').value) / 100,
                    placement: document.getElementById('caption-placement').value,
                    showBox: document.getElementById('caption-background').checked,
                    boxOpacity: parseInt(document.getElementById('caption-bg-opacity').value) / 100
                };

                // Build precise caption layout mirroring preview controls
                const placementMap = { top: 12, middle: 50, bottom: 88 };
                const vAlignMap = { top: 'top', middle: 'center', bottom: 'bottom' };
                // Measure the preview canvas height (fallback to 640)
                const canvasEl = document.getElementById('live-preview-canvas');
                const previewHeightPx = Math.round((canvasEl?.clientHeight || canvasEl?.height || 640));
                const previewWidthPx = Math.round((canvasEl?.clientWidth || canvasEl?.width || 360));

                // Build preview-fitted lines so backend can draw exactly as shown
                // Normalize preview family/weight to match ffmpeg font files exactly
                const fwRaw = captionStyle.weight ?? 'normal';
                const fontWeight = (String(fwRaw).toLowerCase() === 'bold' || Number(fwRaw) >= 600) ? 'bold' : 'normal';
                // Force preview + measure to DejaVu Sans (matches ffmpeg)
                const previewFontFamily = 'DejaVu Sans Local';

                // Build preview-fitted lines using the same family & weight used by ffmpeg
                const quoteText = (currentQuote?.text || '').trim();
                console.log('[render] Computing fitted text for:', { quoteText, previewFontFamily, fontWeight, sizePx: captionStyle.sizePx, previewWidthPx });
                
                // First, calculate the scaling we'll need
                const tempPreviewToRenderScale = 1920 / Math.max(1, previewHeightPx);
                const tempScaledFontPx = Math.round((captionStyle.sizePx || 48) * tempPreviewToRenderScale);
                
                const fittedText = computeFittedTextForPreview(quoteText, {
                    font: previewFontFamily,
                    weight: fontWeight,
                    sizePx: tempScaledFontPx, // Use scaled font size for measurement
                    previewWidthPx: 1080 // Use final render width for accurate measurement
                });
                
                console.log('[render] Fitted text result:', fittedText);

                // Ensure font family/weight variables for parity with renderer
                const family    = "DejaVu Sans Local";
                const weightCss = (String(fontWeight).toLowerCase() === "bold") ? "700" : "400";

                // Scale font size from preview canvas to final render dimensions
                const previewToRenderScale = 1920 / Math.max(1, previewHeightPx); // Scale factor from preview to 1920px height
                const scaledFontPx = Math.round((captionStyle.sizePx || 48) * previewToRenderScale);
                
                console.log('[render] Font scaling:', { 
                    previewHeightPx, 
                    renderHeight: 1920, 
                    previewToRenderScale, 
                    originalSizePx: captionStyle.sizePx, 
                    scaledFontPx 
                });

                // Capture preview's resolved metrics for authoritative rendering
                const captionResolved = {
                    fontFamily: family,
                    weightCss: (weightCss === "700") ? "bold" : "normal",
                    fontFile: (weightCss === "700") ? "DejaVuSans-Bold.ttf" : "DejaVuSans.ttf",
                    fontPx: scaledFontPx, // Use scaled font size for final render
                    lineSpacing: Math.round(scaledFontPx * 0.20), // Scale line spacing too
                    textAlpha: Math.max(0, Math.min(1, captionStyle.opacity ?? 0.8)),
                    strokeW: Math.max(1, Math.round(3 * previewToRenderScale)), // Scale stroke width
                    strokeAlpha: 0.85,
                    shadowAlpha: 0.55,
                    shadowX: 0,
                    shadowY: Math.round(2 * previewToRenderScale), // Scale shadow offset
                    // Add splitLines from preview for exact text layout
                    splitLines: fittedText ? fittedText.split('\n') : (quoteText ? [quoteText] : []),
                    yPct: placementMap[captionStyle.placement] ?? 88
                };

                const caption = {
                    has: true,
                    text: (currentQuote?.text || '').trim(),
                    fittedText,
                    fontFamily: family,
                    fontWeight: (weightCss === "700") ? "bold" : "normal",
                    weight: captionStyle.weight, // Pass through original weight for FFmpeg processing
                    fontSizePx: Number.isFinite(captionStyle.sizePx) ? captionStyle.sizePx : 48,
                    opacity: Math.max(0, Math.min(1, captionStyle.opacity ?? 0.8)),
                    align: 'center',
                    vAlign: vAlignMap[captionStyle.placement] || 'top',
                    pos: { xPct: 50, yPct: placementMap[captionStyle.placement] ?? 88 },
                    position: { xPct: 50, yPct: placementMap[captionStyle.placement] ?? 88 },
                    previewHeightPx,
                    lineSpacingPx: Math.round(((Number.isFinite(captionStyle.sizePx)?captionStyle.sizePx:48) * 0.20)), // Match preview calculation
                    box: {
                        enabled: !!document.querySelector('#caption-background')?.checked,
                        alpha: Math.max(0, Math.min(1, (parseInt(document.getElementById('caption-bg-opacity')?.value || '50', 10) / 100)))
                    },
                    // convenience aliases
                    wantBox: !!document.querySelector('#caption-background')?.checked,
                    boxAlpha: Math.max(0, Math.min(1, (parseInt(document.getElementById('caption-bg-opacity')?.value || '50', 10) / 100)))
                };

                // Normalize caption mode to satisfy server enum
                // For videos, burn one bottom caption in the final render
                const uiCaptionMode = 'static';
                const normalizedCaptionMode = uiCaptionMode;
                const includeBottomCaption = detectedType === 'video';

                // Decide which text goes where based on background type
                const isVideoBg = detectedType === 'video';
                const finalText = isVideoBg ? '' : (currentQuote.text || '').trim();
                const finalCaptionText = isVideoBg ? (currentQuote.text || '').trim() : '';

                const payload = {
                    mode: 'quote',
                    text: finalText,
                    template: 'calm', // Default template
                    durationSec: 8,
                    voiceover: !!currentVoiceId,
                    wantAttribution: true,
                    background,
                    captionMode: normalizedCaptionMode,
                    includeBottomCaption,
                    watermark: true,
                    // Add caption style settings
                    captionStyle,
                    caption,
                    // Preview is authoritative - send resolved metrics
                    captionResolved,
                    // Provide captionText for videos only
                    captionText: finalCaptionText,
                    // Ensure TTS has content for both image/video flows
                    ttsText: (finalCaptionText || finalText || '').trim()
                };

                // Only add voiceId if a voice is actually selected
                if (currentVoiceId) {
                    payload.voiceId = currentVoiceId;
                }

                console.log('Render payload:', payload);
                console.log('Background object:', background);
                console.log('Current voice ID:', currentVoiceId);

                // Final validation before sending
                if (background.url && background.type) {
                    const url = background.url.toLowerCase();
                    const isVideoUrl = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v'].some(ext => url.includes(`.${ext}`));
                    const isImageUrl = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].some(ext => url.includes(`.${ext}`));
                    
                    if (background.type === 'video' && !isVideoUrl) {
                        console.error('[validation] Type mismatch: type is video but URL is not a video');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                    if (background.type === 'image' && !isImageUrl) {
                        console.error('[validation] Type mismatch: type is image but URL is not an image');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                }

                const data = await apiFetch('/shorts/create', {
                    method: 'POST',
                    body: payload
                });

                if (data.success) {
                    // Success! Show the result
                    const result = data.data;
                    alert(`Short created successfully! Job ID: ${result.jobId}`);
                    
                    // Redirect to My Shorts page so user sees result immediately
                    try { window.location.href = `/my-shorts.html?new=${encodeURIComponent(result.jobId)}`; } catch {}
                    
                    // You could redirect to a results page or show the video here
                    // For now, we'll just show success
                    console.log('Render result:', result);
                } else {
                    alert(`Render failed: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Render error:', error);
                alert(`Render failed: ${error.message || 'Network error'}`);
            } finally {
                renderBtn.disabled = false;
                renderBtn.textContent = originalText;
            }
        }

        // Remix quote function
        async function remixQuote(mode) {
            if (!currentQuote) return;
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to remix quotes');
                return;
            }
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/remix', {
                    method: 'POST',
                    body: {
                        // Prefer live textarea content so users don't need to hit Save first
                        originalText: (document.getElementById('quote-edit')?.value || currentQuote.text || '').trim(),
                        mode,
                        targetTone: mode === 'tone_shift' ? document.getElementById('quote-tone').value : undefined,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    displayQuote(currentQuote);
                    decRegens();
                    // Keep the editor visible with new text
                    try {
                      document.getElementById('quote-text-display').classList.add('hidden');
                      document.getElementById('quote-edit').classList.remove('hidden');
                      document.getElementById('save-quote-btn').classList.remove('hidden');
                      document.getElementById('cancel-quote-btn').classList.remove('hidden');
                      document.getElementById('edit-quote-btn').classList.add('hidden');
                    } catch {}
                } else {
                    showError('quote-error', data.reason || 'Failed to remix quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        // AI Image generation
        async function generateAiImage() {
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            const prompt = document.getElementById('ai-prompt').value;
            const styleSlider = document.getElementById('ai-style-slider').value;
            
            if (!prompt.trim()) {
                showError('ai-error', 'Please enter a prompt');
                return;
            }
            
            setLoading('generate-ai-btn', true);
            hideError('ai-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Map slider value to style: 0-0.5 = realistic, 0.5-1 = cartoon
                const style = parseFloat(styleSlider) <= 0.5 ? 'realistic' : 'cartoon';
                
                // Map slider 0..1 → ideogram style_type: closer to Realistic at 0, Creative at 1
                const creative = parseFloat(styleSlider);
                const styleType = creative < 0.33 ? 'Photographic' : (creative > 0.66 ? 'Illustration' : 'None');

                const data = await apiFetch('/generate', {
                    method: 'POST',
                    body: {
                        prompt,
                        style, // retained for compatibility
                        count: 1,
                        // ideogram params ride along; backend adapter maps them
                        params: { style_type: styleType },
                        options: {}
                    }
                });
                
                if ((data?.success === true && Array.isArray(data?.data?.images)) || data.images || data?.data?.images) {
                    // Handle successful generation
                    const imgs = data.images || data?.data?.images || [];
                    const first = imgs[0];
                    const url = typeof first === 'string' ? first : (first?.url || first);
                    if (url) {
                        const aiAsset = {
                            id: `ai-${Date.now()}`,
                            fileUrl: url,
                            thumbUrl: url,
                            query: prompt,
                            provider: 'ai',
                            type: 'ai-generated'
                        };
                        // Add to asset grid
                        const grid = document.getElementById('asset-grid');
                        const assetElement = createAssetElement(aiAsset);
                        grid.insertBefore(assetElement, grid.firstChild);
                        // Also show next to remix references if present
                        const aiBlock = document.getElementById('ai-result-block');
                        const aiPrev = document.getElementById('ai-result-preview');
                        if (aiBlock && aiPrev) {
                            aiPrev.innerHTML = `<img src="${aiAsset.thumbUrl}" class="w-full h-full object-cover" />`;
                            aiBlock.classList.remove('hidden');
                        }
                        // Auto-select the generated image
                        selectAsset(aiAsset);
                    } else {
                        showError('ai-error', 'No image URL returned');
                    }
                } else {
                    // Some backends use { ok:false, reason } envelope
                    showError('ai-error', (data && (data.reason || data.error)) || 'Failed to generate AI image');
                }
            } catch (error) {
                showError('ai-error', error.message || 'Network error');
            } finally {
                setLoading('generate-ai-btn', false);
            }
        }

        // Remix button handler: require at least 1 reference, prefer 2
        document.addEventListener('click', (e) => {
            const t = e.target;
            if (!t || t.id !== 'remix-generate-btn') return;
            e.preventDefault();
            // Collect refs + prompt + style, then call generate endpoint
            const base = document.getElementById('ai-prompt');
            const prompt = (base?.value || '').trim();
            const styleSlider = document.getElementById('ai-style-slider');
            const sVal = parseFloat(styleSlider?.value || '0.5');
            const style = sVal < 0.33 ? 'realistic' : (sVal > 0.66 ? 'creative' : 'realistic');

            const refs = Array.from(document.querySelectorAll('#remix-assets img, #remix-assets video'))
              .map((el)=> el.getAttribute('src') || el.getAttribute('poster'))
              .filter(Boolean)
              .filter((v, i, arr) => arr.indexOf(v) === i)
              .slice(0,2);

            // Fallback to simple text-to-image if no refs
            if (refs.length < 2) {
              generateAiImage();
              return;
            }

            // Use existing assets API for AI image generation (single image)
            // We reuse the /assets/ai-images for now with count:1
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                // Compose a richer prompt mentioning references implicitly
                const styleMap = style === 'creative' ? 'illustration' : 'photographic';
                const data = await apiFetch('/assets/ai-images', { method:'POST', body: { prompt: `${prompt}`.trim(), style: style === 'creative' ? 'creative' : 'realistic', count: 1 } });
                const url = data?.data?.images?.[0]?.url || data?.images?.[0] || null;
                if (!url) { showError('ai-error', 'AI image generation failed'); return; }
                // Display result
                const aiBlock = document.getElementById('ai-result-block');
                const aiPrev = document.getElementById('ai-result-preview');
                if (aiBlock && aiPrev) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(url)}`;
                  aiPrev.innerHTML = `<img crossOrigin="anonymous" src="${proxied}" class="w-full h-full object-cover block" />`;
                  aiBlock.classList.remove('hidden');
                }
              } catch (err) {
                showError('ai-error', err?.message || 'AI generation error');
              }
            })();
        });

        // Save & Use handler: persists image URL and marks as selected background
        document.addEventListener('click', async (e) => {
            if (e.target?.id !== 'ai-save-use-btn') return;
            e.preventDefault();
            try {
              const imgEl = document.querySelector('#ai-result-preview img');
              const url = imgEl?.getAttribute('src');
              if (!url) return;
              const { apiFetch } = await import('./api.mjs');
              // Store the image in storage and get a tokenized URL
              const reg = await apiFetch('/uploads/register', { method:'POST', body:{ imageUrl: url } });
              const savedUrl = reg?.data?.url || url;
              // Mark selection locally and update preview immediately
              selectedAsset = { id: `ai-${Date.now()}`, provider: 'ai', query: (document.getElementById('ai-prompt')?.value||'').trim(), fileUrl: savedUrl, thumbUrl: savedUrl, width: 1024, height: 1024 };
              updateRenderPreview();
              updateRenderButtonState();
              // Also update dedicated preview nodes if present
              try {
                // Ensure we have a preview <img id="preview-img"> inside live preview
                let previewImg = document.getElementById('preview-img');
                if (!previewImg) {
                  const live = document.getElementById('live-preview-container');
                  if (live) {
                    live.classList.remove('hidden');
                    const holder = live.querySelector('.relative') || live;
                    // Force 9x16 preview aspect
                    try { holder.style.aspectRatio = '9 / 16'; } catch {}
                    try { if (!holder.style.background) holder.style.background = '#000'; } catch {}
                    // Clear holder if it only had a canvas (we'll still keep canvas for other flows)
                    // but append img above it so swap is visible immediately
                    previewImg = document.createElement('img');
                    previewImg.id = 'preview-img';
                    previewImg.style.width = '100%';
                    previewImg.style.height = '100%';
                    previewImg.style.display = 'block';
                    previewImg.style.objectFit = 'cover';
                    holder.prepend(previewImg);
                    // Hide canvas during static image preview to avoid black overlay
                    try { const c = holder.querySelector('#live-preview-canvas'); if (c) c.style.display = 'none'; } catch {}
                  }
                }
                if (previewImg) {
                  try { previewImg.crossOrigin = 'anonymous'; } catch {}
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewImg.src = proxied;
                }
                // Ensure overlay visible for still image preview
                try { const ov = document.getElementById('caption-overlay'); if (ov) ov.style.display = 'block'; } catch {}
                const previewBox = document.getElementById('short-preview');
                if (previewBox) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewBox.style.backgroundImage = `url("${proxied}")`;
                  previewBox.setAttribute('data-bg', proxied);
                }
                window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentBackgroundUrl = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
              } catch {}
              // Feedback
              try { showToast('✅ Saved to My Images and selected'); } catch {}
            } catch (err) {
              console.warn('Save & Use failed:', err);
            }
        });

        // Event listeners
        document.getElementById('generate-quote-btn').onclick = generateQuote;
        document.getElementById('use-text-btn').onclick = () => {
            const input = document.getElementById('quote-text').value.trim();
            if (!input) return;
            currentQuote = { text: input };
            displayQuote(currentQuote);
            // Ensure visible in view mode on use
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.classList.add('hidden');
            disp.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            // do not reset regen counter here
            // Persist immediately so it can be used for the short without extra clicks
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                await apiFetch('/quotes/save', { method:'POST', body:{ text: input, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
                try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = input; } catch {}
              } catch (e) {
                console.warn('Use This Text save failed:', e?.message || e);
              }
            })();
        };
        document.getElementById('search-assets-btn').onclick = () => {
            assetCache.clear(); // Clear cache on new search
            loadAssets(1);
        };
        document.getElementById('prev-page-btn').onclick = () => loadAssets(currentAssetPage - 1);
        document.getElementById('next-page-btn').onclick = () => loadAssets(currentAssetPage + 1);
        try { document.getElementById('generate-ai-btn').onclick = generateAiImage; } catch {}
        document.getElementById('upload-asset-btn').onclick = () => {
            document.getElementById('asset-upload-input').click();
        };
        document.getElementById('asset-upload-input').onchange = (e) => handleFileUpload(e.target.files);
        document.getElementById('clear-remix-btn').onclick = () => {
            remixAssets = [];
            updateRemixArea();
        };
        document.getElementById('render-btn').onclick = renderShort;
        
        // Caption style event listeners
        document.getElementById('caption-font').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-weight').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-size').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        document.getElementById('caption-opacity').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        document.getElementById('caption-placement').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-background').onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-bg-opacity').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        
        // Voiceover event listeners
        document.getElementById('voiceover-voice').onchange = () => {
            const voiceSelect = document.getElementById('voiceover-voice');
            currentVoiceId = voiceSelect.value || null;
            updateRenderPreview();
        };
        document.getElementById('preview-voice-btn').onclick = previewVoice;

        // Remix button event listeners (success-only decrement handled inside)
        try { document.getElementById('regenerate-btn').onclick = () => remixQuote('regenerate'); } catch {}
        try { document.getElementById('rephrase-btn').onclick = () => remixQuote('rephrase'); } catch {}
        try { document.getElementById('tone-shift-btn').onclick = () => remixQuote('tone_shift'); } catch {}

        // Inline edit handlers
        try { document.getElementById('edit-quote-btn').onclick = () => {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.value = (currentQuote?.text || '').trim();
            disp.classList.add('hidden');
            ta.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            // While editing, hide caption overlay
            updateCaptionOverlay('', false);
        }; } catch {}
        try { document.getElementById('cancel-quote-btn').onclick = () => {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            // remain in edit mode but clear contents
            ta.value = '';
            updateCaptionOverlay('', false);
            // do not change regen counter
        }; } catch {}
        document.getElementById('save-quote-btn').onclick = async () => {
            const ta = document.getElementById('quote-edit');
            const newText = ta.value.trim().slice(0, 200);
            if (!newText) return;
            currentQuote = { ...(currentQuote||{}), text: newText };
            document.getElementById('quote-text-display').textContent = newText;
            // do not reset regen counter on save
            // switch to locked/solid view after save
            ta.classList.add('hidden');
            document.getElementById('quote-text-display').classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            updateRenderPreview();
            updateCaptionOverlay(newText, true);

            // Persist to backend so it can be used in the short without CORS issues
            try {
              const { apiFetch } = await import('./api.mjs');
              await apiFetch('/quotes/save', { method: 'POST', body: { text: newText, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
              try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = newText; } catch {}
            } catch (e) {
              console.warn('Quote save failed (non-fatal):', e?.message || e);
            }
        };

        // Character counter for input
        document.getElementById('quote-text').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
        });

        // Also update counter when typing inside the inlaid editor
        document.getElementById('quote-edit').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
            // live overlay while editing
            try { updateCaptionOverlay(v, true); } catch {}
        });

        // Tab switching
        document.querySelectorAll('[data-type]').forEach(tab => {
            tab.onclick = () => {
                currentAssetType = tab.dataset.type;
                
                // Update tab styles
                document.querySelectorAll('[data-type]').forEach(t => {
                    t.className = 'px-4 py-2 rounded bg-gray-700';
                });
                tab.className = 'px-4 py-2 rounded bg-blue-600';
                
                // Show/hide controls
                const searchControls = document.getElementById('search-controls');
                const aiControls = document.getElementById('ai-controls');
                
                if (currentAssetType === 'ai') {
                    try { searchControls.classList.add('hidden'); } catch {}
                    try { aiControls && aiControls.classList.remove('hidden'); } catch {}
                } else {
                    try { searchControls.classList.remove('hidden'); } catch {}
                    try { aiControls && aiControls.classList.add('hidden'); } catch {}
                }
                
                // Clear cache and reset pagination for new type
                assetCache.clear();
                currentAssetPage = 1;
                
                // Load assets for new type
                if (currentAssetType !== 'ai') {
                    loadAssets(1);
                }
            };
        });

        // Theme toggle functionality
        function initTheme() {
            const themeToggle = document.getElementById('theme-toggle');
            if (!themeToggle) return;

            // Set initial theme
            if (localStorage.getItem("theme") === "dark") {
                document.documentElement.classList.add("dark");
                themeToggle.textContent = "🌙";
            } else {
                document.documentElement.classList.remove("dark");
                themeToggle.textContent = "☀️";
            }

            // Theme toggle event listener
            themeToggle.addEventListener("click", () => {
                const isDark = document.documentElement.classList.toggle("dark");
                localStorage.setItem("theme", isDark ? "dark" : "light");
                themeToggle.textContent = isDark ? "🌙" : "☀️";
            });
        }

        // Initialize authentication using existing system
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme first
            initTheme();
            
            // Wait for auth system to be ready
            const checkAuth = () => {
                if (window.auth && window.onAuthStateChanged) {
                    // Listen for auth state changes
                    window.onAuthStateChanged(window.auth, async (user) => {
                        const loggedIn = !!user;
                        
                        // Update UI visibility
                        document.querySelectorAll(".logged-in")?.forEach(el => el.classList.toggle("hidden", !loggedIn));
                        document.querySelectorAll(".logged-out")?.forEach(el => el.classList.toggle("hidden", loggedIn));

                        if (!loggedIn) {
                            updateCreditUI(0);
                            updateRenderButtonState();
                            return;
                        }

                        try {
                            // Give api.mjs a brief moment to obtain the token via the bridge
                            if (window.__vaiform_diag__?.tokenWait) { 
                                await window.__vaiform_diag__.tokenWait(4000); 
                            }
                            await refreshCredits(true);
                            
                            // Update render button state after auth changes
                            updateRenderButtonState();
                            
                            // Load voices with a small delay to ensure auth is fully ready
                            setTimeout(() => {
                                loadVoices();
                            }, 500);
                        } catch (e) {
                            console.error("Failed to refresh credits:", e);
                        }
                    });
                } else {
                    // Retry in 100ms if auth not ready yet
                    setTimeout(checkAuth, 100);
                }
            };
            
            checkAuth();

            // Initialize quote editor for manual entry from the start
            try {
                const seedInput = document.getElementById('quote-text');
                const seed = (seedInput?.value || '').trim();
                currentQuote = { text: seed };
                displayQuote(currentQuote);
                // Switch to edit mode by default so users can type immediately
                const disp = document.getElementById('quote-text-display');
                const ta = document.getElementById('quote-edit');
                disp.classList.add('hidden');
                ta.classList.remove('hidden');
                document.getElementById('save-quote-btn').classList.remove('hidden');
                document.getElementById('cancel-quote-btn').classList.remove('hidden');
                document.getElementById('edit-quote-btn').classList.add('hidden');
                // Do not reset regen counter on init
                // Ensure overlay reflects initial caption settings
                try { updateCaptionOverlay(seed, !!seed); } catch {}
                // Seed char counter
                const n = Math.min(200, seed.length);
                const cc = document.getElementById('quote-char-count');
                if (cc) cc.textContent = `${n}/200`;
            } catch {}
        });
    </script>


</body>
</html>
