<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Studio - Vaiform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Unified Header and Auth -->
    <script type="module">
        import { createUnifiedHeader, initializeHeader } from "/components/header.js";
        import { initializeAuth } from "/components/auth-utils.js";
        
        // Load unified header
        document.getElementById('unified-header').innerHTML = createUnifiedHeader();
        initializeHeader();
        
        // Initialize auth after a short delay to ensure Firebase is ready
        setTimeout(() => {
            initializeAuth();
        }, 100);
    </script>
    
    <!-- Firebase SDK - Load the same way as main site -->
    <script type="module" src="./js/firebaseClient.js"></script>
    <!-- Auth bridge: expose auth & wire token provider before page code -->
    <script type="module" src="./auth-bridge.js"></script>
    <script type="module" src="/js/credits-ui.js?v=20250920b"></script>
    <script type="module">
        // Make credits functions globally available
        import { updateCreditsDisplay, fetchAndUpdateCredits } from '/js/credits-ui.js?v=20250920b';
        window.updateCreditsDisplay = updateCreditsDisplay;
        window.fetchAndUpdateCredits = fetchAndUpdateCredits;
    </script>
    <script type="module">
        // Import render payload helper functions for SSOT preview workflow
        try {
            const { 
                getSavedOverlayMeta, 
                validateOverlayCaption,
                validateBeforeRender,
                showPreviewSavedIndicator,
                markPreviewUnsaved
            } = await import('/js/render-payload-helper.js');
            
            // Make globally available
            window.getSavedOverlayMeta = getSavedOverlayMeta;
            window.validateOverlayCaption = validateOverlayCaption;
            window.validateBeforeRender = validateBeforeRender;
            window.showPreviewSavedIndicator = showPreviewSavedIndicator;
            window.markPreviewUnsaved = markPreviewUnsaved;
            
            console.log('[module] render-payload-helper functions loaded successfully');
        } catch (error) {
            console.error('[module] Failed to load render-payload-helper:', error);
            // Set up fallback functions
            window.showPreviewSavedIndicator = function(containerSelector = '#preview-status') {
                const container = document.querySelector(containerSelector);
                if (!container) return;
                
                const meta = window.getSavedOverlayMeta ? window.getSavedOverlayMeta() : null;
                
                if (meta) {
                    container.innerHTML = `
                        <div class="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded text-sm">
                            <span>‚úì</span>
                            <span>Preview saved - ready to render</span>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="flex items-center gap-2 px-3 py-2 bg-yellow-600 text-white rounded text-sm">
                            <span>‚ö†</span>
                            <span>No preview saved - generate preview before rendering</span>
                        </div>
                    `;
                }
                container.classList.remove('hidden');
            };
            
            window.getSavedOverlayMeta = function() {
                if (window._overlayMeta) return window._overlayMeta;
                try {
                    const stored = localStorage.getItem('overlayMeta');
                    if (stored) {
                        const meta = JSON.parse(stored);
                        const timestamp = parseInt(localStorage.getItem('overlayMetaTimestamp') || '0', 10);
                        const age = Date.now() - timestamp;
                        if (age < 3600000) { // 1 hour
                            window._overlayMeta = meta;
                            return meta;
                        }
                    }
                } catch (err) {
                    console.warn('[fallback] Failed to load from localStorage:', err.message);
                }
                return null;
            };
        }
    </script>
    <script type="module" src="./frontend.js"></script>
    <!-- Delegated event system for action buttons -->
    <script src="./js/ui-actions.js"></script>
    <link rel="stylesheet" href="/creative.css" />
    <!-- Caption rendering now uses server-side PNG overlay - no fonts needed -->
    <style>
        .loading { opacity: 0.6; pointer-events: none; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        
        /* Force dark mode for content boxes */
        .dark .content-box {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        .dark .content-box h2 {
            color: #ffffff !important;
        }
        
        /* Force dark mode for quote result box */
        .dark #quote-result {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for quote text display */
        .dark #quote-text-display {
            color: #ffffff !important;
        }
        
        /* Force dark mode for quote edit textarea */
        .dark #quote-edit {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for remix area */
        .dark #remix-area {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for remix area heading */
        .dark #remix-area h3 {
            color: #d1d5db !important; /* gray-300 */
        }
        
        /* Force dark mode for remix assets container */
        .dark #remix-assets {
            background-color: transparent !important;
        }
        
        /* Force dark mode for AI result preview */
        .dark #ai-result-preview {
            background-color: #111827 !important; /* gray-900 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for render preview box */
        .dark #render-preview {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for preview text elements */
        .dark #preview-quote {
            color: #ffffff !important;
        }
        
        .dark #preview-asset,
        .dark #preview-caption-style,
        .dark #preview-voiceover {
            color: #9ca3af !important; /* gray-400 */
        }
        
        /* Force dark mode for remix input text */
        .dark #remix-input {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* --- Caption overlay stacking & sizing --- */
        #live-preview-container { position: relative; }
        #live-preview-canvas { position: relative; z-index: 1; display: block; width: 100%; height: auto; }
        #caption-overlay {
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 1;
        }
        /* Make sure preview media and any legacy containers never steal pointer events */
        #stage img, #stage video, #previewMedia, .preview-overlay, #previewOverlayCanvas, #previewOverlayImg {
            pointer-events: none;
            z-index: 1;
        }
        /* Draggable box must sit on top */
        .caption-box, .caption-box .drag-handle { touch-action: none; }
        .caption-box { z-index: 9999; }
    </style>
    <!-- Respect saved theme before paint - default to dark -->
    <script>
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "light") {
            document.documentElement.classList.remove("dark");
        } else {
            document.documentElement.classList.add("dark");
        }
    </script>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">
    <!-- Unified Header -->
    <div id="unified-header"></div>

    <div class="max-w-6xl mx-auto p-6 space-y-8">
        <!-- Header -->
        <div class="flex items-center justify-between">
            <h1 class="text-3xl font-bold">Creative Studio</h1>
        </div>

        <!-- Accordion Layout -->
        <div class="studio-accordion-layout">
            <!-- Left: Accordion Sections -->
            <div class="studio-accordion-left">
                <!-- Quote Section -->
                <div class="accordion-section">
                    <div class="accordion-header active" data-section="quote">
                        <div class="accordion-title">
                            <span class="accordion-icon">‚ñº</span>
                            <span class="accordion-label">Quote</span>
                        </div>
                        <div class="accordion-summary" id="quote-summary">Enter a prompt to generate quotes</div>
                    </div>
                    <div class="accordion-body active" id="quote-body">

                        <!-- Quote Generation Section -->
                        <div id="section-quote" class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
                            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Generate Quote</h2>
            
            <div class="flex gap-4 items-center">
                <input
                    type="text"
                    id="quote-text"
                    value="Create a motivational quote about success"
                    placeholder="Describe what kind of quote you want..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <div class="text-xs text-gray-500 dark:text-gray-400 w-20 text-right" id="quote-char-count">0/200</div>
                <select id="quote-tone" class="bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                    <option value="default">Default</option>
                    <option value="motivational">Motivational</option>
                    <option value="witty">Witty</option>
                    <option value="poetic">Poetic</option>
                    <option value="bold">Bold</option>
                    <option value="calm">Calm</option>
                </select>
                <button
                    id="generate-quote-btn"
                    data-action="generateQuote"
                    type="button"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded"
                >
                    Generate Quote
                </button>
            </div>

            <div id="quote-error" class="error text-sm hidden"></div>

            <div id="quote-result" class="bg-gray-100 dark:bg-gray-800 rounded p-4 space-y-3 border border-gray-200 dark:border-gray-700">
                <div class="flex items-start justify-between gap-3">
                    <div class="flex-1">
                        <div id="quote-text-display" class="text-lg font-medium text-gray-900 dark:text-white hidden"></div>
                        <textarea id="quote-edit" class="w-full bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm text-gray-900 dark:text-white" style="min-height: 100px;" placeholder="Enter your quote here or generate one above..."></textarea>
                        <div class="flex gap-2 mt-2">
                            <button id="save-quote-btn" data-action="saveQuote" type="button" class="px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-sm text-white">Save</button>
                            <button id="cancel-quote-btn" data-action="cancelEdit" type="button" class="px-3 py-1 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-sm text-white hidden">Cancel</button>
                        </div>
                    </div>
                    <div class="flex flex-col gap-2 items-end">
                        <div id="regen-info" class="text-xs text-gray-400">Regens left: 10</div>
                        <div class="flex gap-2">
                            <button id="edit-quote-btn" data-action="editQuote" type="button" class="px-3 py-1 bg-gray-600 dark:bg-neutral-700 hover:bg-gray-700 dark:hover:bg-neutral-600 rounded text-sm text-white hidden">Edit</button>
                        </div>
                    </div>
                </div>
                <div id="quote-author" class="text-sm text-gray-400 hidden"></div>
                <div id="quote-tone-tag" class="text-xs text-blue-400 hidden"></div>
                
                <!-- Remix buttons (Pro only) -->
                <div id="remix-buttons" class="flex gap-2">
                    <button id="regenerate-btn" data-action="regenerateQuote" type="button" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Regenerate
                    </button>
                    <button id="rephrase-btn" data-action="rephraseQuote" type="button" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Rephrase
                    </button>
                    <button id="tone-shift-btn" data-action="changeTone" type="button" class="px-3 py-1 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 rounded text-sm">
                        Change Tone
                    </button>
                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Media Section -->
                <div class="accordion-section">
                    <div class="accordion-header" data-section="media">
                        <div class="accordion-title">
                            <span class="accordion-icon">‚ñ∂</span>
                            <span class="accordion-label">Media</span>
                        </div>
                        <div class="accordion-summary" id="media-summary">No media selected</div>
                    </div>
                    <div class="accordion-body" id="media-body">
                        <!-- Asset Selection Section -->
                        <div id="section-media" class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
                            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Media</h2>
            
            <!-- Asset Type Tabs -->
            <div class="flex gap-2">
                <button id="images-tab" data-action="setMediaTab" type="button" class="px-4 py-2 rounded bg-blue-600 text-white" data-type="images">
                    Images
                </button>
                <button id="videos-tab" data-action="setMediaTab" type="button" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white" data-type="videos">
                    Videos
                </button>
                <button id="ai-tab" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white hidden" data-type="ai">
                    AI Images
                </button>
            </div>

            <!-- Remix Area -->
            <div id="remix-area" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-4 hidden border border-gray-200 dark:border-gray-700">
                <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Remix References (up to 2)</h3>
                <div id="remix-assets" class="flex gap-4">
                    <!-- Remix assets will be added here -->
                </div>
                <!-- AI result preview slot -->
                <div id="ai-result-block" class="mt-3 hidden">
                    <div class="flex flex-col items-center gap-2">
                        <div id="ai-ref-preview" class="flex gap-2 justify-center"></div>
                        <div id="ai-result-preview" class="relative w-full rounded overflow-hidden border border-gray-600 bg-black" style="aspect-ratio: 9/16;"></div>
                        <div class="mt-2">
                            <button id="ai-save-use-btn" class="px-3 py-1 bg-green-600 hover:bg-green-500 text-white text-xs rounded">Save & Use</button>
                        </div>
                    </div>
                </div>
                <!-- Inline AI prompt + style for ideogram remix -->
                <div class="mt-3 flex flex-wrap items-center gap-3">
                    <input
                        type="text"
                        id="ai-prompt"
                        value="A serene mountain landscape at sunset"
                        placeholder="Describe what to create from these references..."
                        class="flex-1 min-w-[16rem] bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm text-gray-900 dark:text-white"
                    />
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-400">Realistic</span>
                        <input type="range" id="ai-style-slider" min="0" max="1" step="0.1" value="0.5" class="w-24" />
                        <span class="text-xs text-gray-400">Creative</span>
                    </div>
                </div>
                <div class="mt-3 flex items-center gap-2">
                    <button
                        id="clear-remix-btn"
                        class="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-xs rounded"
                    >
                        Clear All
                    </button>
                    <button
                        id="remix-generate-btn"
                        class="px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded"
                        title="Generate a new AI image using the selected references"
                    >
                        20 Credits
                    </button>
                </div>
            </div>

            <!-- Search Controls -->
            <div id="search-controls" class="flex gap-4 items-center">
                <input
                    type="text"
                    id="asset-query"
                    value="nature"
                    placeholder="Search for images/videos..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <button
                    id="search-assets-btn"
                    data-action="searchAssets"
                    type="button"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded text-white"
                >
                    Search
                </button>
                <button
                    id="upload-asset-btn"
                    class="px-3 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-white"
                    title="Upload your own image or video"
                >
                    üìÅ
                </button>
                <input
                    type="file"
                    id="asset-upload-input"
                    accept="image/*,video/*"
                    class="hidden"
                />
            </div>

            <!-- AI Images Controls removed (inline controls are now in remix-area) -->
            <div id="ai-error" class="error text-sm hidden"></div>

            <div id="asset-error" class="error text-sm hidden"></div>

            <!-- Asset Grid (3 rows √ó 4 columns ‚âà 12 results) -->
            <div id="asset-grid" class="grid grid-cols-4 gap-4">
                <!-- Assets will be populated here -->
            </div>

            <!-- Pagination Controls -->
            <div id="pagination-container" class="flex justify-between items-center mt-4 hidden">
                <button
                    id="prev-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    ‚Üê Previous
                </button>
                <span id="page-info" class="text-sm text-gray-600 dark:text-gray-400">Page 1</span>
                <button
                    id="next-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    Next ‚Üí
                </button>
            </div>

            <!-- Free Plan Notice -->
            <div id="free-notice" class="text-center text-sm text-gray-400 hidden">
                Showing 12 curated assets. 
                <span class="text-blue-400"> Upgrade to Pro</span> for larger pages and AI images.
            </div>
        </div>

        <!-- Caption Style Section (Hidden during transition) -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600" style="display: none;">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Caption Style</h2>
            
            <!-- Overlay Mode Toggle -->
            <div class="mb-4">
                <label class="flex items-center gap-2">
                    <input type="checkbox" id="overlay-mode-toggle" class="rounded" />
                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Use Draggable Overlay</span>
                </label>
            </div>
            
            <!-- Overlay Controls (shown when overlay mode is enabled) -->
            <div id="overlay-controls" class="mb-4 space-y-3" style="display: none;">
                <div>
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="show-outline-toggle" class="rounded" checked />
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Show outline</span>
                    </label>
                </div>
                <div>
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="responsive-text-toggle" class="rounded" checked />
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Responsive text</span>
                    </label>
                </div>
            </div>
            
            
            
            <div class="grid grid-cols-2 gap-4">
                <!-- Font Family -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Font</label>
                    <select id="caption-font" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="system">System</option>
                        <option value="bold">Bold</option>
                        <option value="cinematic">Cinematic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                
                <!-- Font Weight -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Weight</label>
                    <select id="caption-weight" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                    </select>
                </div>
                
                <!-- Size -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Size: <span id="size-value">80px</span></label>
                    <input
                        type="range"
                        id="caption-size"
                        min="0"
                        max="100"
                        value="60"
                        class="w-full"
                    />
                </div>
                
                <!-- Opacity -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Opacity: <span id="opacity-value">80%</span></label>
                    <input
                        type="range"
                        id="caption-opacity"
                        min="30"
                        max="100"
                        value="80"
                        class="w-full"
                    />
                </div>
                
                <!-- Placement -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Placement</label>
                    <select id="caption-placement" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="top">Top</option>
                        <option value="middle">Middle</option>
                        <option value="bottom" selected>Bottom</option>
                    </select>
                </div>
                
                <!-- Background Box -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Background</label>
                    <div class="flex items-center gap-4">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="caption-background" class="rounded" />
                            <span class="text-sm">Show box</span>
                        </label>
                        <div class="flex-1">
                            <label class="block text-xs text-gray-400 mb-1">Box opacity: <span id="bg-opacity-value">50%</span></label>
                            <input
                                type="range"
                                id="caption-bg-opacity"
                                min="0"
                                max="100"
                                value="50"
                                class="w-full"
                            />
                        </div>
                    </div>
                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Voiceover Section -->
                <div class="accordion-section">
                    <div class="accordion-header" data-section="voice">
                        <div class="accordion-title">
                            <span class="accordion-icon">‚ñ∂</span>
                            <span class="accordion-label">Voiceover</span>
                        </div>
                        <div class="accordion-summary" id="voice-summary">No voice selected</div>
                    </div>
                    <div class="accordion-body" id="voice-body">
                        <!-- Voiceover Section -->
                        <div id="section-voice" class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
                            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Voiceover</h2>
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Voice</label>
                    <div class="flex gap-2">
                        <select id="voiceover-voice" class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                            <option value="">Loading voices...</option>
                        </select>
                        <button id="retry-voices-btn" onclick="loadVoices()" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm">
                            üîÑ
                        </button>
                    </div>
                </div>
                <div class="flex items-end gap-2">
                    <button
                        id="preview-voice-btn"
                        class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white"
                        disabled
                    >
                        Preview Voice
                    </button>
                    <audio id="voice-preview-audio" class="hidden" controls></audio>
                </div>
            </div>
            
            <!-- TTS Settings -->
            <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Stability</label>
                    <input type="range" id="tts-stability" min="0" max="1" step="0.1" value="0.5" class="w-full">
                    <div class="text-xs text-gray-500 mt-1">Value: <span id="stability-value">0.5</span></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Similarity Boost</label>
                    <input type="range" id="tts-similarity" min="0" max="1" step="0.1" value="0.75" class="w-full">
                    <div class="text-xs text-gray-500 mt-1">Value: <span id="similarity-value">0.75</span></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Style</label>
                    <input type="range" id="tts-style" min="0" max="100" step="1" value="0" class="w-full">
                    <div class="text-xs text-gray-500 mt-1">Value: <span id="style-value">0</span></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Speaker Boost</label>
                    <input type="checkbox" id="tts-speaker-boost" checked class="rounded">
                    <div class="text-xs text-gray-500 mt-1">Enhance speaker characteristics</div>
                </div>
            </div>
            
                            <div id="voice-preview-status" class="text-sm text-gray-400 hidden"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right: Preview Section -->
            <div class="studio-accordion-right">
                <!-- Render Section -->
                <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Live Preview</h2>
            
            <!-- Live Preview Canvas -->
            <div id="live-preview-container" class="opacity-0 transition-opacity duration-300" style="min-height: 400px; width: 360px;">
                <!-- Fix A: Give the preview wrapper a predictable size -->
                <div class="relative mx-auto bg-black rounded-lg overflow-hidden" style="width: 360px; aspect-ratio: 9 / 16;">
                    <canvas id="live-preview-canvas" class="w-full h-full block"></canvas>
                    <!-- Legacy caption overlay (hidden when using new overlay system) -->
                    <img
                      id="caption-overlay"
                      class="absolute inset-0 pointer-events-none block w-full h-full"
                      style="z-index:2"
                    />
                    <!-- New draggable caption overlay container -->
                    <div id="stage" class="absolute inset-0 w-full h-full" style="z-index:3; display:none;">
                        <img id="previewMedia" class="w-full h-full object-cover" />
                    </div>
                    </div>
                </div>
                
                <!-- Render buttons below preview -->
                <div class="mt-4 flex flex-col items-center gap-3">
                    <!-- Preview Status Indicator -->
                    <div id="preview-status" class="hidden"></div>
                    
                    <!-- Action Buttons -->
                    <div class="flex gap-3">
                        <!-- Save Preview Button -->
                        <button
                            id="save-preview-btn"
                            class="px-6 py-3 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-base font-semibold text-white shadow-md transition-colors"
                        >
                            Save Preview
                        </button>
                        
                        <!-- Render Button (disabled until preview saved) -->
                        <button
                            id="render-btn"
                            class="px-6 py-3 bg-green-600 hover:bg-green-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-base font-semibold text-white shadow-md transition-colors"
                            disabled
                            title="Save preview first"
                        >
                            Render
                        </button>
                    </div>
                </div>
                
                <div id="render-preview" class="bg-gray-100 dark:bg-gray-800 rounded p-4 hidden border border-gray-200 dark:border-gray-700">
                    <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">Preview:</div>
                    <div id="preview-quote" class="text-lg font-medium mb-2 text-gray-900 dark:text-white"></div>
                    <div id="preview-asset" class="text-sm text-gray-600 dark:text-gray-400"></div>
                    <div id="preview-caption-style" class="text-sm text-gray-600 dark:text-gray-400"></div>
                    <div id="preview-voiceover" class="text-sm text-gray-600 dark:text-gray-400"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { BACKEND as BACKEND_FROM_CONFIG } from '/config.js';

        const API_BASE_FALLBACK = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        // Hard-force the backend origin to Replit to avoid Netlify handling /cdn
        const API_BASE_FIXED = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        function getApiBase(){
            return API_BASE_FIXED.replace(/\/$/, '');
        }

        // --- Auth ready (wait for Firebase to finish initializing exactly once) ---
        window.__authReady = window.__authReady || new Promise((resolve) => {
          try {
            // If firebase auth is already available, attach listener; otherwise poll briefly
            const attach = () => {
              if (window.firebase && window.firebase.auth) {
                window.firebase.auth().onAuthStateChanged((user) => {
                  window.__currentUser = user || null;
                  resolve(user || null);
                });
                return true;
              }
              return false;
            };
            if (!attach()) {
              const t = setInterval(() => {
                if (attach()) clearInterval(t);
              }, 50);
              setTimeout(() => { clearInterval(t); resolve(null); }, 5000); // worst-case resolve
            }
          } catch {
            resolve(null);
          }
        });

        // --- Caption sizing constants (HOISTED) ---
        const UI_MIN_PX = 48;     // slider min visual (increased to prevent text disappearing)
        const UI_MID_PX = 72;     // slider mid visual (more reasonable middle)
        const UI_MAX_PX = 120;    // slider max visual (capped to prevent overflow)
        const API_MIN_PX = 32;    // backend clamp lower bound
        const API_MAX_PX = 120;   // backend clamp upper bound (match server ABS_MAX_FONT)

        // --- Caption size mapping (define BEFORE any usage)
        function mapSliderToPx(sliderVal) {
          // non-linear map slider value to pixel range, then clamp to API bounds
          const raw = Number(sliderVal);
          
          if (!isFinite(raw)) {
            return API_MIN_PX + (API_MAX_PX - API_MIN_PX) / 2; // fallback to middle
          }
          
          const v = Math.max(0, Math.min(100, raw));
          const t = v / 100;
          // Non-linear mapping: size = 32 + (120-32)*Math.pow(t,0.6)
          const size = API_MIN_PX + (API_MAX_PX - API_MIN_PX) * Math.pow(t, 0.6);
          
          return Math.max(API_MIN_PX, Math.min(API_MAX_PX, Math.round(size)));
        }

        function getCaptionPx() {
            const el = document.getElementById('caption-size');
            return mapSliderToPx(el ? el.value : 50);
        }
        
        // Font size clamping to prevent overflow with binary search for better responsiveness
        function fitFontPx(targetFontPx, text, W = 1080, H = 1920) {
            const min = 24, max = 160;
            const padPctTop = 0.08, padPctBottom = 0.08;
            const maxWidthPct = 0.90; // increased from 0.85
            const lineHeight = 1.05; // reduced from 1.1
            const maxTextWidth = W * maxWidthPct;
            const maxTextHeight = H * (1 - padPctTop - padPctBottom);
            
            function measureFits(fontPx) {
                // Simple word wrapping simulation
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine ? `${currentLine} ${word}` : word;
                    // Rough width estimation (fontPx * 0.6 is approximate)
                    const estimatedWidth = testLine.length * fontPx * 0.6;
                    
                    if (estimatedWidth <= maxTextWidth && currentLine) {
                        currentLine = testLine;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                const totalHeight = lines.length * fontPx * lineHeight;
                return totalHeight <= maxTextHeight;
            }
            
            let lo = min, hi = Math.min(max, targetFontPx), best = lo;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1; // binary search
                if (measureFits(mid)) { 
                    best = mid; 
                    lo = mid + 1; 
                } else { 
                    hi = mid - 1; 
                }
            }
            
            if (best !== targetFontPx) {
                console.log(`[caption] Font size ${targetFontPx}px fitted to ${best}px for better responsiveness`);
            }
            
            return best;
        }

        // Fix D: Preview geometry helper using proper CSS/backing separation
        function getPreviewGeometry(canvas) {
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const cssW = canvas.clientWidth;  // CSS size
            const cssH = canvas.clientHeight; // CSS size
            const backingW = canvas.width;    // Backing store size
            const backingH = canvas.height;   // Backing store size
            const scaleX = cssW / 1080; // CSS size to PNG native size
            const scaleY = cssH / 1920;
            
            return { dpr, cssW, cssH, backingW, backingH, scaleX, scaleY };
        }

        // expose for other code
          window.getCaptionPx = getCaptionPx;
        window.__captionSizeMapping = { mapSliderToPx, API_MIN_PX, API_MAX_PX, UI_MIN_PX, UI_MID_PX, UI_MAX_PX };

        // --- Auth-aware login warning function ---
        async function ensureLoggedInOrWarn() {
          const warnEl = document.getElementById('asset-error'); // the red text element
          if (!warnEl) return true; // nothing to do
          const user = await window.__authReady;
          const isLoggedIn = !!user;
          if (isLoggedIn) {
            warnEl.style.display = 'none'; // hide when logged in
          }
          return isLoggedIn;
        }

        // --- Helper to get active asset type ---
        function getActiveAssetType() {
          const activeTab = document.querySelector('[data-type].bg-blue-600') ||
                            document.querySelector('[data-type]');
          return activeTab?.dataset.type || 'images'; // fallback to images (default tab)
        }

        // --- High-quality Pexels preview URL helper ---
        function bestPexelsPreviewUrl(photo, targetWidth = 720, targetHeight = 1280) {
          if (!photo || !photo.src) return null;
          
          const src = photo.src;
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
          
          // Prefer portrait, then large2x, then large, fallback to original/medium
          let baseUrl = src.portrait || src.large2x || src.large || src.original || src.medium;
          
          if (!baseUrl) return null;
          
          // Add Pexels optimization parameters for high-quality preview
          const params = new URLSearchParams({
            auto: 'compress',
            cs: 'tinysrgb',
            dpr: dpr.toString(),
            fit: 'crop',
            w: targetWidth.toString(),
            h: targetHeight.toString()
          });
          
          return `${baseUrl}?${params.toString()}`;
        }

        // === Pexels Preview Quality + Trace Helpers ===
        function _isHiResPreviewUrl(url) {
          if (!url) return false;
          // Must NOT be just h=350; should include fit=crop and explicit w/h and dpr
          return /fit=crop/.test(url) && /[?&]w=\d+/.test(url) && /[?&]h=\d+/.test(url);
        }
        
        function _pexelsPreviewUrlFromPhoto(photo, needW, needH, headroom = 1.2) {
          const base =
            (photo?.src?.portrait) ||
            (photo?.src?.large2x) ||
            (photo?.src?.large) ||
            (photo?.src?.original) ||
            (photo?.src?.medium);
          if (!base) return null;
          const join = base.includes('?') ? '&' : '?';
          const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
          const w = Math.ceil(needW * headroom);
          const h = Math.ceil(needH * headroom);
          return `${base}${join}auto=compress&cs=tinysrgb&fit=crop&dpr=${dpr}&w=${w}&h=${h}`;
        }
        
        // Fix B: Updated HiDPI canvas setup using sizeCanvasToCSS
        function _setupHiDPICanvas(canvas, cssW, cssH) {
          // Use the new sizing function
          if (!sizeCanvasToCSS(canvas)) {
            // Fallback to manual setup if sizeCanvasToCSS fails
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width  = Math.round(cssW * dpr);
            canvas.height = Math.round(cssH * dpr);
            canvas.style.width  = `${cssW}px`;
            canvas.style.height = `${cssH}px`;
          }
          
          const ctx = canvas.getContext('2d');
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          return { ctx, dpr };
        }
        
        // Visual breadcrumb on the canvas so we know who drew last
        const DEBUG_CANVAS = false;
        function _tapCanvas(label) {
          if (!DEBUG_CANVAS) return;
          try {
            const c = document.getElementById('live-preview-canvas');
            if (!c) return;
            const x = c.getContext('2d');
            x.save();
            x.font = '12px system-ui';
            x.fillStyle = 'rgba(255,255,255,.95)';
            x.strokeStyle = 'rgba(0,0,0,.6)';
            x.strokeText(label, 8, 18);
            x.fillText(label, 8, 18);
            x.restore();
          } catch {}
        }

        // Legacy function - now calls the new helper
        function pexelsPreviewUrl(photo, needW, needH, headroom = 1.2) {
          return _pexelsPreviewUrlFromPhoto(photo, needW, needH, headroom);
        }

        // --- Pexels hi-res intercept helpers (preview-only) ---
        function _buildHiResPexelsUrlFromBase(baseUrl, needW, needH) {
          try {
            const u = new URL(baseUrl);
            if (u.hostname !== 'images.pexels.com') return baseUrl;
            // We always prefer fit=crop + explicit w/h + dpr
            const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
            u.searchParams.set('auto', 'compress');
            u.searchParams.set('cs', 'tinysrgb');
            u.searchParams.set('fit', 'crop');
            u.searchParams.set('dpr', String(dpr));
            u.searchParams.set('w', String(Math.ceil(needW * 1.2)));
            u.searchParams.set('h', String(Math.ceil(needH * 1.2)));
            // remove stray h=350 if present
            return u.toString();
          } catch { return baseUrl; }
        }

        // Given whatever the app thinks is the preview URL, ensure it is hi-res for the canvas draw.
        function _ensureHiResPreviewUrl(rawUrl, canvas) {
          if (!rawUrl) return rawUrl;
          const needW = canvas.width || canvas.clientWidth;
          const needH = canvas.height || canvas.clientHeight;
          return _buildHiResPexelsUrlFromBase(rawUrl, needW, needH);
        }

        // Fix A: Use predictable wrapper dimensions
        function layoutPreviewDims() {
          const box = document.querySelector('#live-preview-container .relative');
          if (box) {
            // Use the fixed wrapper dimensions
            const cssW = box.clientWidth || 360; // fallback to our fixed width
            const cssH = Math.round(cssW * 16 / 9); // lock to 9:16 portrait
            return { cssW, cssH };
          }
          // Fallback to default dimensions
          return { cssW: 360, cssH: 640 };
        }

        function drawCover(ctx, img, cssW, cssH) {
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.max(cssW / iw, cssH / ih); // COVER (fill + crop)
          const dw = iw * scale, dh = ih * scale;
          const dx = (cssW - dw) / 2, dy = (cssH - dh) / 2;
          ctx.clearRect(0, 0, cssW, cssH);
          ctx.drawImage(img, dx, dy, dw, dh);
        }

        function setupHiDPICanvas(canvas, cssW, cssH) {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          canvas.width  = Math.round(cssW * dpr);
          canvas.height = Math.round(cssH * dpr);
          canvas.style.width  = `${cssW}px`;
          canvas.style.height = `${cssH}px`;
          const ctx = canvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          return { ctx, dpr };
        }

        // --- High-quality canvas drawing helper with HiDPI support ---
        function drawPreviewOnCanvas(canvas, ctx, img, targetWidth = 400, targetHeight = 711) {
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
          
          // Set up HiDPI canvas
          canvas.width = targetWidth * dpr;
          canvas.height = targetHeight * dpr;
          canvas.style.width = `${targetWidth}px`;
          canvas.style.height = `${targetHeight}px`;
          
          // Enable high-quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // Set transform for HiDPI
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          
          // Calculate cover-fit dimensions (fill canvas without distortion)
          const imgAspect = img.naturalWidth / img.naturalHeight;
          const canvasAspect = targetWidth / targetHeight;
          
          let drawWidth, drawHeight, drawX, drawY;
          
          if (imgAspect > canvasAspect) {
            // Image is wider - fit height, crop width
            drawHeight = targetHeight;
            drawWidth = drawHeight * imgAspect;
            drawX = (targetWidth - drawWidth) / 2;
            drawY = 0;
          } else {
            // Image is taller - fit width, crop height
            drawWidth = targetWidth;
            drawHeight = drawWidth / imgAspect;
            drawX = 0;
            drawY = (targetHeight - drawHeight) / 2;
          }
          
          // Draw the image with cover-fit
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        // --- Race protection for preview loading ---
        let _previewReqId = 0;
        let _currentPexelsPhoto = null; // Track current photo for resize re-rendering

        async function _drawBackground(url, canvas, cssW, cssH, who='drawBackground') {
          const my = ++_previewReqId;
          const startTime = performance.now();
          console.log('[asset-load] Starting background load:', { url: url.substring(0, 50), who, my });
          
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.decoding = 'async';
          img.src = url;
          await img.decode();
          if (my !== _previewReqId) return;
          
          const loadTime = performance.now() - startTime;
          console.log('[asset-load] Background loaded:', { 
            duration: Math.round(loadTime), 
            naturalWidth: img.naturalWidth, 
            naturalHeight: img.naturalHeight,
            who, my 
          });
          
          const ctx = canvas.getContext('2d');
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.max(cssW/iw, cssH/ih);
          const dw = iw*scale, dh = ih*scale;
          const dx = (cssW - dw)/2, dy = (cssH - dh)/2;
          ctx.clearRect(0,0,cssW,cssH);
          ctx.drawImage(img, dx, dy, dw, dh);
          
          console.log('[asset-load] First drawImage completed:', { 
            duration: Math.round(performance.now() - startTime),
            canvasSize: `${cssW}x${cssH}`,
            imageSize: `${iw}x${ih}`,
            drawSize: `${dw}x${dh}`,
            who, my 
          });
          window._currentPreviewUrl = url;
          _tapCanvas(`${who}`);
        }

        // --- Debounced caption overlay refresh (prevents blocking assets) ---
        let overlayRefreshTimer = null;
        function queueCaptionOverlayRefresh() {
          // Legacy function - no longer used in overlay mode
          if (overlayRefreshTimer) clearTimeout(overlayRefreshTimer);
          overlayRefreshTimer = setTimeout(() => {
            try {
              // Call existing caption overlay update function
              if (typeof updateCaptionOverlay === 'function' && currentQuote?.text) {
                updateCaptionOverlay(currentQuote.text.trim(), true);
              }
            } catch (e) {
              console.warn('[caption-overlay] preview failed (non-fatal)', e);
            }
          }, 120); // 120ms debounce to reduce server load
        }

        // Safe placeholder if real loader is attached later
        window.loadVoices = window.loadVoices || (async function () {
          console.debug('[voice] loadVoices placeholder (no-op)');
          // If you have a real loader like populateVoicesDropdown(), call it here instead:
          // return populateVoicesDropdown();
        });

        // Helper for clearer logging
        window.__log = (...args) => console.log('[assets]', ...args);

        // Global state
        let currentLimits = null;
        let currentQuote = null;
        let selectedAsset = null;
        // SSOT: Use window scope so ui-actions.js can update it
        window.currentAssetType = window.currentAssetType || 'images';
        let currentAssetPage = 1;
        let hasMoreAssets = false;
        let currentCredits = 0;
        let remixAssets = [];
        let assetCache = new Map(); // Cache for pagination
        let uploadedAssets = [];
        let availableVoices = [];
        let currentVoiceId = null;

        // Helper functions - PNG overlay system
        let captionOverlayState = null;
        let captionDebounceTimer = null;
        
        // New draggable overlay system
        let overlaySystemInitialized = false;
        let useOverlayMode = true; // Default to overlay mode as SSOT

        // Helper functions for overlay management
        const must = (sel) => {
            const el = typeof sel === 'string' ? document.querySelector(sel) : sel;
            if (!el) throw new Error('MISSING_EL: ' + sel);
            return el;
        };

        const canOverlay = () => useOverlayMode && overlaySystemInitialized;

        function setQuoteUI(text) {
            const out = document.querySelector('#quote-result');
            if (out) out.textContent = text;
        }

        async function maybeUpdateOverlay(text, force = true) {
            try {
                await ensureOverlayActive();
                if (canOverlay()) {
                    await updateOverlayCaption(text.trim(), force);
                } else {
                    setQuoteUI(text);
                }
            } catch (e) {
                console.warn('[overlay] fallback to text-only UI', e);
                setQuoteUI(text);
            }
        }

        // Ensure overlay is active and initialized
        async function ensureOverlayActive() {
            try {
                useOverlayMode = true;
                const chk = document.getElementById('overlay-mode-toggle');
                if (chk && !chk.checked) chk.checked = true;
                if (!overlaySystemInitialized) {
                    await initOverlaySystem();
                }
                // Apply current quote text into overlay and refresh background
                if (currentQuote?.text) {
                    try { const { setQuote } = await import('./js/caption-overlay.js');
                      setQuote(currentQuote.text.trim());
                      console.log('[overlay-caption] set:', currentQuote.text.trim().substring(0,80));
                    } catch {}
                }
                if (typeof updateOverlayCanvasBackground === 'function') updateOverlayCanvasBackground();
                // Reflect UI: show stage, hide legacy image
                const stage = document.getElementById('stage');
                const legacyOverlay = document.getElementById('caption-overlay');
                if (stage) {
                    stage.style.display = 'block';
                    // Ensure stage has minimum height and black background when no media
                    if (!selectedAsset) {
                        stage.style.minHeight = '400px';
                        stage.style.backgroundColor = '#000';
                        const previewMedia = document.getElementById('previewMedia');
                        if (previewMedia) {
                            previewMedia.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
                            previewMedia.style.display = 'block';
                        }
                    }
                }
                if (legacyOverlay) legacyOverlay.style.display = 'none';
                console.log('[overlay] ensureOverlayActive: stage visible, hasMedia:', !!selectedAsset);
            } catch (e) { console.warn('[overlay] ensureOverlayActive failed', e); }
        }
        
        // Debounced caption preview generator
        function debouncedPreview(delay = 200) {
            // Legacy function - no longer used in overlay mode
            clearTimeout(captionDebounceTimer);
            captionDebounceTimer = setTimeout(() => {
                if (currentQuote?.text?.trim()) {
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            }, delay);
        }
        
        function maybeGenerateCaptionPreview() {
            const txt = currentQuote?.text?.trim() || '';
            if (txt.length && selectedAsset) {
                debouncedPreview();
            }
        }
        
        async function updateCaptionOverlay(text = '', show = true) {
            // Legacy function - use maybeUpdateOverlay instead for new overlay system
            console.log('[preview-init] updateCaptionOverlay called with:', { text: text?.substring(0, 50), show });
            
            const overlay = document.getElementById('caption-overlay');
            if (!overlay) return;
            
            // Ensure container is visible and has a size before drawing
            const container = document.getElementById('live-preview-container');
            if (!container) return;
            
            // Fallback gate: Don't proceed if container is effectively hidden (but allow opacity-0 if has dimensions)
            if (container.offsetParent === null) {
                console.log('[preview-init] Container not visible, skipping caption overlay');
                return;
            }
            
            // If container has opacity-0 but has dimensions, proceed (will be made visible)
            if (container.classList.contains('opacity-0')) {
                console.log('[preview-init] Container has opacity-0 but has dimensions, proceeding...');
            }
            
            container.classList.remove('opacity-0');
            
            // Log container dimensions
            const containerRect = container.getBoundingClientRect();
            console.log('[preview-init] container dimensions:', { 
                cssW: containerRect.width, 
                cssH: containerRect.height, 
                dpr: window.devicePixelRatio 
            });
            
            // New canvas ready logic with feature flag
            if (window.__PREVIEW_FIX__) {
                const canvas = document.getElementById('live-preview-canvas');
                if (!canvas || !canvasReadyState.ready) {
                    console.log('[canvas-ready] Canvas not ready, scheduling render');
                    scheduleRender();
                    return;
                }
            } else {
                // Legacy logic for fallback
                const ensureSized = () =>
                    (container.clientWidth > 0 && container.clientHeight > 0) ? true : false;
                if (!ensureSized()) {
                    await new Promise(requestAnimationFrame);
                }
                if (!ensureSized()) {
                    console.warn('[caption-overlay] Container still has no size, skipping overlay');
                    return;
                }
                
                const canvas = document.getElementById('live-preview-canvas');
                if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                    console.log('[canvas-ready] Canvas not ready, scheduling retry...', {
                        canvasExists: !!canvas,
                        clientWidth: canvas?.clientWidth,
                        clientHeight: canvas?.clientHeight,
                        canvasWidth: canvas?.width,
                        canvasHeight: canvas?.height
                    });
                    // Two RAF deferral as suggested
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    const retryCanvas = document.getElementById('live-preview-canvas');
                    if (!retryCanvas || retryCanvas.clientWidth === 0 || retryCanvas.clientHeight === 0) {
                        console.warn('[canvas-ready] Canvas still not ready after deferral, skipping overlay');
                        return;
                    }
                }
            }
            
            // Clear existing overlay
            overlay.innerHTML = '';
            
            if (!show || !text?.trim()) {
                captionOverlayState = null;
                return;
            }

            // Get caption style parameters from UI
            const sizePx = window.getCaptionPx(); // Use original mapped size logic
            const opacityPct = parseInt(document.getElementById('caption-opacity')?.value || '85', 10);
            const placement = (document.getElementById('caption-placement')?.value || 'bottom').toLowerCase();
            const showBoxToggle = document.getElementById('caption-background')?.checked || false;
            const boxOpacityPct = parseInt(document.getElementById('caption-bg-opacity')?.value || '50', 10);
            const selectedWeight = document.getElementById('caption-weight')?.value || 'bold';
            
            console.log('[preview-scaling]', { 
                mappedSizePx: sizePx
            });

            // Map UI selection to server placement format
            function placementToServerFormat(placement) {
                switch ((placement || 'bottom').toLowerCase()) {
                    case 'top':    return { placement: 'top' };
                    case 'middle': 
                    case 'center': return { placement: 'center' };
                    case 'bottom': 
                    default:       return { placement: 'bottom' };
                }
            }
            
            // Validate yPct to prevent extreme values
            function validateYPct(yPct) {
                const clamped = Math.max(0.05, Math.min(0.95, Number(yPct)));
                if (clamped !== Number(yPct)) {
                    console.warn(`[caption] yPct ${yPct} clamped to ${clamped} to prevent off-screen positioning`);
                }
                return clamped;
            }
            
            const placementData = placementToServerFormat(placement);
            
            console.log('[caption-debug] Placement mapping:', {
                uiPlacement: placement,
                serverPlacement: placementData.placement
            });
            
            // Map UI font selection to server font names (only use registered fonts)
            const fontMapping = {
                'system': { family: 'DejaVuSans', weightCss: 'normal' },
                'bold': { family: 'DejaVuSans', weightCss: 'bold' },
                'cinematic': { family: 'DejaVuSans', weightCss: 'bold' }, // Fallback to DejaVu until we add more fonts
                'minimal': { family: 'DejaVuSans', weightCss: 'normal' }
            };
            
            const selectedFont = document.getElementById('caption-font')?.value || 'system';
            const fontConfig = fontMapping[selectedFont] || fontMapping['system'];
            
            const captionStyle = {
                text: text.trim(),
                fontFamily: fontConfig.family,
                weightCss: fontConfig.weightCss,
                fontPx: sizePx, // Use fitted size
                color: "#FFFFFF",
                opacity: opacityPct / 100,
                shadow: true,
                showBox: showBoxToggle,
                boxColor: `rgba(0,0,0,${boxOpacityPct/100})`,
                placement: placementData.placement, // Server will compute yPct based on placement
                lineHeight: 1.05, // reduced for better stacking
                padding: 24,
                maxWidthPct: 0.90, // increased for bigger text
                borderRadius: 16
            };
            
            console.log('[caption-debug] Final captionStyle:', {
                placement: captionStyle.placement,
                yPct: captionStyle.yPct,
                text: captionStyle.text.substring(0, 50) + '...'
            });

            // Debounce caption generation
            clearTimeout(captionDebounceTimer);
            captionDebounceTimer = setTimeout(async () => {
                try {
                    // If draggable overlay mode is on, apply styles to overlay and skip legacy PNG path
                    if (useOverlayMode) {
                        try {
                            const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js');
                            const meta = getCaptionMeta && getCaptionMeta();
                            if (meta) {
                                // Update overlay style based on current UI controls
                                meta.fontPx = captionStyle.fontPx;
                                meta.fontFamily = captionStyle.fontFamily;
                                meta.weightCss = captionStyle.weightCss || captionStyle.weight;
                                meta.color = '#FFFFFF';
                                meta.opacity = captionStyle.opacity;
                                applyCaptionMeta && applyCaptionMeta(meta);
                            }
                            // Keep the stage background in sync with the canvas
                            if (typeof updateOverlayCanvasBackground === 'function') updateOverlayCanvasBackground();
                        } catch (e) {
                            console.warn('[overlay-style] apply failed; falling back to legacy preview', e);
                        }
                        return; // Do not generate PNG while overlay mode is active
                    }

                    console.log('[caption-overlay] Generating PNG preview...');
                    
                    // Ensure preview container is visible before generating overlay
                    document.getElementById('live-preview-container')?.classList.remove('opacity-0');
                    
                    // Import the caption preview function
                    const { generateCaptionPreview, getLastCaptionPNG, createCaptionOverlay } = await import('./js/caption-preview.js');
                    
                    // Import the new draggable overlay system
                    const { initCaptionOverlay, getCaptionMeta, applyCaptionMeta, setQuote } = await import('./js/caption-overlay.js');
                    
                    // Build proper payload with all controls wired
                    const payload = buildCaptionPayload(text, captionStyle);
                    
                    // Generate caption PNG with new payload
                    await generateCaptionPreview(payload);
                    const result = getLastCaptionPNG();
                    captionOverlayState = result;
                    
                    console.log('[apply-font] Caption style applied:', {
                        fontFamily: payload.fontFamily,
                        weight: payload.weight,
                        fontPx: payload.fontPx,
                        opacity: payload.opacity,
                        placement: payload.placement
                    });
                    
                    console.log('[caption-overlay] meta:', {
                        fontPx: result?.meta?.fontPx,
                        lineSpacing: result?.meta?.lineSpacing,
                        yPct: result?.meta?.yPct,
                        placement: result?.meta?.placement,
                        fontFamilyUsed: result?.meta?.fontFamilyUsed,
                        wPx: result?.meta?.wPx,
                        hPx: result?.meta?.hPx
                    });
                    
                    console.log('[caption-overlay] PNG preview generated:', result);
                    
                    // Calculate preview scaling using geometry helper
                    const previewContainer = document.getElementById('live-preview-container');
                    const previewCanvas = document.getElementById('live-preview-canvas');
                    const geometry = getPreviewGeometry(previewCanvas);
                    
                    // Debug logging for scaling
                    console.debug('[preview-scaling]', {
                        cssW: geometry.cssW,
                        cssH: geometry.cssH,
                        backingW: geometry.backingW,
                        backingH: geometry.backingH,
                        dpr: geometry.dpr,
                        scaleX: geometry.scaleX,
                        scaleY: geometry.scaleY,
                        ovW: result.meta?.wPx || 1080,
                        ovH: result.meta?.hPx || 1920,
                        placement: captionStyle.placement,
                        yPct: result.meta?.yPct,
                        fontPx: result.meta?.fontPx
                    });
                    
                    // If overlay mode is inactive, render legacy PNG overlay image
                    try {
                        if (!useOverlayMode) {
                            createCaptionOverlay(result, overlay, { 
                                previewW: geometry.cssW, 
                                previewH: geometry.cssH,
                                placement: captionStyle.placement
                            });
                        }
                    } catch {}
                    
                    // Debug logging
                    console.log('[preview-scaling]', { 
                        previewW: geometry.cssW, 
                        previewH: geometry.cssH 
                    });
                    
                    console.log('[caption-overlay] PNG overlay created successfully');
                    
                    // Log font fallback info if available
                    if (result.meta?.fontFamilyUsed) {
                        console.log('[caption-overlay] Font used:', result.meta.fontFamilyUsed);
                    }
                    
                } catch (error) {
                    console.error('[caption-overlay] Failed to generate PNG:', error);
                    console.error('[caption-overlay] Error details:', error.message);
                    
                    // TASK 7: Disable HTML fallback to prevent mega-sized text issues
                    // The fallback was causing the "yo" situation mentioned in the task
                    console.log('[caption-overlay] PNG generation failed, not using HTML fallback');
                    overlay.innerHTML = ''; // Clear overlay instead of showing fallback text
                }
            }, 300); // 300ms debounce
        }
        
        // New draggable overlay system functions
        async function initOverlaySystem() {
            if (overlaySystemInitialized) return;
            
            try {
                const { initCaptionOverlay, getCaptionMeta, applyCaptionMeta, setQuote, ensureOverlayTopAndVisible, bindCaptionDrag } = await import('./js/caption-overlay.js');
                
                // Initialize the overlay system
                initCaptionOverlay({ stageSel: '#stage', mediaSel: '#previewMedia' });
                
                // Set default caption box geometry if not already set
                if (!window.__overlayMeta || !window.__overlayMeta.wPct) {
                    const stage = document.querySelector('#stage');
                    const w = stage?.clientWidth || 360;
                    const h = stage?.clientHeight || 640;
                    
                    // Default box ~88% width, readable font, near top (SSOT: decimal fractions 0-1)
                    const defaultMeta = {
                        text: (currentQuote?.text || '').trim(),
                        xPct: 0.04,              // 4% left margin (decimal)
                        yPct: 0.10,              // 10% from top (decimal)
                        wPct: 0.88,              // 88% of stage width (decimal)
                        fontFamily: 'Inter, system-ui, sans-serif',
                        weightCss: '700',
                        fontPx: Math.max(28, Math.min(96, Math.round(h * 0.08))),
                        color: '#FFFFFF',
                        opacity: 1,
                        textAlign: 'center',
                        paddingPx: 12,
                    };
                    
                    try {
                        applyCaptionMeta(defaultMeta);
                        window.__overlayMeta = { ...defaultMeta, ...getCaptionMeta() };
                        console.log('[overlay-default] applied:', { wPct: defaultMeta.wPct, xPct: defaultMeta.xPct, yPct: defaultMeta.yPct, fontPx: defaultMeta.fontPx });
                    } catch (e) {
                        console.warn('[overlay-system] Failed to apply default meta:', e);
                    }
                }
                
                try { ensureOverlayTopAndVisible('#stage'); } catch {}
                
                // Set up the preview media source - wait for canvas to be ready
                const setupCanvasBackground = () => {
                    const previewMedia = document.getElementById('previewMedia');
                    const canvas = document.getElementById('live-preview-canvas');
                    
                    if (previewMedia && canvas && canvas.width > 0 && canvas.height > 0) {
                        // Convert canvas to image for the overlay system
                        const dataUrl = canvas.toDataURL('image/png');
                        previewMedia.src = dataUrl;
                        console.log('[overlay-system] Canvas background set');
                        return true;
                    }
                    return false;
                };
                
                // Try to set canvas background immediately
                if (!setupCanvasBackground()) {
                    // If canvas not ready, wait for it
                    const checkCanvas = () => {
                        if (setupCanvasBackground()) {
                            console.log('[overlay-system] Canvas background set after wait');
                            try { ensureOverlayTopAndVisible('#stage'); } catch {}
                        } else {
                            // Retry in 100ms
                            setTimeout(checkCanvas, 100);
                        }
                    };
                    checkCanvas();
                }
                
                // Set initial quote if available
                if (currentQuote?.text) {
                    setQuote(currentQuote.text);
                    try { ensureOverlayTopAndVisible('#stage'); } catch {}
                }
                
                overlaySystemInitialized = true;
                console.log('[overlay-system] Initialized draggable overlay');
                
                // Mark preview as unsaved when caption text changes (SSOT workflow)
                try {
                    const captionContent = document.querySelector('.caption-box .content');
                    if (captionContent) {
                        // Debounce the reset to avoid triggering on every keystroke
                        let resetDebounceTimer = null;
                        captionContent.addEventListener('input', () => {
                            clearTimeout(resetDebounceTimer);
                            resetDebounceTimer = setTimeout(() => {
                                // Only reset if preview was previously saved
                                if (window._previewSavedForCurrentText) {
                                    resetPreviewSavedState();
                                }
                            }, 500); // Wait 500ms after user stops typing
                        });
                        console.log('[overlay-system] Added caption change listener for preview state');
                    }
                    
                    // Also listen to quote edit textarea for unsaved changes
                    const quoteEdit = document.getElementById('quote-edit');
                    if (quoteEdit) {
                        let resetDebounceTimer2 = null;
                        quoteEdit.addEventListener('input', () => {
                            clearTimeout(resetDebounceTimer2);
                            resetDebounceTimer2 = setTimeout(() => {
                                // Only reset if preview was previously saved
                                if (window._previewSavedForCurrentText) {
                                    resetPreviewSavedState();
                                }
                            }, 500);
                        });
                        console.log('[overlay-system] Added quote edit change listener for preview state');
                    }
                } catch (e) {
                    console.warn('[overlay-system] Failed to add change listeners:', e);
                }
            } catch (error) {
                console.error('[overlay-system] Failed to initialize:', error);
            }
        }
        
        async function toggleOverlayMode() {
            const toggle = document.getElementById('overlay-mode-toggle');
            const stage = document.getElementById('stage');
            const legacyOverlay = document.getElementById('caption-overlay');
            const overlayControls = document.getElementById('overlay-controls');
            
            useOverlayMode = toggle.checked;
            
            if (useOverlayMode) {
                // Show new overlay system
                stage.style.display = 'block';
                legacyOverlay.style.display = 'none';
                try { overlayControls.style.display = 'block'; } catch {}
                
                // Initialize overlay system if not already done
                if (!overlaySystemInitialized) {
                    await initOverlaySystem();
                }
                
                // Wait a moment for the overlay to be ready
                setTimeout(async () => {
                    // Update overlay with current quote if available
                    if (currentQuote?.text) {
                        await updateOverlayCaption(currentQuote.text.trim(), true);
                    }
                }, 100);
            } else {
                // Show legacy overlay system
                stage.style.display = 'none';
                legacyOverlay.style.display = 'block';
                try { overlayControls.style.display = 'none'; } catch {}
            }
            
            console.log('[overlay-mode] Switched to:', useOverlayMode ? 'draggable overlay' : 'legacy overlay');
        }
        
        // New overlay-based caption update function
        async function updateOverlayCaption(text = '', show = true) {
            if (!useOverlayMode || !overlaySystemInitialized) return;
            
            try {
                const { setQuote, getCaptionMeta, applyCaptionMeta, ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                
                if (show && text?.trim()) {
                    setQuote(text);
                }
                
                // Update canvas background if needed
                updateOverlayCanvasBackground();
                
                console.log('[overlay-caption] Updated overlay with text:', text?.substring(0, 50));
                try { ensureOverlayTopAndVisible('#stage'); } catch {}
            } catch (error) {
                console.error('[overlay-caption] Failed to update overlay:', error);
            }
        }
        
        // Update overlay canvas background
        async function updateOverlayCanvasBackground() {
            if (!useOverlayMode || !overlaySystemInitialized) return;
            
            try {
                const previewMedia = document.getElementById('previewMedia');
                const canvas = document.getElementById('live-preview-canvas');
                
                if (previewMedia && canvas && canvas.width > 0 && canvas.height > 0) {
                    const dataUrl = canvas.toDataURL('image/png');
                    previewMedia.src = dataUrl;
                    console.log('[overlay-canvas] Background updated');
                    try { const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js'); ensureOverlayTopAndVisible('#stage'); } catch {}
                }
            } catch (error) {
                console.warn('[overlay-canvas] Failed to update background:', error);
            }
        }
        
        // Convert overlay meta to SSOT payload
        function overlayMetaToSSOT(meta) {
            const overlayV2 = (window.__overlayV2 === true);
            const xPct = Number.isFinite(meta?.xPct) ? Number(meta.xPct) : 0.5;
            const yPct = Number.isFinite(meta?.yPct) ? Number(meta.yPct) : 0.5;
            const wPct = Number.isFinite(meta?.wPct) ? Number(meta.wPct) : 0.8;
            const sizePx = Math.max(32, Math.min(120, Number(meta.fontPx || 48)));
            const lineSpacingPx = Math.round(sizePx * (Number(meta.lineHeight || 1.15) - 1) * 0.3);
            const base = {
                text: String(meta.text || ''),
                placement: 'custom',
                xPct, yPct, wPct,
                sizePx, lineSpacingPx,
                fontFamily: meta.fontFamily || 'DejaVuSans',
                weightCss: String(meta.weightCss || 'bold'),
                color: meta.color || '#FFFFFF',
                opacity: Number.isFinite(meta.opacity) ? Number(meta.opacity) : 0.85,
            };
            return overlayV2 ? { ...base, v2: true } : base;
        }
        
        // Preview function for overlay system
        async function previewOverlayCaption() {
            if (!useOverlayMode || !overlaySystemInitialized) {
                console.warn('[overlay-preview] Overlay mode not ready:', { useOverlayMode, overlaySystemInitialized });
                return;
            }
            
            try {
                const { getCaptionMeta } = await import('./js/caption-overlay.js');
                const meta = getCaptionMeta();
                console.log('[overlay-preview] Got overlay meta:', meta);
                
                const payload = overlayMetaToSSOT(meta);
                console.log('[overlay-preview] Sending payload:', payload);
                const { apiFetch } = await import('./api.mjs');
                const result = await apiFetch('/caption/preview', { method: 'POST', body: payload });
                console.log('[overlay-preview] Server response:', result);
                
                // Store overlay preview meta to window.__lastCaptionOverlay for SSOT render payload
                if (result?.ok && result?.data) {
                    window.__lastCaptionOverlay = {
                        dataUrl: result.data.imageUrl,
                        width: result.data.wPx || 1080,
                        height: result.data.hPx || 1920,
                        meta: result.data.meta || {}
                    };
                    console.log('[overlay-preview] Stored server meta:', window.__lastCaptionOverlay.meta);
                }
                
                const previewMedia = document.getElementById('previewMedia');
                if (previewMedia && (result?.previewUrl || result?.data?.imageUrl)) {
                    previewMedia.src = result.previewUrl || result.data.imageUrl;
                    console.log('[overlay-preview] Preview image set');
                }
                
                console.log('[overlay-preview] Preview generated successfully');
            } catch (error) {
                console.error('[overlay-preview] Failed:', error);
                // Do not fall back to legacy while overlay mode is ON (keeps SSOT)
            }
        }
        
        // Render function for overlay system
        async function renderOverlayCaption() {
            if (!useOverlayMode || !overlaySystemInitialized) return;
            
            try {
                const { getCaptionMeta } = await import('./js/caption-overlay.js');
                const meta = getCaptionMeta();
                const payload = overlayMetaToSSOT(meta);
                
                const res = await fetch('/api/caption/render', {
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'}, 
                    body: JSON.stringify(payload)
                });
                
                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.detail || 'Render failed');
                }
                
                const { jobId, outputUrl } = await res.json();
                console.log('[overlay-render] Render job created:', jobId);
                
                // Handle job creation / redirect / poll as you already do
                // This would integrate with your existing render pipeline
                
            } catch (error) {
                console.error('[overlay-render] Failed:', error);
            }
        }
        
        // Regen helpers: only decrement on LLM actions
        window.VAI = window.VAI || {};
        VAI.state = VAI.state || { regensLeft: 10 };
        (function initRegens(){
            const info = document.getElementById('regen-info');
            if (!info) return;
            const m = String(info.textContent||'').match(/(\d+)/);
            const initial = m ? parseInt(m[1],10) : 10;
            if (!Number.isFinite(VAI.state.regensLeft)) VAI.state.regensLeft = initial;
            info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        })();
        function setRegensLeft(n){
            VAI.state.regensLeft = Math.max(0, Number(n||0));
            const info = document.getElementById('regen-info');
            if (info) info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        }
        function decRegens(){
            setRegensLeft((VAI.state.regensLeft|0) - 1);
        }
        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function setLoading(buttonId, loading) {
            const button = document.getElementById(buttonId);
            button.disabled = loading;
            button.textContent = loading ? 'Loading...' : button.textContent.replace('Loading...', '');
        }

        // Load credits using existing system
        async function refreshCredits(force = true, retries = 1) {
            if (!window.auth?.currentUser) { 
                updateCreditUI(0); 
                return; 
            }
            try {
                // Use the apiFetch from the imported module
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch("/credits", { method: "GET" });
                const credits = Number(data?.credits ?? 0);
                updateCreditUI(Number.isNaN(credits) ? 0 : credits);
            } catch (err) {
                if (retries > 0) return refreshCredits(false, retries - 1);
                console.warn("Credits fetch failed:", err);
            }
        }

        function updateCreditUI(credits) {
            currentCredits = typeof credits === "number" ? credits : 0;
            const creditDisplay = document.getElementById('credit-display');
            const creditCount = document.getElementById('credit-count');
            if (creditDisplay) creditDisplay.classList.remove("hidden");
            if (creditCount) creditCount.textContent = String(currentCredits);
        }

        // Quote generation
        async function generateQuote() {
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to generate quotes');
                return;
            }
            
            const text = document.getElementById('quote-text').value;
            const tone = document.getElementById('quote-tone').value;
            
            if (!text.trim()) return;
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/generate-quote', {
                    method: 'POST',
                    body: {
                        text,
                        tone: tone === 'default' ? undefined : tone,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    await displayQuote(currentQuote, { skipPreview: true }); // keep textarea visible, skip preview update
                    decRegens();
                    
                    // Preview update removed - will only happen on Save
                } else {
                    showError('quote-error', data.reason || 'Failed to generate quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        // Expose to window scope for ui-actions.js
        window.generateQuote = generateQuote;

        async function displayQuote(quote, options = {}) {
            document.getElementById('quote-text-display').textContent = quote.text;
            const editEl = document.getElementById('quote-edit');
            editEl.value = quote.text;
            // Always keep the inlaid editor visible
            document.getElementById('quote-text-display').classList.add('hidden');
            editEl.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            
            // Update char counter from textarea content
            try {
              const cc = document.getElementById('quote-char-count');
              if (cc) cc.textContent = `${Math.min(200, (editEl.value||'').length)}/200`;
            } catch {}
            document.getElementById('quote-author').textContent = quote.author ? `‚Äî ${quote.author}` : '';
            document.getElementById('quote-author').classList.toggle('hidden', !quote.author);
            document.getElementById('quote-tone-tag').textContent = quote.toneTag ? `Tone: ${quote.toneTag}` : '';
            document.getElementById('quote-tone-tag').classList.toggle('hidden', !quote.toneTag);
            document.getElementById('quote-result').classList.remove('hidden');
            // Always expose LLM iterate buttons when a quote is present
            const remix = document.getElementById('remix-buttons');
            if (remix) remix.classList.remove('hidden');
            updateRenderPreview();
            
            // Preview is handled by updateRenderPreview() which now shows container even without asset
        }

        // Asset loading with pagination and caching
        async function loadAssets(page = 1) {
            if (currentAssetType === 'ai') return;
            if (!window.auth?.currentUser) {
                showError('asset-error', 'Please log in to load assets');
                return;
            }
            
            setLoading('search-assets-btn', true);
            hideError('asset-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const perPage = 12; // fuller grid per request
                const query = document.getElementById('asset-query').value;
                const cacheKey = `${currentAssetType}-${query}-${page}`;
                
                console.log('[assets] loadAssets called:', { type: currentAssetType, query, page });
                
                // Check cache first
                if (assetCache.has(cacheKey)) {
                    const cachedData = assetCache.get(cacheKey);
                    displayAssets(cachedData.items);
                    hasMoreAssets = cachedData.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                    setLoading('search-assets-btn', false);
                    console.log('[assets] Loaded from cache:', cacheKey);
                    return;
                }
                
                const data = await apiFetch('/assets/options', {
                    method: 'POST',
                    body: {
                        type: currentAssetType,
                        query,
                        page,
                        perPage
                    }
                });
                
                if (data.ok) {
                    console.log('[assets] Response received:', { 
                        meta: data.data.meta, 
                        count: data.data.items?.length 
                    });
                    
                    // Cache the results
                    assetCache.set(cacheKey, {
                        items: data.data.items,
                        nextPage: data.data.nextPage
                    });
                    
                    displayAssets(data.data.items);
                    hasMoreAssets = data.data.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                } else {
                    showError('asset-error', data.reason || 'Failed to load assets');
                }
            } catch (error) {
                showError('asset-error', error.message || 'Network error');
            } finally {
                setLoading('search-assets-btn', false);
            }
        }

        // Expose to window scope for ui-actions.js
        window.loadAssets = loadAssets;

        function displayAssets(assets) {
            const grid = document.getElementById('asset-grid');
            grid.innerHTML = '';
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function appendAssets(assets) {
            const grid = document.getElementById('asset-grid');
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function createAssetElement(asset) {
            const div = document.createElement('div');
            div.className = `relative border-2 rounded overflow-hidden transition-colors group ${
                selectedAsset?.id === asset.id ? 'border-blue-500' : 'border-gray-700'
            }`;
            
            let media;
            if (asset.provider === 'ai' || asset.type === 'ai-generated') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
            } else if (currentAssetType === 'images') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
            } else {
                media = `<video src="${asset.fileUrl}" class="w-full h-32 object-cover" muted playsinline preload="metadata" onerror="this.style.display='none'"></video>`;
            }
            
            const attribution = asset.provider === 'ai' 
                ? '<div class="text-purple-400 truncate">AI Generated</div>'
                : asset.photographer 
                    ? `<div class="text-gray-400 truncate">by ${asset.photographer}</div>`
                    : '';
            
            div.innerHTML = `
                ${media}
                <div class="p-2 text-xs">
                    <div class="truncate">${asset.query}</div>
                    ${attribution}
                </div>
                <!-- Action Buttons Overlay -->
                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-all duration-200 flex items-end justify-center pb-2 opacity-0 group-hover:opacity-100">
                    <div class="flex gap-2">
                        <button 
                            class="use-asset-btn px-3 py-1 bg-blue-600 hover:bg-blue-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Use
                        </button>
                        <button 
                            class="remix-asset-btn px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Remix
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners for the buttons
            const useBtn = div.querySelector('.use-asset-btn');
            const remixBtn = div.querySelector('.remix-asset-btn');
            
            useBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                useAsset(asset);
            });
            
            remixBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                addToRemix(asset);
            });
            
            return div;
        }

        function selectAsset(asset) {
            selectedAsset = asset;
            // Re-render grid to update selection
            loadAssets(1);
            updateRenderPreview();
            updateRenderButtonState();
            
            // Trigger caption preview immediately after asset selection
            maybeGenerateCaptionPreview();
        }

        function updatePagination() {
            const container = document.getElementById('pagination-container');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const pageInfo = document.getElementById('page-info');
            
            if (currentAssetType === 'ai') {
                container.classList.add('hidden');
                return;
            }
            
            // Show pagination for non-AI asset types
            container.classList.remove('hidden');
            prevBtn.disabled = currentAssetPage <= 1;
            nextBtn.disabled = !hasMoreAssets;
            pageInfo.textContent = `Page ${currentAssetPage}`;
        }

        // Use asset function
        async function useAsset(asset) {
            selectedAsset = asset;
            
            // Initialize window.state if needed
            if (!window.state) window.state = {};
            window.state.selectedAsset = asset;
            
            // Special handling for Pexels assets - high-quality preview
            if (asset.provider === 'pexels' && asset.src) {
                // Ensure the asset has the photo data for later use
                selectedAsset.photo = asset.src;
                await onPexelsUse(asset.src);
            }
            
            updateRenderPreview();
            updateRenderButtonState();
            
            // Show media + caption immediately in overlay (seamless flow with sync guarantee)
            try {
                await ensureOverlayActive();
                
                // Update overlay background with new media (wait for completion)
                if (useOverlayMode && overlaySystemInitialized) {
                    await updateOverlayCanvasBackground();
                    
                    // Wait one frame to ensure canvas/media has painted
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    
                    const hasText = !!(currentQuote?.text || '').trim();
                    console.log('[overlay-media] bg updated; hasText:', hasText);
                }
                
                // If we have a saved quote, show it on the new media
                const txt = (currentQuote?.text || '').trim();
                if (txt && useOverlayMode && overlaySystemInitialized) {
                    await updateOverlayCaption(txt, true);
                    console.log('[useAsset] Updated overlay caption');
                }
                
                // Ensure overlay is visible on top (final positioning)
                try {
                    const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                    ensureOverlayTopAndVisible('#stage');
                } catch {}
            } catch (e) {
                console.warn('[useAsset] overlay update failed', e);
            }
            
            // Legacy flow fallback
            if (currentQuote && !useOverlayMode) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
            
            // Scroll to render section
            document.getElementById('render-preview').scrollIntoView({ behavior: 'smooth' });
        }

        // High-quality Pexels preview handler with race protection
        async function onPexelsUse(photo) {
            const reqId = ++_previewReqId;
            _currentPexelsPhoto = photo; // Track for resize re-rendering

            const canvas = document.getElementById('live-preview-canvas');
            const container = canvas.parentElement;
            const cssW = container.clientWidth;
            const cssH = Math.round(cssW * 16 / 9);

            _setupHiDPICanvas(canvas, cssW, cssH);

            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const previewUrl = _pexelsPreviewUrlFromPhoto(photo, cssW * dpr, cssH * dpr, 1.2);

            // Persist both URLs for later redraws (resize/caption)
            if (!window.state) window.state = {};
            window.state.selectedAsset = {
                ...(window.state.selectedAsset || {}),
                provider: 'pexels',
                id: photo?.id,
                thumbUrl: photo?.src?.medium,
                previewUrl
            };
            
            // Also update the global selectedAsset to keep them in sync
            selectedAsset.previewUrl = previewUrl;

            console.log('[pexels-use] previewUrl', previewUrl);
            await _drawBackground(window.state.selectedAsset.previewUrl, canvas, cssW, cssH, 'bg:pexels-use');

            // Add write-trap to detect accidental overwrites
            try {
                const sa = window.state.selectedAsset;
                let _pv = sa.previewUrl;
                Object.defineProperty(sa, 'previewUrl', {
                    get() { return _pv; },
                    set(v) {
                        if (!_isHiResPreviewUrl(v)) {
                            console.warn('[trap] previewUrl being set to NON-hires url:', v);
                        }
                        _pv = v;
                    }
                });
            } catch {}
        }

        // Add to remix function
        function addToRemix(asset) {
            if (remixAssets.length >= 2) {
                showError('asset-error', 'Maximum 2 remix references allowed');
                return;
            }
            
            if (remixAssets.find(a => a.id === asset.id)) {
                showError('asset-error', 'Asset already in remix references');
                return;
            }
            
            remixAssets.push(asset);
            updateRemixArea();
        }

        // Update remix area display
        function updateRemixArea() {
            const remixArea = document.getElementById('remix-area');
            const remixAssetsContainer = document.getElementById('remix-assets');
            
            if (remixAssets.length === 0) {
                remixArea.classList.add('hidden');
                return;
            }
            
            remixArea.classList.remove('hidden');
            remixAssetsContainer.innerHTML = '';
            
            remixAssets.slice(0,2).forEach((asset, index) => {
                const assetDiv = document.createElement('div');
                assetDiv.className = 'relative w-20 h-20 rounded overflow-hidden border border-gray-600';
                
                const media = asset.provider === 'ai' || asset.type === 'ai-generated'
                    ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`
                    : currentAssetType === 'images'
                        ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`
                        : `<video src="${asset.fileUrl}" class="w-full h-full object-cover" muted playsinline preload="metadata" onerror="this.style.display='none'"></video>`;
                
                assetDiv.innerHTML = `
                    ${media}
                    <button 
                        class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 hover:bg-red-500 text-white text-xs rounded-full flex items-center justify-center"
                        onclick="removeFromRemix(${index})"
                    >
                        √ó
                    </button>
                `;
                
                remixAssetsContainer.appendChild(assetDiv);
            });
        }

        // Remove from remix
        function removeFromRemix(index) {
            remixAssets.splice(index, 1);
            updateRemixArea();
        }

        // Handle file upload
        function handleFileUpload(files) {
            if (!files || !files[0]) return;
            const file = files[0];
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const uploadedAsset = {
                    id: `uploaded-${Date.now()}`,
                    fileUrl: e.target.result,
                    thumbUrl: e.target.result,
                    query: file.name,
                    provider: 'uploaded',
                    type: file.type.startsWith('video/') ? 'video' : 'image'
                };
                
                uploadedAssets.push(uploadedAsset);
                
                // Add to current grid
                const grid = document.getElementById('asset-grid');
                const assetElement = createAssetElement(uploadedAsset);
                grid.insertBefore(assetElement, grid.firstChild);
            };
            
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else if (file.type.startsWith('video/')) {
                reader.readAsDataURL(file);
            }
        }

        function updateRenderPreview() {
            const preview = document.getElementById('render-preview');
            const renderBtn = document.getElementById('render-btn');
            
            // Show preview container if we have any feature selected
            if (currentQuote || selectedAsset || currentVoiceId) {
                // Handle quote display
                if (currentQuote) {
                    document.getElementById('preview-quote').textContent = currentQuote.text;
                } else {
                    document.getElementById('preview-quote').textContent = 'Quote: None';
                }
                
                // Show asset info if available
                if (selectedAsset) {
                    document.getElementById('preview-asset').textContent = 
                        `Background: ${selectedAsset.provider === 'ai' ? 'AI Image' : selectedAsset.provider === 'uploaded' ? 'Uploaded' : `${currentAssetType} - ${selectedAsset.query}`}`;
                } else {
                    document.getElementById('preview-asset').textContent = 'Background: None (black)';
                }
                
                // Update caption style preview
                const font = document.getElementById('caption-font').value;
                const weight = document.getElementById('caption-weight').value;
                const size = window.getCaptionPx();
                const opacity = document.getElementById('caption-opacity').value;
                const placement = document.getElementById('caption-placement').value;
                const background = document.getElementById('caption-background').checked;
                
                document.getElementById('preview-caption-style').textContent = 
                    `Caption: ${font} ${weight}, ${size}px, ${opacity}% opacity, ${placement}${background ? ', with background' : ''}`;
                
                // Update voiceover preview
                const voiceId = document.getElementById('voiceover-voice').value;
                const selectedVoice = availableVoices.find(v => v.id === voiceId);
                const voiceName = selectedVoice ? selectedVoice.name : 'Not selected';
                const stability = document.getElementById('tts-stability').value;
                const similarity = document.getElementById('tts-similarity').value;
                const style = document.getElementById('tts-style').value;
                const speakerBoost = document.getElementById('tts-speaker-boost').checked;
                
                // Show normalized style value (0-1 range) in preview
                const normalizedStyle = (parseInt(style) / 100).toFixed(2);
                document.getElementById('preview-voiceover').textContent = `Voice: ${voiceName} (Stability: ${stability}, Similarity: ${similarity}, Style: ${normalizedStyle}, Boost: ${speakerBoost ? 'On' : 'Off'})`;
                
                preview.classList.remove('hidden');
                // Always show render button when we have any feature
                renderBtn.classList.remove('hidden');
                // Always show preview container when we have any feature
                document.getElementById('live-preview-container').classList.remove('opacity-0');
                
                // Wait a frame for the container to be visible, then update preview
                requestAnimationFrame(() => {
                    // Ensure proper sequence: Container ‚Üí Canvas ‚Üí Preview ‚Üí Caption
                    console.log('[preview-init] Triggering preview sequence...');
                    if (selectedAsset) {
                        updateLivePreview();
                    }
                    if (currentQuote) {
                        // Small delay to ensure preview is rendered before caption
                        setTimeout(() => {
                            updateCaptionOverlay(currentQuote.text.trim(), true);
                        }, 100);
                    }
                });
            } else {
                // No features selected - hide preview but keep button visible
                preview.classList.add('hidden');
                renderBtn.classList.remove('hidden'); // Keep button visible
                document.getElementById('live-preview-container').classList.add('opacity-0');
            }
            updateRenderButtonState();
        }

        // Update caption style values
        function updateCaptionStyleValues() {
            const px = window.getCaptionPx();
            document.getElementById('size-value').textContent = `${px}px`;
            document.getElementById('opacity-value').textContent = document.getElementById('caption-opacity').value + '%';
            document.getElementById('bg-opacity-value').textContent = document.getElementById('caption-bg-opacity').value + '%';
            updateRenderPreview();
            updateLivePreview();
            try { updateCaptionOverlay((currentQuote?.text||'').trim(), true); } catch {}
        }

        // Feature flag for preview fixes
        window.__PREVIEW_FIX__ = true;
        
        // Canvas ready state tracking
        let canvasReadyState = { ready: false, observer: null, intersectionObserver: null };
        
        // Fix B: Set the canvas backing store AFTER CSS size exists
        function sizeCanvasToCSS(canvas) {
            const wCSS = canvas.clientWidth;
            const hCSS = canvas.clientHeight;
            
            console.log('[preview-init] Canvas sizing check:', {
                cssW: wCSS, cssH: hCSS, dpr: window.devicePixelRatio,
                canvasw: canvas.width, canvasH: canvas.height,
                rectWidth: canvas.getBoundingClientRect().width, 
                rectHeight: canvas.getBoundingClientRect().height
            });
            
            if (wCSS === 0 || hCSS === 0) {
                console.log('[preview-init] Canvas sized immediately:', {
                    cssW: wCSS, cssH: hCSS, dpr: window.devicePixelRatio,
                    canvasw: canvas.width, canvasH: canvas.height
                });
                return false;
            }

            const dpr = window.devicePixelRatio || 1;
            const wBS = Math.round(wCSS * dpr);
            const hBS = Math.round(hCSS * dpr);

            if (canvas.width !== wBS || canvas.height !== hBS) {
                canvas.width = wBS;
                canvas.height = hBS;
                const ctx = canvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            
            canvasReadyState.ready = true;
            return true;
        }
        
        // IntersectionObserver + ResizeObserver for robust canvas ready detection
        function setupCanvasObserver() {
            if (!window.__PREVIEW_FIX__) return;
            
            const container = document.getElementById('live-preview-container');
            const canvas = document.getElementById('live-preview-canvas');
            if (!container || !canvas) return;
            
            // Clean up existing observers
            if (canvasReadyState.observer) {
                canvasReadyState.observer.disconnect();
            }
            if (canvasReadyState.intersectionObserver) {
                canvasReadyState.intersectionObserver.disconnect();
            }
            
            // Use IntersectionObserver to detect when container becomes visible
            canvasReadyState.intersectionObserver = new IntersectionObserver(entries => {
                for (const entry of entries) {
                    if (entry.isIntersecting) {
                        console.log('[canvas-ready] Container became visible, checking canvas');
                        if (sizeCanvasToCSS(canvas)) {
                            console.log('[canvas-ready] Canvas ready, triggering render');
                            scheduleRender();
                        }
                    }
                }
            }, { threshold: 0.1 });
            
            // Use ResizeObserver for dimension changes
            canvasReadyState.observer = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const { width, height } = entry.contentRect;
                    if (width > 0 && height > 0) {
                        console.log('[canvas-ready] Container resized, checking canvas:', { width, height });
                        if (sizeCanvasToCSS(canvas)) {
                            console.log('[canvas-ready] Canvas ready, triggering render');
                            scheduleRender();
                        }
                    }
                }
            });
            
            // Observe both intersection and resize
            canvasReadyState.intersectionObserver.observe(container);
            canvasReadyState.observer.observe(container);
        }
        
        // Idempotent render scheduler with RAF cancellation
        let renderScheduled = false;
        let renderRafId = null;
        function scheduleRender() {
            if (!window.__PREVIEW_FIX__) return;
            if (renderScheduled) return;
            
            // Cancel any pending RAF to prevent stacking
            if (renderRafId !== null) {
                cancelAnimationFrame(renderRafId);
                renderRafId = null;
            }
            
            renderScheduled = true;
            renderRafId = requestAnimationFrame(() => {
                renderScheduled = false;
                renderRafId = null;
                if (canvasReadyState.ready && currentQuote?.text && selectedAsset) {
                    console.log('[canvas-ready] Executing scheduled render');
                    updateLivePreview();
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            });
        }
        
        // Font parity map for client-side consistency
        const FONT_MAP = { 
            DejaVuSans: 'DejaVu Sans', 
            DejaVuSerif: 'DejaVu Serif' 
        };
        
        // Helper function to derive yPct from placement
        function yPctFromPlacement(placement) {
            switch (placement) {
                case 'top': return 0.15;
                case 'center': return 0.50;
                case 'bottom': return 0.80; // Reduced from 0.90 to prevent cutoff at bottom
                default: return 0.50;
            }
        }
        
        // Helper function for precise float conversion
        function preciseFloat0to1(value) {
            // Fix: If value is already 0-1 range, don't divide by 100
            const numValue = Number(value);
            if (numValue <= 1) {
                return Math.max(0, Math.min(1, numValue));
            }
            // If value is 0-100 range, convert to 0-1
            return Math.max(0, Math.min(1, numValue / 100));
        }
        
        // Build proper payload with all controls wired
        function buildCaptionPayload(text, captionStyle) {
            // SSOT: Check if overlay mode is enabled and use overlay metadata
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const { getCaptionMeta } = window;
                    if (typeof getCaptionMeta === 'function') {
                        const overlayMeta = getCaptionMeta();
                        
                        // Validate overlay meta has required fields
                        if (overlayMeta && typeof overlayMeta.yPct === 'number' && overlayMeta.text) {
                            console.log('[overlay-payload] Using overlay metadata:', overlayMeta);
                            
                            // Convert overlay meta to SSOT payload format
                            return {
                                text: overlayMeta.text || text,
                                yPct: overlayMeta.yPct,
                                xPct: overlayMeta.xPct,
                                wPct: overlayMeta.wPct,
                                fontFamily: overlayMeta.fontFamily,
                                weightCss: overlayMeta.weightCss,
                                sizePx: overlayMeta.fontPx,
                                color: overlayMeta.color,
                                opacity: overlayMeta.opacity,
                                textAlign: overlayMeta.textAlign || 'center',
                                padding: overlayMeta.paddingPx ?? 12,
                                placement: 'custom',      // SSOT: signals server to use manual placement
                                maxWidthPct: Math.round((meta.wPct || 0.8) * 100),
                                showBox: meta.showBox ?? true,
                                boxColor: 'transparent',
                                responsiveText: meta.responsiveText ?? true
                            };
                        } else {
                            console.warn('[overlay-payload] Overlay meta incomplete, falling back to legacy');
                        }
                    }
                } catch (error) {
                    console.warn('[overlay-payload] Failed to get overlay metadata, falling back to legacy:', error);
                }
            }
            
            // Legacy payload format (existing logic)
            const placement = captionStyle.placement || 'center';
            const yPct = captionStyle.yPct ?? yPctFromPlacement(placement);
            const opacity = preciseFloat0to1(captionStyle.opacity || 80);
            
            const payload = {
                text,
                fontFamily: captionStyle.fontFamily || 'DejaVuSans',
                weight: captionStyle.weightCss || captionStyle.weight || 'normal', // Fix: Use weightCss from captionStyle
                fontPx: captionStyle.fontPx || 48,
                opacity,
                placement,
                yPct
            };
            
            console.log('[caption-overlay] payload:', {
                weight: payload.weight,
                opacity: payload.opacity,
                placement: payload.placement,
                yPct: payload.yPct,
                fontPx: payload.fontPx
            });
            
            return payload;
        }

        // Fix C: Robust "wait for ready" without infinite loop
        async function waitForCanvasReady(canvas, { timeoutMs = 2000 } = {}) {
            const start = performance.now();

            return new Promise((resolve, reject) => {
                const check = () => {
                    const connected = canvas?.isConnected;
                    const rect = canvas?.getBoundingClientRect();
                    const container = document.getElementById('live-preview-container');
                    const containerVisible = container && !container.classList.contains('hidden');
                    const ready = connected && rect && rect.width > 0 && rect.height > 0 && containerVisible;

                    if (ready && sizeCanvasToCSS(canvas)) {
                        resolve(true);
                        return;
                    }
                    if (performance.now() - start > timeoutMs) {
                        reject(new Error('Canvas not ready: no size within timeout'));
                        return;
                    }
                    requestAnimationFrame(check);
                };
                check();
            });
        }

        // Fix E: Initialize preview system with immediate canvas sizing
        async function initPreviewSystem() {
            const canvas = document.getElementById('live-preview-canvas');
            const container = document.getElementById('live-preview-container');
            
            if (!canvas || !container) {
                console.warn('[preview-init] Canvas or container not found');
                return;
            }
            
            // Size canvas immediately from wrapper dimensions
            const wrapper = canvas.parentElement;
            const cssW = wrapper ? wrapper.clientWidth : 360; // fallback 360
            const cssH = wrapper ? wrapper.clientHeight : 640; // fallback 640
            
            // Set canvas.style.width/height in CSS pixels
            canvas.style.width = `${cssW}px`;
            canvas.style.height = `${cssH}px`;
            
            // Set canvas.width/height in device pixels (multiply by devicePixelRatio)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.round(cssW * dpr);
            canvas.height = Math.round(cssH * dpr);
            
            console.log('[preview-init] Canvas sized immediately:', { cssW, cssH, dpr, canvasW: canvas.width, canvasH: canvas.height });
            
            // Trigger initial preview if we have content
            if (currentQuote?.text && selectedAsset) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
        }

        // Manual trigger function for debugging
        function forcePreviewUpdate() {
            console.log('[preview-debug] Forcing preview update');
            if (currentQuote && selectedAsset) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            } else {
                console.log('[preview-debug] Missing quote or asset:', { 
                    hasQuote: !!currentQuote, 
                    hasAsset: !!selectedAsset 
                });
            }
        }

        // Make it globally available for debugging
        window.forcePreviewUpdate = forcePreviewUpdate;

        // Initialize caption size UI (safe DOM ready wrapper)
        function initCaptionSizeUI(){
          const el = document.getElementById('caption-size');
          const label = document.getElementById('size-value');
          if (!el || !label) return;
          
          function update() {
            try {
              const px = getCaptionPx(); // use the hoisted function
            label.textContent = `${px}px`;
              // refresh preview overlay without blocking rest of UI
              queueCaptionOverlayRefresh();
              // also update other caption style values
              if (typeof updateCaptionStyleValues === 'function') {
                updateCaptionStyleValues();
              }
            } catch (err) {
              console.error('[caption-size] update failed:', err);
            }
          }

          el.addEventListener('input', update);
          update(); // initial paint
        }
        
        // --- robust page bootstrap (run after DOM is ready)
        document.addEventListener('DOMContentLoaded', async () => {
          // Wrap each init so one failure doesn't stop the others
          const safe = (label, fn) => { try { fn && fn(); } catch (e) { console.error(`[init] ${label} failed`, e); } };

          // PRIORITY: Initialize assets after auth is ready
          (async () => {
            try {
              console.log('[init] Starting asset browser initialization...');
              // Wait for auth to settle once, then decide what to do
              const ok = await ensureLoggedInOrWarn();
              // If logged in (or you want to allow anonymous browsing anyway), kick off first load
              if (ok) {
                const activeType = getActiveAssetType();   // 'images' | 'videos' | 'ai'
                const q = (document.getElementById('asset-query')?.value || 'nature').trim();
                const grid = document.getElementById(`${activeType}-grid`) ||
                             document.querySelector(`[data-grid="${activeType}"]`) ||
                             document.getElementById('asset-grid');
                
                console.log('[assets] Checking initial load:', { activeType, gridEmpty: grid?.childElementCount === 0, query: q });

            if (grid && grid.childElementCount === 0) {
                  console.log('[assets] Loading initial assets for', activeType);
              if (typeof loadAssets === 'function') {
                    currentAssetType = activeType; // Set the global state
                    await loadAssets(1); // Wait for assets to load
              } else {
                console.warn('[assets] loadAssets function not found');
              }
            }
              }
            } catch (e) {
              console.error('[init] Asset browser initialization failed:', e);
            }
          })();

          // Trigger caption preview if we have text and asset (legacy fallback only)
          safe('caption-preview-init', () => maybeGenerateCaptionPreview());

          // Default to overlay mode as soon as caption exists
          safe('overlay-default', () => {
            const hasCaption = !!(currentQuote?.text || document.getElementById('quote-text')?.value);
            if (hasCaption) ensureOverlayActive();
          });

          // SECONDARY: Initialize caption UI (non-blocking)
          safe('caption-size', () => (typeof initCaptionSizeUI === 'function') && initCaptionSizeUI());

          // Asset browser setup is now handled above in priority section
          // Tab switching is now handled by the delegated router in ui-actions.js
        });

        // Update render button state based on validation
        function updateRenderButtonState() {
            console.log('[render-validate] updateRenderButtonState called from:', new Error().stack?.split('\n')[2]?.trim() || 'unknown');
            
            const renderBtn = document.getElementById('render-btn');
            const hasValidAsset = selectedAsset && (selectedAsset.fileUrl || selectedAsset.url);
            const hasQuote = currentQuote;
            const hasVoiceover = !!currentVoiceId;
            const isLoggedIn = window.auth?.currentUser;
            
            console.log('[render-validate] Basic conditions:', {
                hasValidAsset,
                hasQuote,
                hasVoiceover,
                isLoggedIn: !!isLoggedIn,
                selectedAsset: selectedAsset?.url || selectedAsset?.fileUrl || 'none'
            });
            
            // NEW: Check if preview is saved AND current text matches saved text (SSOT workflow)
            let hasSavedPreview = false;
            
            // Debug: Log all validation conditions
            console.log('[render-validate] Checking preview state:', {
                hasGetSavedMeta: !!window.getSavedOverlayMeta,
                hasGetCaptionMeta: !!window.getCaptionMeta,
                flagSet: window._previewSavedForCurrentText,
                flagType: typeof window._previewSavedForCurrentText
            });
            
            if (window.getSavedOverlayMeta && window.getCaptionMeta && window._previewSavedForCurrentText) {
                console.log('[render-validate] All conditions met, checking meta...');
                
                const savedMeta = window.getSavedOverlayMeta();
                console.log('[render-validate] Saved meta exists:', !!savedMeta);
                
                if (savedMeta) {
                    try {
                        const currentMeta = window.getCaptionMeta();
                        console.log('[render-validate] Current meta exists:', !!currentMeta);
                        
                        // Normalize text for comparison (trim whitespace)
                        const savedText = (savedMeta.text || '').trim();
                        const currentText = (currentMeta.text || '').trim();
                        
                        console.log('[render-validate] Text comparison:', {
                            savedLength: savedText.length,
                            currentLength: currentText.length,
                            match: savedText === currentText,
                            saved: savedText.substring(0, 100),
                            current: currentText.substring(0, 100),
                            savedFull: savedText,
                            currentFull: currentText
                        });
                        
                        // Preview is valid if flag is set AND text matches
                        hasSavedPreview = (savedText === currentText);
                        
                        if (!hasSavedPreview && savedText && currentText && savedText !== currentText) {
                            console.log('[preview-state] Text mismatch detected - saved vs current differ');
                        }
                    } catch (err) {
                        console.warn('[preview-state] Error comparing caption text:', err);
                        hasSavedPreview = false;
                    }
                } else {
                    console.log('[render-validate] No saved meta found');
                }
            } else {
                console.log('[render-validate] Prerequisites not met:', {
                    getSavedOverlayMeta: !!window.getSavedOverlayMeta,
                    getCaptionMeta: !!window.getCaptionMeta,
                    previewSavedFlag: window._previewSavedForCurrentText
                });
            }
            
            console.log('[render-validate] Final hasSavedPreview:', hasSavedPreview);
            
            // Render requires: features + logged in + saved preview
            const canRender = (hasQuote || hasValidAsset || hasVoiceover) && isLoggedIn && hasSavedPreview;
            
            console.log('[render-validate] Final render decision:', {
                hasQuote,
                hasValidAsset,
                hasVoiceover,
                isLoggedIn: !!isLoggedIn,
                hasSavedPreview,
                canRender,
                buttonWillBeDisabled: !canRender
            });
            
            renderBtn.disabled = !canRender;
            
            if (!canRender) {
                let reason = '';
                if (!isLoggedIn) reason = 'Please log in';
                else if (!hasQuote && !hasValidAsset && !hasVoiceover) reason = 'Please add a quote, select media, or choose a voiceover';
                else if (!hasSavedPreview) reason = 'Save preview first';
                
                console.log('[render-validate] Button disabled, reason:', reason);
                renderBtn.title = reason;
            } else {
                console.log('[render-validate] Button ENABLED - ready to render!');
                renderBtn.title = 'Ready to render with saved preview';
            }
        }

        // Fix C: Live preview functionality without infinite retry
        function updateLivePreview() {
            if (!currentQuote || !selectedAsset) return;
            
            const container = document.getElementById('live-preview-container');
            const canvas = document.getElementById('live-preview-canvas');
            
            // Check if container is visible first - allow opacity-0 if container has dimensions
            if (!container || container.offsetParent === null) {
                console.log('[preview-scaling] Container not visible, skipping preview');
                return;
            }
            
            // If container has opacity-0 but has dimensions, proceed (will be made visible)
            if (container.classList.contains('opacity-0')) {
                console.log('[preview-scaling] Container has opacity-0 but has dimensions, proceeding...');
            }
            
            // Fix C: Check if canvas has real dimensions, with improved retry logic
            if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                console.log('[preview-scaling] Canvas not ready, scheduling retry...');
                // Force canvas sizing if container has dimensions
                if (container && container.clientWidth > 0 && container.clientHeight > 0) {
                    console.log('[preview-scaling] Container has dimensions, forcing canvas sizing...');
                    const wrapper = canvas.parentElement;
                    if (wrapper) {
                        canvas.style.width = `${wrapper.clientWidth}px`;
                        canvas.style.height = `${wrapper.clientHeight}px`;
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = Math.round(wrapper.clientWidth * dpr);
                        canvas.height = Math.round(wrapper.clientHeight * dpr);
                        console.log('[preview-scaling] Canvas force-sized:', { 
                            cssW: canvas.clientWidth, cssH: canvas.clientHeight,
                            canvasW: canvas.width, canvasH: canvas.height 
                        });
                    }
                }
                
                // Retry once on next frame
                requestAnimationFrame(() => {
                    const retryCanvas = document.getElementById('live-preview-canvas');
                    if (retryCanvas && retryCanvas.clientWidth > 0 && retryCanvas.clientHeight > 0) {
                        console.log('[preview-scaling] Canvas ready on retry, proceeding...');
                        updateLivePreview();
                    } else {
                        console.warn('[preview-scaling] Canvas still not ready after retry, skipping preview');
                    }
                });
                return;
            }
            
            container.classList.remove('opacity-0');
            
            // If a <video> is present for preview, hide overlay to avoid double text
            try {
                const ov = document.getElementById('caption-overlay');
                const hasVideo = !!document.querySelector('#live-preview-container video, #preview-holder video');
                if (ov) ov.style.display = hasVideo ? 'none' : 'block';
            } catch {}

            // 9:16 CSS sizing + HiDPI backing
            const { cssW, cssH } = layoutPreviewDims();
            const { ctx } = _setupHiDPICanvas(canvas, cssW, cssH);

            // Choose the background URL from whatever the app thinks it should be
            let url = selectedAsset?.previewUrl || selectedAsset?.url || selectedAsset?.thumbUrl || selectedAsset?.fileUrl;
            
            // >>> Insert this one line to force hi-res for Pexels:
            url = _ensureHiResPreviewUrl(url, canvas);

            // Load & draw the background
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.decoding = 'async';
            img.src = url;
            
            img.onload = () => {
                // COVER draw (no stretching)
                drawCover(ctx, img, cssW, cssH);
                
                // Debug
                window._currentPreviewUrl = url;
                _tapCanvas('bg:updateLivePreview');
            };
        }

        function drawCaptionOverlay(ctx, canvasWidth, canvasHeight) {
            if (!currentQuote) return;
            
            const font = document.getElementById('caption-font').value;
            const weight = document.getElementById('caption-weight').value;
            const size = window.getCaptionPx();
            const opacity = parseInt(document.getElementById('caption-opacity').value) / 100;
            const placement = document.getElementById('caption-placement').value;
            const showBackground = document.getElementById('caption-background').checked;
            const bgOpacity = parseInt(document.getElementById('caption-bg-opacity').value) / 100;
            
            // Set font - ensure weight mapping matches FFmpeg
            const cssWeight = (String(weight).toLowerCase() === 'bold' || Number(weight) >= 600) ? 'bold' : 'normal';
            ctx.font = `${cssWeight} ${size}px ${getFontFamily(font)}`;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add stroke to match FFmpeg rendering
            ctx.lineWidth = 3;
            ctx.strokeStyle = `rgba(0, 0, 0, 0.85)`;
            ctx.miterLimit = 2;
            
            // Calculate text position
            let y;
            const padding = 20;
            switch (placement) {
                case 'top':
                    y = padding + size / 2;
                    break;
                case 'middle':
                    y = canvasHeight / 2;
                    break;
                case 'bottom':
                    y = canvasHeight - padding - size / 2;
                    break;
            }
            
            // Wrap text if needed
            const maxWidth = canvasWidth - 40;
            const words = currentQuote.text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw background if enabled
            if (showBackground) {
                const lineHeight = size * 1.2;
                const totalHeight = lines.length * lineHeight;
                const bgY = y - totalHeight / 2;
                const bgHeight = totalHeight + padding;
                const bgWidth = canvasWidth - 20;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${bgOpacity})`;
                ctx.fillRect(10, bgY - padding / 2, bgWidth, bgHeight);
            }
            
            // Draw text lines
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            const lineHeight = size * 1.2;
            const startY = y - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                const x = canvasWidth / 2;
                const y = startY + index * lineHeight;
                
                // Draw stroke first (matches FFmpeg layering)
                ctx.strokeText(line, x, y);
                // Draw fill text on top
                ctx.fillText(line, x, y);
            });
        }

        function getFontFamily(font) {
            const fontMap = {
                'system': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif',
                'bold': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif', 
                'cinematic': 'DejaVu Sans Local, Georgia, serif',
                'minimal': 'DejaVu Sans Local, Helvetica, Arial, sans-serif'
            };
            return fontMap[font] || 'DejaVu Sans Local, system-ui, sans-serif';
        }

        // Compute preview-fitted lines using canvas metrics to mirror overlay width
        function computeFittedTextForPreview(text, { font, weight, sizePx, previewWidthPx }) {
            try {
                const raw = String(text || '').trim();
                if (!raw) {
                    return '';
                }
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const family = "DejaVu Sans Local";
                const weightCss = (String(weight).toLowerCase() === 'bold') ? '700' : '400';
                const size = Math.max(10, Number(sizePx) || 48);
                ctx.font = `${weightCss} ${size}px ${family}`;
                
                // Match overlay: max content width ‚âà 92% of preview width
                const maxWidth = Math.max(20, Math.round((Number(previewWidthPx)||360) * 0.92));
                
                const words = raw.split(/\s+/);
                const lines = [];
                let cur = '';
                for (const w of words) {
                    const next = cur ? cur + ' ' + w : w;
                    const width = ctx.measureText(next).width;
                    if (width > maxWidth && cur) { lines.push(cur); cur = w; } else { cur = next; }
                }
                if (cur) lines.push(cur);
                
                const result = lines.join('\n');
                return result;
            } catch (error) {
                return String(text || '').trim();
            }
        }

        // Voice loading and preview functions
        window.loadVoices = async function loadVoices() {
            try {
                // Wait for auth to be ready
                if (!window.auth?.currentUser) {
                    // Wait a bit for auth to initialize
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (!window.auth?.currentUser) {
                        showError('voice-preview-status', 'Please log in to load voices');
                        return;
                    }
                }

                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/voice/voices', {
                    method: 'GET'
                });

                if (data.success) {
                    availableVoices = data.data.voices;
                    populateVoiceSelect();
                    hideError('voice-preview-status');
                } else {
                    showError('voice-preview-status', data.error || 'Failed to load voices');
                }
            } catch (error) {
                console.error('Voice loading error:', error);
                showError('voice-preview-status', error.message || 'Network error');
            }
        }

        function populateVoiceSelect() {
            const select = document.getElementById('voiceover-voice');
            const retryBtn = document.getElementById('retry-voices-btn');
            select.innerHTML = '';
            
            if (availableVoices.length === 0) {
                select.innerHTML = '<option value="">No voices available</option>';
                retryBtn.title = 'Retry loading voices';
                return;
            }

            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = `${voice.name} - ${voice.description}`;
                select.appendChild(option);
            });

            // Enable preview button and hide retry button
            document.getElementById('preview-voice-btn').disabled = false;
            retryBtn.style.display = 'none';
        }

        async function previewVoice() {
            const voiceSelect = document.getElementById('voiceover-voice');
            const voiceId = voiceSelect.value;
            
            if (!voiceId || voiceId === '') {
                showError('voice-preview-status', 'Please select a voice');
                return;
            }

            const statusEl = document.getElementById('voice-preview-status');
            const previewBtn = document.getElementById('preview-voice-btn');
            const audioEl = document.getElementById('voice-preview-audio');

            statusEl.classList.remove('hidden');
            statusEl.textContent = 'Generating preview...';
            previewBtn.disabled = true;

            try {
                // Get TTS settings from UI and normalize to 0-1 range
                const stability = parseFloat(document.getElementById('tts-stability').value);
                const similarity_boost = parseFloat(document.getElementById('tts-similarity').value);
                const style = parseInt(document.getElementById('tts-style').value);
                const use_speaker_boost = document.getElementById('tts-speaker-boost').checked;
                
                // Normalize style from 0-100 to 0-1 range
                const normalizedStyle = Math.max(0, Math.min(1, style / 100));
                
                // Get caption text for preview if available, otherwise use default
                const captionText = document.getElementById('quote-text-display')?.textContent?.trim() || 
                                  document.getElementById('quote-edit')?.value?.trim() || 
                                  'Hello, this is a preview of my voice. How does it sound?';
                
                // Trim caption if too long (max ~240 chars for preview)
                const previewText = captionText.length > 240 ? captionText.substring(0, 240) + '...' : captionText;
                
                const ttsPayload = {
                    text: previewText,
                    voiceId,
                    modelId: 'eleven_multilingual_v2',
                    outputFormat: 'mp3_44100_128',
                    voiceSettings: {
                        stability,
                        similarity_boost,
                        style: normalizedStyle, // Now 0-1 range
                        use_speaker_boost
                    }
                };
                
                console.log('[tts.preview] POST /api/tts/preview', { voiceId, settings: ttsPayload.voiceSettings });
                
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/tts/preview', {
                    method: 'POST',
                    body: ttsPayload
                });
                
                console.log('[tts.preview] Response received:', { success: data.success, hasAudio: !!data.data?.audio });

                if (data.success) {
                    audioEl.src = data.data.audio;
                    audioEl.classList.remove('hidden');
                    statusEl.textContent = 'Preview ready - click play to listen';
                    
                    // Auto-play the preview
                    audioEl.play().catch(e => {
                        console.warn('[tts.preview] Autoplay prevented:', e.message);
                        statusEl.textContent = 'Preview ready - click play to listen';
                    });
                    console.log('[tts.preview] Playing preview audio');
                } else {
                    console.error('[tts.preview] Failed:', data.error || 'Unknown error');
                    showError('voice-preview-status', data.error || 'Failed to generate preview');
                }
            } catch (error) {
                console.error('[tts.preview] Error:', error);
                showError('voice-preview-status', error.message || 'Network error');
            } finally {
                previewBtn.disabled = false;
            }
        }

        // Helper function for better error messages
        function summarizeCreateError(err) {
            try {
                const msg = String(err?.message || err);
                const json = JSON.parse(msg.replace(/^Error:\s*/, ''));
                const fe = json?.detail?.fieldErrors || {};
                if (fe.caption?.length) return `Caption: ${fe.caption.join(', ')}`;
            } catch {}
            return null;
        }


        // Helper functions for payload construction
        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        
        // Drop undefined keys before fetch; keeps payload clean
        function stripUndefined(obj) {
            return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined));
        }

        // Reset preview saved state when caption text changes
        function resetPreviewSavedState() {
            console.log('[preview-state] Resetting preview saved state - caption changed');
            
            // Show Save Preview button
            const saveBtn = document.getElementById('save-preview-btn');
            if (saveBtn) {
                saveBtn.style.display = '';
                saveBtn.disabled = false;
            }
            
            // Hide Preview Saved status indicator
            const statusContainer = document.querySelector('#preview-status');
            if (statusContainer) {
                statusContainer.innerHTML = '';
                statusContainer.classList.add('hidden');
            }
            
            // Mark saved preview as stale (don't clear localStorage, just invalidate flag)
            window._previewSavedForCurrentText = false;
            
            // Update render button state (will disable it since preview is no longer saved)
            updateRenderButtonState();
        }

        // Save Preview function (SSOT workflow)
        async function savePreview() {
            if (!window.auth?.currentUser) {
                alert('Please log in to save preview');
                return;
            }

            const saveBtn = document.getElementById('save-preview-btn');
            const originalText = saveBtn.textContent;
            
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                // Get current caption meta from overlay system
                const meta = window.getCaptionMeta();
                
                if (!meta || !meta.text || !meta.text.trim()) {
                    alert('Please add caption text first');
                    return;
                }

                // Build preview payload (v2 format with percentages)
                const payload = {
                    v2: true,
                    text: meta.text,
                    xPct: meta.xPct,
                    yPct: meta.yPct,
                    wPct: meta.wPct,
                    hPct: meta.hPct,
                    fontPx: meta.fontPx,
                    lineHeight: typeof meta.lineHeight === 'string' ? parseFloat(meta.lineHeight) : (meta.lineHeight || 1.15),
                    lineSpacingPx: 0, // Will be computed by server
                    align: meta.textAlign || 'center',
                    color: meta.color || '#ffffff',
                    opacity: meta.opacity ?? 1.0,
                    fontFamily: meta.fontFamily || 'DejaVuSans',
                    weightCss: meta.weightCss || 'normal'
                };

                console.log('[savePreview] Sending payload:', payload);

                // Call preview API
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/caption/preview', {
                    method: 'POST',
                    body: payload
                });

                if (!data?.ok) {
                    throw new Error(data?.detail || data?.reason || 'Preview generation failed');
                }

                console.log('[savePreview] Preview saved successfully:', data.data.meta);

                // SSOT: Save the returned meta to localStorage for render workflow
                const normalizedMeta = {
                    text: data.data.meta?.text || meta.text,
                    xPct: data.data.meta?.xPct ?? meta.xPct,
                    yPct: data.data.meta?.yPct ?? meta.yPct,
                    wPct: data.data.meta?.wPct ?? meta.wPct,
                    hPct: data.data.meta?.hPct ?? meta.hPct,
                    fontPx: data.data.meta?.fontPx || meta.fontPx,
                    lineHeight: data.data.meta?.lineHeight ?? 1.15,
                    lineSpacingPx: data.data.meta?.lineSpacingPx ?? 0,
                    align: data.data.meta?.align || meta.textAlign || 'center',
                    color: data.data.meta?.color || meta.color || '#ffffff',
                    opacity: data.data.meta?.opacity ?? meta.opacity ?? 1.0,
                    fontFamily: data.data.meta?.fontFamily || meta.fontFamily || 'DejaVuSans',
                    weightCss: data.data.meta?.weightCss || meta.weightCss || 'normal',
                    // Server-computed positioning data (SSOT)
                    totalTextH: data.data.meta?.totalTextH,
                    splitLines: data.data.meta?.splitLines,
                    baselines: data.data.meta?.baselines,
                    internalPadding: data.data.meta?.internalPadding
                };

                // Store normalized overlay meta for render (SSOT)
                window._overlayMeta = normalizedMeta;
                window.lastCaptionPNG = {
                    dataUrl: data.data?.imageUrl,
                    width: data.data?.wPx || 1080,
                    height: data.data?.hPx || 1920,
                    meta: normalizedMeta
                };
                window.__lastCaptionOverlay = window.lastCaptionPNG;

                // Persist to localStorage for "Save Preview" workflow
                try {
                    localStorage.setItem('overlayMeta', JSON.stringify(normalizedMeta));
                    localStorage.setItem('overlayMetaTimestamp', Date.now().toString());
                    console.log('[savePreview] Saved overlay meta to localStorage');
                } catch (err) {
                    console.warn('[savePreview] Failed to save to localStorage:', err.message);
                }

                // Set flag indicating preview is saved for current text
                window._previewSavedForCurrentText = true;
                console.log('[preview-state] Preview saved successfully for current caption text');
                
                // Debug: Log what was saved
                console.log('[savePreview] Saved meta details:', {
                    text: normalizedMeta.text,
                    textLength: normalizedMeta.text?.length,
                    xPct: normalizedMeta.xPct,
                    yPct: normalizedMeta.yPct,
                    fontPx: normalizedMeta.fontPx
                });
                
                // Debug: Verify functions are available
                console.log('[savePreview] Function availability after save:', {
                    getSavedOverlayMeta: !!window.getSavedOverlayMeta,
                    getCaptionMeta: !!window.getCaptionMeta,
                    previewSavedFlag: window._previewSavedForCurrentText
                });

                // Hide Save Preview button and show success indicator
                saveBtn.style.display = 'none';
                
                // Show success indicator
                if (typeof window.showPreviewSavedIndicator === 'function') {
                    window.showPreviewSavedIndicator('#preview-status');
                } else {
                    // Fallback: directly update the preview status container
                    const container = document.querySelector('#preview-status');
                    if (container) {
                        container.innerHTML = `
                            <div class="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded text-sm">
                                <span>‚úì</span>
                                <span>Preview saved - ready to render</span>
                            </div>
                        `;
                        container.classList.remove('hidden');
                    }
                    console.warn('[savePreview] showPreviewSavedIndicator not available, using fallback');
                }
                
                // Enable render button (after localStorage save is complete)
                updateRenderButtonState();
                
                alert('Preview saved! You can now render the video.');

            } catch (error) {
                console.error('[savePreview] Error:', error);
                alert(`Save preview failed: ${error.message}`);
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = originalText;
            }
        }

        // Render short function
        async function renderShort() {
            // Require at least one feature (quote, asset, or voiceover)
            if (!currentQuote && !selectedAsset && !currentVoiceId) {
                alert('Please add a quote, select media, or choose a voiceover first');
                return;
            }

            if (!window.auth?.currentUser) {
                alert('Please log in to render shorts');
                return;
            }

            const renderBtn = document.getElementById('render-btn');
            const originalText = renderBtn.textContent;
            
            renderBtn.disabled = true;
            renderBtn.textContent = 'Rendering...';

            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Prepare the render payload with proper background structure (optional)
                let background = null;
                
                if (selectedAsset) {
                    const assetUrl = selectedAsset.fileUrl || selectedAsset.url;
                    
                    // Detect type from URL extension
                    const detectTypeFromUrl = (url) => {
                        if (!url) return 'image'; // Default fallback
                        
                        try {
                            // Handle URLs with query parameters or fragments
                            const cleanUrl = url.split('?')[0].split('#')[0];
                            const ext = cleanUrl.toLowerCase().split('.').pop();
                            
                            console.log(`[typeDetection] URL: ${url}`);
                            console.log(`[typeDetection] Clean URL: ${cleanUrl}`);
                            console.log(`[typeDetection] Extension: ${ext}`);
                            
                            if (['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', '3gp', 'flv'].includes(ext)) {
                                return 'video';
                            }
                            if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg', 'tiff'].includes(ext)) {
                                return 'image';
                            }
                            
                            // Default fallback
                            console.log(`[typeDetection] Unknown extension: ${ext}, defaulting to image`);
                            return 'image';
                        } catch (error) {
                            console.error(`[typeDetection] Error parsing URL: ${error.message}`);
                            return 'image'; // Safe fallback
                        }
                    };
                    
                    const detectedType = detectTypeFromUrl(assetUrl);
                    
                    console.log(`[render] Asset URL: ${assetUrl}`);
                    console.log(`[render] Detected type: ${detectedType}`);
                    
                    background = {
                        kind: selectedAsset.provider === 'ai' ? 'ai' : 
                              selectedAsset.provider === 'uploaded' ? 'upload' : 'stock',
                        type: detectedType, // Use detected type from URL
                        url: assetUrl, // Required URL
                        query: selectedAsset.query,
                        // Legacy fields for backward compatibility
                        imageUrl: selectedAsset.provider === 'uploaded' ? selectedAsset.fileUrl : undefined,
                        prompt: selectedAsset.provider === 'ai' ? selectedAsset.query : undefined
                    };
                } else {
                    console.log('[render] No asset selected - will render with black background');
                }

                // Get caption style settings
                const captionStyle = {
                    font: document.getElementById('caption-font').value,
                    weight: document.getElementById('caption-weight').value,
                    sizePx: window.getCaptionPx(),
                    opacity: parseInt(document.getElementById('caption-opacity').value) / 100,
                    placement: document.getElementById('caption-placement').value,
                    showBox: document.getElementById('caption-background').checked,
                    boxOpacity: parseInt(document.getElementById('caption-bg-opacity').value) / 100
                };
                
                // --- BEGIN strictly-typed payload construction ---

                // 1) Get current quote text safely as a string
                const quoteText = ((currentQuote && currentQuote.text) || '').toString();

                // 2) Get mapped and clamped font size
                const sizePx = window.getCaptionPx();

                // 3) Find last generated overlay from preview step
                //    (caption-preview.js should already be writing this)
                const overlay = window.__lastCaptionOverlay;
                // overlay shape we expect: { dataUrl: 'data:image/png;base64,...', width, height, meta: {...} }
                const overlayDataUrl = overlay && typeof overlay.dataUrl === 'string' ? overlay.dataUrl : undefined;

                // 4) Voice handling (don't change existing selection logic‚Äîjust make sure we send strings)
                const voiceId = (currentVoiceId || '').toString();
                const wantVoiceover = !!currentVoiceId; // keep existing toggle, but normalize to boolean

                // 5) Background (use what the page already computed)
                const bg = background; // must be whatever your UI already sets up

                // 6) Build payload with correct conditional logic
                let payload = {
                  mode: 'quote',
                  template: 'calm',
                  durationSec: 8,
                  voiceover: wantVoiceover,
                  includeBottomCaption: true,
                  wantAttribution: true,
                  watermark: true,

                  // strings only
                  text: quoteText,
                  ttsText: wantVoiceover ? quoteText : '',

                  // keep existing background contract
                  background: bg,

                  // pass voice id only if voiceover is on (string type)
                  voiceId: wantVoiceover && voiceId ? voiceId : undefined,
                  
                  // TTS settings for SSOT (normalized to 0-1 range)
                  modelId: wantVoiceover ? 'eleven_multilingual_v2' : undefined,
                  outputFormat: wantVoiceover ? 'mp3_44100_128' : undefined,
                  voiceSettings: wantVoiceover ? {
                    stability: parseFloat(document.getElementById('tts-stability').value),
                    similarity_boost: parseFloat(document.getElementById('tts-similarity').value),
                    style: Math.max(0, Math.min(1, parseInt(document.getElementById('tts-style').value) / 100)), // Normalize 0-100 to 0-1
                    use_speaker_boost: document.getElementById('tts-speaker-boost').checked
                  } : undefined,
                };

                // SSOT: Use saved overlay meta from preview
                if (useOverlayMode && overlaySystemInitialized) {
                  // Validate saved preview before rendering
                  const validation = window.validateBeforeRender ? window.validateBeforeRender() : { valid: false, errors: ['Preview not saved'] };
                  
                  if (!validation.valid) {
                    alert(`Cannot render: ${validation.errors.join(', ')}`);
                    renderBtn.disabled = false;
                    renderBtn.textContent = originalText;
                    return;
                  }
                  
                  const savedMeta = validation.meta;
                  
                  payload.captionMode = 'overlay';
                  payload.overlayCaption = savedMeta; // Use saved meta directly (already normalized by server)
                  
                  console.log('[render] Using saved preview meta:', {
                    xPct: savedMeta.xPct,
                    yPct: savedMeta.yPct,
                    fontPx: savedMeta.fontPx,
                    totalTextH: savedMeta.totalTextH
                  });
                  
                  // Remove legacy fields when using overlay
                  delete payload.caption;
                  delete payload.captionStyle;
                  delete payload.captionImage;
                } else if (overlayDataUrl) {
                  // Legacy PNG overlay fallback
                  payload.captionImage = overlayDataUrl;
                  delete payload.caption;
                  delete payload.captionStyle;
                } else {
                  // Legacy drawtext fallback
                  payload.caption = sizePx;
                  payload.captionMode = 'static';
                  payload.captionStyle = {
                    placement: captionStyle.placement || 'bottom',
                    align: 'center',
                    opacity: clamp(captionStyle.opacity || 0.8, 0, 1),
                    weight: captionStyle.weight || 'bold',
                    font: captionStyle.font || 'DejaVu Sans Local',
                  };
                }

                // remove undefined keys so contract stays clean
                payload = stripUndefined(payload);

                // 7) Log minimal, type-focused debug
                console.debug('[render] payload.types', {
                  captionMode: payload.captionMode,                   // 'overlay' | 'static' | undefined
                  overlayCaption: !!payload.overlayCaption,           // boolean for debugging
                  caption_type: typeof payload.caption,               // expect 'number' when no overlay, 'undefined' when overlay
                  captionImage_type: typeof payload.captionImage,     // 'string' when overlay present or 'undefined'
                  text_type: typeof payload.text,                     // 'string'
                  ttsText_type: typeof payload.ttsText,               // 'string'
                  voiceId_type: typeof payload.voiceId,               // 'string' or 'undefined'
                  hasOverlay: !!overlayDataUrl,                       // boolean for debugging
                  caption_value: payload.caption,                     // show actual value
                  mappedSizePx: sizePx,                            // show mapped font size
                });

                // --- END strictly-typed payload construction ---

                console.log('[render] Final payload:', payload);
                // SSOT validation: Log overlay caption meta to verify positioning data
                if (payload.overlayCaption) {
                  const textPreview = payload.overlayCaption.text || '';
                  const hasNewlines = textPreview.includes('\n');
                  const lineCount = hasNewlines ? textPreview.split('\n').length : 1;
                  
                  console.log('[render] overlayCaption contract verification:', {
                    yPct: payload.overlayCaption.yPct,
                    totalTextH: payload.overlayCaption.totalTextH,
                    lineSpacingPx: payload.overlayCaption.lineSpacingPx,
                    fontPx: payload.overlayCaption.fontPx,
                    wPct: payload.overlayCaption.wPct,
                    xPct: payload.overlayCaption.xPct,
                    textLength: textPreview.length,
                    hasNewlines: hasNewlines,
                    lineCount: lineCount,
                    textPreview: textPreview.substring(0, 80) + (textPreview.length > 80 ? '...' : ''),
                    color: payload.overlayCaption.color,
                    opacity: payload.overlayCaption.opacity
                  });
                }
                console.log('[render] Background object:', background);
                console.log('[render] Current voice ID:', currentVoiceId);

                // Final validation before sending
                if (background.url && background.type) {
                    const url = background.url.toLowerCase();
                    const isVideoUrl = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v'].some(ext => url.includes(`.${ext}`));
                    const isImageUrl = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].some(ext => url.includes(`.${ext}`));
                    
                    if (background.type === 'video' && !isVideoUrl) {
                        console.error('[validation] Type mismatch: type is video but URL is not a video');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                    if (background.type === 'image' && !isImageUrl) {
                        console.error('[validation] Type mismatch: type is image but URL is not an image');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                }

                const data = await apiFetch('/shorts/create', {
                    method: 'POST',
                    body: payload
                });

                if (data.success) {
                    // Success! Show the result
                    const result = data.data;
                    alert(`Short created successfully! Job ID: ${result.jobId}`);
                    
                    // Redirect to My Shorts page so user sees result immediately
                    try { window.location.href = `/my-shorts.html?new=${encodeURIComponent(result.jobId)}`; } catch {}
                    
                    // You could redirect to a results page or show the video here
                    // For now, we'll just show success
                    console.log('Render result:', result);
                } else {
                    alert(`Render failed: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Render error:', error); // includes stack trace
                
                const hint = summarizeCreateError(error);
                alert(`Render failed${hint ? ': ' + hint : ': ' + (error?.message || 'Unknown error')}`);
            } finally {
                renderBtn.disabled = false;
                renderBtn.textContent = originalText;
            }
        }

        // Remix quote function
        async function remixQuote(mode) {
            if (!currentQuote) return;
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to remix quotes');
                return;
            }
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/remix', {
                    method: 'POST',
                    body: {
                        // Prefer live textarea content so users don't need to hit Save first
                        originalText: (document.getElementById('quote-edit')?.value || currentQuote.text || '').trim(),
                        mode,
                        targetTone: mode === 'tone_shift' ? document.getElementById('quote-tone').value : undefined,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    await displayQuote(currentQuote, { skipPreview: true }); // Skip preview during remix
                    decRegens();
                    // Keep the editor visible with new text
                    try {
                      document.getElementById('quote-text-display').classList.add('hidden');
                      document.getElementById('quote-edit').classList.remove('hidden');
                      document.getElementById('save-quote-btn').classList.remove('hidden');
                      document.getElementById('cancel-quote-btn').classList.remove('hidden');
                      document.getElementById('edit-quote-btn').classList.add('hidden');
                    } catch {}
                } else {
                    showError('quote-error', data.reason || 'Failed to remix quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        // Expose to window scope for ui-actions.js
        window.remixQuote = remixQuote;

        // AI Image generation
        async function generateAiImage() {
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            // Check if user has sufficient credits (20 credits for AI generation)
            if (window.currentCredits < 20) {
                showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                return;
            }
            
            const prompt = document.getElementById('ai-prompt').value;
            const styleSlider = document.getElementById('ai-style-slider').value;
            
            if (!prompt.trim()) {
                showError('ai-error', 'Please enter a prompt');
                return;
            }
            
            setLoading('generate-ai-btn', true);
            hideError('ai-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Map slider value to style: 0-0.5 = realistic, 0.5-1 = cartoon
                const style = parseFloat(styleSlider) <= 0.5 ? 'realistic' : 'cartoon';
                
                // Map slider 0..1 ‚Üí ideogram style_type: closer to Realistic at 0, Creative at 1
                const creative = parseFloat(styleSlider);
                const styleType = creative < 0.33 ? 'Photographic' : (creative > 0.66 ? 'Illustration' : 'None');

                const data = await apiFetch('/generate', {
                    method: 'POST',
                    body: {
                        prompt,
                        style, // retained for compatibility
                        count: 1,
                        // ideogram params ride along; backend adapter maps them
                        params: { style_type: styleType },
                        options: {}
                    }
                });
                
                if (data?.ok === true && data?.data?.images) {
                    // Handle successful generation
                    const imgs = data.data.images || [];
                    const first = imgs[0];
                    const url = typeof first === 'string' ? first : (first?.url || first);
                    if (url) {
                        // Update credits display if successful (20 credits deducted by backend)
                        window.currentCredits -= 20;
                        if (window.updateCreditsDisplay) {
                            window.updateCreditsDisplay(window.currentCredits);
                        }
                        
                        const aiAsset = {
                            id: `ai-${Date.now()}`,
                            fileUrl: url,
                            thumbUrl: url,
                            width: 1080,
                            height: 1920,
                            query: prompt,
                            provider: 'ai',
                            type: 'ai-generated'
                        };
                        // Add to asset grid
                        const grid = document.getElementById('asset-grid');
                        const assetElement = createAssetElement(aiAsset);
                        grid.insertBefore(assetElement, grid.firstChild);
                        // Also show next to remix references if present
                        const aiBlock = document.getElementById('ai-result-block');
                        const aiPrev = document.getElementById('ai-result-preview');
                        if (aiBlock && aiPrev) {
                            aiPrev.innerHTML = `<img src="${aiAsset.thumbUrl}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
                            aiBlock.classList.remove('hidden');
                        }
                        // Auto-select the generated image
                        selectAsset(aiAsset);
                    } else {
                        showError('ai-error', 'No image URL returned');
                    }
                } else {
                    // Some backends use { ok:false, reason } envelope
                    showError('ai-error', (data && (data.reason || data.error)) || 'Failed to generate AI image');
                }
            } catch (error) {
                if (error?.reason === 'INSUFFICIENT_CREDITS') {
                    showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                } else {
                    showError('ai-error', error.message || 'Network error');
                }
            } finally {
                setLoading('generate-ai-btn', false);
            }
        }

        // Remix button handler: require at least 1 reference, prefer 2
        document.addEventListener('click', (e) => {
            const t = e.target;
            if (!t || t.id !== 'remix-generate-btn') return;
            e.preventDefault();
            
            // Check if user is logged in
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            // Check if user has sufficient credits (20 credits for AI generation)
            if (window.currentCredits < 20) {
                showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                return;
            }
            
            // Collect refs + prompt + style, then call generate endpoint
            const base = document.getElementById('ai-prompt');
            const prompt = (base?.value || '').trim();
            const styleSlider = document.getElementById('ai-style-slider');
            const sVal = parseFloat(styleSlider?.value || '0.5');
            const style = sVal < 0.33 ? 'realistic' : (sVal > 0.66 ? 'creative' : 'realistic');

            const refs = Array.from(document.querySelectorAll('#remix-assets img, #remix-assets video'))
              .map((el)=> el.getAttribute('src') || el.getAttribute('poster'))
              .filter(Boolean)
              .filter((v, i, arr) => arr.indexOf(v) === i)
              .slice(0,2);

            // Fallback to simple text-to-image if no refs
            if (refs.length < 2) {
              generateAiImage();
              return;
            }

            // Use existing assets API for AI image generation (single image)
            // We reuse the /assets/ai-images for now with count:1
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                // Compose a richer prompt mentioning references implicitly
                const styleMap = style === 'creative' ? 'illustration' : 'photographic';
                const data = await apiFetch('/assets/ai-images', { method:'POST', body: { prompt: `${prompt}`.trim(), style: style === 'creative' ? 'creative' : 'realistic', count: 1 } });
                console.log('[AI Image] Response:', data); // Debug log
                if (!data?.ok || !data?.data?.images || data.data.images.length === 0) {
                    console.error('[AI Image] Failed:', data);
                    showError('ai-error', 'AI image generation failed'); 
                    return; 
                }
                
                const firstImage = data.data.images[0];
                const url = firstImage?.url || null;
                if (!url) { showError('ai-error', 'No image URL in response'); return; }
                
                // Update credits display if successful
                if (data?.data?.creditsDeducted) {
                    window.currentCredits -= data.data.creditsDeducted;
                    if (window.updateCreditsDisplay) {
                        window.updateCreditsDisplay(window.currentCredits);
                    }
                }
                
                // Display result
                const aiBlock = document.getElementById('ai-result-block');
                const aiPrev = document.getElementById('ai-result-preview');
                if (aiBlock && aiPrev) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(url)}`;
                  aiPrev.innerHTML = `<img crossOrigin="anonymous" src="${proxied}" class="w-full h-full object-cover block" />`;
                  aiBlock.classList.remove('hidden');
                }
              } catch (err) {
                if (err?.reason === 'INSUFFICIENT_CREDITS') {
                    showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                } else {
                    showError('ai-error', err?.message || 'AI generation error');
                }
              }
            })();
        });

        // Save & Use handler: persists image URL and marks as selected background
        document.addEventListener('click', async (e) => {
            if (e.target?.id !== 'ai-save-use-btn') return;
            e.preventDefault();
            try {
              const imgEl = document.querySelector('#ai-result-preview img');
              const url = imgEl?.getAttribute('src');
              if (!url) return;
              const { apiFetch } = await import('./api.mjs');
              // Store the image in storage and get a tokenized URL
              const reg = await apiFetch('/uploads/register', { method:'POST', body:{ imageUrl: url } });
              const savedUrl = reg?.data?.url || url;
              // Mark selection locally and update preview immediately
              selectedAsset = { id: `ai-${Date.now()}`, provider: 'ai', query: (document.getElementById('ai-prompt')?.value||'').trim(), fileUrl: savedUrl, thumbUrl: savedUrl, width: 1080, height: 1920 };
              updateRenderPreview();
              updateRenderButtonState();
              // Also update dedicated preview nodes if present
              try {
                // Ensure we have a preview <img id="preview-img"> inside live preview
                let previewImg = document.getElementById('preview-img');
                if (!previewImg) {
                  const live = document.getElementById('live-preview-container');
                  if (live) {
                    live.classList.remove('hidden');
                    const holder = live.querySelector('.relative') || live;
                    // Force 9x16 preview aspect
                    try { holder.style.aspectRatio = '9 / 16'; } catch {}
                    try { if (!holder.style.background) holder.style.background = '#000'; } catch {}
                    // Clear holder if it only had a canvas (we'll still keep canvas for other flows)
                    // but append img above it so swap is visible immediately
                    previewImg = document.createElement('img');
                    previewImg.id = 'preview-img';
                    previewImg.style.width = '100%';
                    previewImg.style.height = '100%';
                    previewImg.style.display = 'block';
                    previewImg.style.objectFit = 'cover';
                    holder.prepend(previewImg);
                    // Hide canvas during static image preview to avoid black overlay
                    try { const c = holder.querySelector('#live-preview-canvas'); if (c) c.style.display = 'none'; } catch {}
                  }
                }
                if (previewImg) {
                  try { previewImg.crossOrigin = 'anonymous'; } catch {}
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewImg.src = proxied;
                }
                // Ensure overlay visible for still image preview
                try { const ov = document.getElementById('caption-overlay'); if (ov) ov.style.display = 'block'; } catch {}
                const previewBox = document.getElementById('short-preview');
                if (previewBox) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewBox.style.backgroundImage = `url("${proxied}")`;
                  previewBox.setAttribute('data-bg', proxied);
                }
                window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentBackgroundUrl = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
              } catch {}
              // Feedback
              try { showToast('‚úÖ Saved to My Images and selected'); } catch {}
            } catch (err) {
              console.warn('Save & Use failed:', err);
            }
        });

        // Event listeners - generateQuote now handled by ui-actions.js
        const useTextBtn = document.getElementById('use-text-btn');
        if (useTextBtn) {
          useTextBtn.onclick = () => {
            const input = document.getElementById('quote-text').value.trim();
            if (!input) return;
            currentQuote = { text: input };
            displayQuote(currentQuote);
            // Ensure visible in view mode on use
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.classList.add('hidden');
            disp.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            // do not reset regen counter here
            // Persist immediately so it can be used for the short without extra clicks
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                await apiFetch('/quotes/save', { method:'POST', body:{ text: input, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
                try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = input; } catch {}
              } catch (e) {
                console.warn('Use This Text save failed:', e?.message || e);
              }
            })();
            
            // Trigger caption preview immediately after using text
            try {
                updateCaptionOverlay(input, true);
            } catch (e) {
                console.warn('[caption-overlay] auto-preview failed (non-fatal)', e);
            }
          };
        }
        // search-assets-btn now handled by ui-actions.js
        const prevPageBtn = document.getElementById('prev-page-btn');
        if (prevPageBtn) prevPageBtn.onclick = () => loadAssets(currentAssetPage - 1);
        
        const nextPageBtn = document.getElementById('next-page-btn');
        if (nextPageBtn) nextPageBtn.onclick = () => loadAssets(currentAssetPage + 1);
        
        const generateAiBtn = document.getElementById('generate-ai-btn');
        if (generateAiBtn) generateAiBtn.onclick = generateAiImage;
        
        const uploadAssetBtn = document.getElementById('upload-asset-btn');
        if (uploadAssetBtn) uploadAssetBtn.onclick = () => {
            const uploadInput = document.getElementById('asset-upload-input');
            if (uploadInput) uploadInput.click();
        };
        const assetUploadInput = document.getElementById('asset-upload-input');
        if (assetUploadInput) assetUploadInput.onchange = (e) => handleFileUpload(e.target.files);
        
        const clearRemixBtn = document.getElementById('clear-remix-btn');
        if (clearRemixBtn) clearRemixBtn.onclick = () => {
            remixAssets = [];
            updateRemixArea();
        };
        
        const renderBtn = document.getElementById('render-btn');
        if (renderBtn) renderBtn.onclick = renderShort;
        
        // Wire Save Preview button (SSOT workflow)
        const savePreviewBtn = document.getElementById('save-preview-btn');
        if (savePreviewBtn) savePreviewBtn.onclick = savePreview;
        
        // Overlay mode toggle event listener (auto-initialize overlay; no extra buttons)
        const overlayModeToggle = document.getElementById('overlay-mode-toggle');
        if (overlayModeToggle) overlayModeToggle.onchange = toggleOverlayMode;
        
        // Overlay control event listeners
        const showOutlineToggle = document.getElementById('show-outline-toggle');
        if (showOutlineToggle) showOutlineToggle.onchange = async () => {
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js');
                    const meta = getCaptionMeta();
                    meta.showBox = document.getElementById('show-outline-toggle').checked;
                    applyCaptionMeta(meta);
                } catch (e) {
                    console.warn('[overlay] outline toggle failed', e);
                }
            }
        };
        
        const responsiveTextToggle = document.getElementById('responsive-text-toggle');
        if (responsiveTextToggle) responsiveTextToggle.onchange = async () => {
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js');
                    const meta = getCaptionMeta();
                    meta.responsiveText = document.getElementById('responsive-text-toggle').checked;
                    applyCaptionMeta(meta);
                } catch (e) {
                    console.warn('[overlay] responsive text toggle failed', e);
                }
            }
        };
        
        // Debug function to check overlay system status
        window.debugOverlaySystem = function() {
            console.log('[debug] Overlay system status:', {
                useOverlayMode,
                overlaySystemInitialized,
                hasGetCaptionMeta: typeof window.getCaptionMeta === 'function',
                hasSetQuote: typeof window.setQuote === 'function',
                stageVisible: document.getElementById('stage').style.display !== 'none',
                legacyOverlayVisible: document.getElementById('caption-overlay').style.display !== 'none'
            });
            
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const meta = window.getCaptionMeta();
                    console.log('[debug] Current overlay meta:', meta);
                } catch (error) {
                    console.error('[debug] Failed to get overlay meta:', error);
                }
            }
        };
        
        // Caption style event listeners
        const captionFont = document.getElementById('caption-font');
        if (captionFont) captionFont.onchange = async () => {
            if (useOverlayMode) { try { const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js'); const m = getCaptionMeta(); m.fontFamily = document.getElementById('caption-font').value; applyCaptionMeta(m); } catch(e){ console.warn('[overlay] font apply failed', e);} }
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        const captionWeight = document.getElementById('caption-weight');
        if (captionWeight) captionWeight.onchange = async () => {
            const newWeight = document.getElementById('caption-weight').value;
            console.log('[controls] Weight changed to:', newWeight);
            if (useOverlayMode) { try { const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js'); const m = getCaptionMeta(); m.weightCss = newWeight; applyCaptionMeta(m); } catch(e){ console.warn('[overlay] weight apply failed', e);} }
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        // Legacy caption-size handler removed - now handled by initCaptionSizeUI()
        document.getElementById('caption-opacity').oninput = async () => { 
            const newOpacity = document.getElementById('caption-opacity').value;
            console.log('[controls] Opacity changed to:', newOpacity);
            if (useOverlayMode) { try { const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js'); const m = getCaptionMeta(); m.opacity = parseInt(newOpacity)/100; applyCaptionMeta(m); } catch(e){ console.warn('[overlay] opacity apply failed', e);} }
            updateCaptionStyleValues(); 
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true); 
        };
        const captionPlacement = document.getElementById('caption-placement');
        if (captionPlacement) captionPlacement.onchange = () => {
            const newPlacement = document.getElementById('caption-placement').value;
            console.log('[controls] Placement changed to:', newPlacement);
            
            // Clear existing caption overlay to force regeneration
            const overlay = document.getElementById('caption-overlay');
            if (overlay) {
                overlay.innerHTML = '';
                overlay.style.display = 'none';
            }
            
            // Clear cached caption data
            if (window.lastCaptionPNG) {
                window.lastCaptionPNG = null;
            }
            if (window.__lastCaptionOverlay) {
                window.__lastCaptionOverlay = null;
            }
            
            updateCaptionStyleValues();
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        const captionBackground = document.getElementById('caption-background');
        if (captionBackground) captionBackground.onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-bg-opacity').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        
        // Voiceover event listeners
        const voiceoverVoice = document.getElementById('voiceover-voice');
        if (voiceoverVoice) voiceoverVoice.onchange = () => {
            const voiceSelect = document.getElementById('voiceover-voice');
            currentVoiceId = voiceSelect.value || null;
            updateRenderPreview();
        };
        const previewVoiceBtn = document.getElementById('preview-voice-btn');
        if (previewVoiceBtn) previewVoiceBtn.onclick = previewVoice;
        
        // TTS Settings event handlers
        document.getElementById('tts-stability').oninput = function() {
            document.getElementById('stability-value').textContent = this.value;
            updateRenderPreview();
        };
        document.getElementById('tts-similarity').oninput = function() {
            document.getElementById('similarity-value').textContent = this.value;
            updateRenderPreview();
        };
        document.getElementById('tts-style').oninput = function() {
            document.getElementById('style-value').textContent = this.value;
            updateRenderPreview();
        };
        const ttsSpeakerBoost = document.getElementById('tts-speaker-boost');
        if (ttsSpeakerBoost) ttsSpeakerBoost.onchange = function() {
            updateRenderPreview();
        };

        // Remix button event listeners now handled by ui-actions.js

        // Inline edit handlers - converted to named functions for ui-actions.js
        function editQuote() {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.value = (currentQuote?.text || '').trim();
            disp.classList.add('hidden');
            ta.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            // While editing, hide caption overlay
            updateCaptionOverlay('', false);
        }

        function cancelEdit() {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            // remain in edit mode but clear contents
            ta.value = '';
            updateCaptionOverlay('', false);
            // do not change regen counter
        }

        async         function saveQuote() {
            const ta = document.getElementById('quote-edit');
            const newText = ta.value.trim().slice(0, 200);
            if (!newText) return;
            currentQuote = { ...(currentQuote||{}), text: newText };
            document.getElementById('quote-text-display').textContent = newText;
            // do not reset regen counter on save
            // switch to locked/solid view after save
            
            // Invalidate saved preview since quote text changed
            if (window.markPreviewUnsaved) {
                window.markPreviewUnsaved();
                updateRenderButtonState();
            }
            ta.classList.add('hidden');
            document.getElementById('quote-text-display').classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            updateRenderPreview();
            
            // Always show caption after save (even with no media)
            try {
                console.log('[save] caption text:', newText);
                await ensureOverlayActive();
                
                if (useOverlayMode && overlaySystemInitialized) {
                    console.log('[overlay-caption] set:', newText.substring(0,80));
                    await updateOverlayCaption(newText, true);
                    
                    // If no media selected yet, ensure stage stays visible with black background
                    if (!selectedAsset) {
                        const stage = document.getElementById('stage');
                        const previewMedia = document.getElementById('previewMedia');
                        
                        // Ensure stage has minimum dimensions (prevent collapse)
                        if (stage) {
                            stage.style.display = 'block';
                            stage.style.minHeight = '400px';
                            stage.style.backgroundColor = '#000';
                        }
                        
                        if (previewMedia) {
                            // 1x1 black pixel data URL (more deterministic than CSS background)
                            previewMedia.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
                            previewMedia.style.display = 'block';
                            console.log('[overlay-save] text: "' + newText.substring(0, 40) + '...", hasMedia: false');
                        }
                    } else {
                        console.log('[overlay-save] text: "' + newText.substring(0, 40) + '...", hasMedia: true');
                    }
                    
                    // Ensure overlay is visible on top
                    try {
                        const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                        ensureOverlayTopAndVisible('#stage');
                    } catch {}
                } else {
                    updateCaptionOverlay(newText, true);
                }
            } catch (e) {
                console.warn('[overlay] save‚Üíoverlay failed', e);
            }

            // Persist to backend so it can be used in the short without CORS issues
            try {
              const { apiFetch } = await import('./api.mjs');
              await apiFetch('/quotes/save', { method: 'POST', body: { text: newText, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
              try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = newText; } catch {}
            } catch (e) {
              console.warn('Quote save failed (non-fatal):', e?.message || e);
            }
        }

        // Expose to window scope for ui-actions.js
        window.editQuote = editQuote;
        window.cancelEdit = cancelEdit;
        window.saveQuote = saveQuote;

        // Character counter for input
        document.getElementById('quote-text').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
        });

        // Also update counter when typing inside the inlaid editor
        document.getElementById('quote-edit').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
            // live overlay while editing
            try { updateCaptionOverlay(v, true); } catch {}
        });

        // Resize listener for zoom/resize scenarios - re-render preview
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                try { import('./js/caption-overlay.js').then(({ ensureOverlayTopAndVisible }) => ensureOverlayTopAndVisible('#stage')); } catch {}
                if (selectedAsset) {
                    if (_currentPexelsPhoto && selectedAsset?.provider === 'pexels') {
                        // Preserve existing previewUrl when updating selectedAsset
                        const existingPreviewUrl = selectedAsset.previewUrl;
                        selectedAsset = { ...selectedAsset, ..._currentPexelsPhoto };
                        if (existingPreviewUrl) {
                            selectedAsset.previewUrl = existingPreviewUrl;
                        }
                        onPexelsUse(_currentPexelsPhoto);
                    } else {
                        // For non-Pexels assets, just redraw the preview
                        updateLivePreview();
                    }
                }
            }, 150); // Debounce resize events
        });

        // Tab switching is now handled by the delegated router in ui-actions.js
        // No duplicate onclick handlers needed
        

        // Theme toggle functionality
        function initTheme() {
            const themeToggle = document.getElementById('theme-toggle');
            if (!themeToggle) return;

            // Set initial theme
            if (localStorage.getItem("theme") === "dark") {
                document.documentElement.classList.add("dark");
                themeToggle.textContent = "üåô";
            } else {
                document.documentElement.classList.remove("dark");
                themeToggle.textContent = "‚òÄÔ∏è";
            }

            // Theme toggle event listener
            themeToggle.addEventListener("click", () => {
                const isDark = document.documentElement.classList.toggle("dark");
                localStorage.setItem("theme", isDark ? "dark" : "light");
                themeToggle.textContent = isDark ? "üåô" : "‚òÄÔ∏è";
            });
        }

        // Initialize authentication using existing system
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme first
            initTheme();
            
            // Wait for auth system to be ready
            const checkAuth = () => {
                if (window.auth && window.onAuthStateChanged) {
                    // Listen for auth state changes
                    window.onAuthStateChanged(window.auth, async (user) => {
                        const loggedIn = !!user;
                        
                        // Update UI visibility
                        document.querySelectorAll(".logged-in")?.forEach(el => el.classList.toggle("hidden", !loggedIn));
                        document.querySelectorAll(".logged-out")?.forEach(el => el.classList.toggle("hidden", loggedIn));

                        if (!loggedIn) {
                            updateCreditUI(0);
                            updateRenderButtonState();
                            return;
                        }

                        try {
                            // Give api.mjs a brief moment to obtain the token via the bridge
                            if (window.__vaiform_diag__?.tokenWait) { 
                                await window.__vaiform_diag__.tokenWait(4000); 
                            }
                            await refreshCredits(true);
                            
                            // Update render button state after auth changes
                            updateRenderButtonState();
                            
                            // Load voices with a small delay to ensure auth is fully ready
                            setTimeout(() => {
                                loadVoices();
                            }, 500);
                        } catch (e) {
                            console.error("Failed to refresh credits:", e);
                        }
                    });
                } else {
                    // Retry in 100ms if auth not ready yet
                    setTimeout(checkAuth, 100);
                }
            };
            
            checkAuth();

            // Initialize quote editor for manual entry from the start
            try {
                const seedInput = document.getElementById('quote-text');
                const seed = (seedInput?.value || '').trim();
                // Use default caption if no seed text provided
                const defaultCaption = seed || 'Success is the result of persistent effort and unwavering belief in yourself.';
                currentQuote = { text: defaultCaption };
                displayQuote(currentQuote);
                // Switch to edit mode by default so users can type immediately
                const disp = document.getElementById('quote-text-display');
                const ta = document.getElementById('quote-edit');
                disp.classList.add('hidden');
                ta.classList.remove('hidden');
                document.getElementById('save-quote-btn').classList.remove('hidden');
                document.getElementById('cancel-quote-btn').classList.remove('hidden');
                document.getElementById('edit-quote-btn').classList.add('hidden');
                // Do not reset regen counter on init
                // Fix E: Initialize preview system after content is ready
                try { 
                    initPreviewSystem();
                    
                    // Fix E: Add ResizeObserver for canvas resizing
                    const canvas = document.getElementById('live-preview-canvas');
                    const container = document.getElementById('live-preview-container');
                    if (canvas && container) {
                        new ResizeObserver(() => {
                            if (sizeCanvasToCSS(canvas)) {
                                // Trigger preview update on resize
                                if (currentQuote?.text && selectedAsset) {
                                    updateLivePreview();
                                    updateCaptionOverlay(currentQuote.text.trim(), true);
                                }
                            }
                        }).observe(container);
                    }
                } catch (e) {
                    console.warn('[preview-init] failed:', e);
                }
                
                // Seed char counter
                const n = Math.min(200, defaultCaption.length);
                const cc = document.getElementById('quote-char-count');
                if (cc) cc.textContent = `${n}/200`;
            } catch {}
        });

        // Fix E: Ensure the first render actually fires
        window.addEventListener('load', () => {
            console.log('[preview-init] Page loaded, initializing preview');
            initPreviewSystem();
            
            // Setup canvas observer for new preview fixes
            if (window.__PREVIEW_FIX__) {
                setupCanvasObserver();
                
                // Re-run render on visibilitychange when tab becomes visible
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && canvasReadyState.ready) {
                        console.log('[preview-init] Tab visible, reinitializing preview');
                        scheduleRender();
                    }
                });
            }
            
            // Also trigger preview if we already have both quote and asset
            if (currentQuote && selectedAsset) {
                console.log('[preview-init] Both quote and asset available, triggering preview');
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
        });
        
        // Removed duplicate visibilitychange listener - consolidated into DOMContentLoaded handler above
    </script>

    <script>
      // ========================================
      // AUDIT NOTES (Phase 0 findings):
      // - Router: Single delegated click router in ui-actions.js using [data-action]
      // - Router style: Calls window.* functions (generateQuote, remixQuote, loadAssets, etc.)
      // - DOM selectors: Already correct (#quote-text, #quote-tone, #quote-result, #asset-query, #asset-grid)
      // - Functions exposed: window.generateQuote (line ~1706), window.loadAssets (~1801), window.remixQuote (~3236)
      // - Now also exposed: window.editQuote, window.cancelEdit, window.saveQuote (~3754-3756)
      // - No legacy-gate blocks found
      // - SSOT: One router (ui-actions.js), one set of controllers, one overlay update path
      // - Safe `must()` helper already exists at line ~1046
      // ========================================

      // Accordion behavior - single open section
      (function(){
        const headers = document.querySelectorAll('.accordion-header');
        const bodies = document.querySelectorAll('.accordion-body');
        
        function toggleSection(targetSection) {
          const targetHeader = document.querySelector(`[data-section="${targetSection}"]`);
          const targetBody = document.getElementById(`${targetSection}-body`);
          const targetIcon = targetHeader?.querySelector('.accordion-icon');
          
          // Toggle the clicked section
          if (targetHeader?.classList.contains('active')) {
            // Close if already open
            targetHeader.classList.remove('active');
            targetBody?.classList.remove('active');
            targetIcon.textContent = '‚ñ∂';
          } else {
            // Open if closed
            targetHeader.classList.add('active');
            targetBody?.classList.add('active');
            targetIcon.textContent = '‚ñº';
          }
        }
        
        headers.forEach(header => {
          header.addEventListener('click', (event) => {
            // Only toggle if clicking the header itself, not buttons inside
            if (event.target === header || event.target.closest('.accordion-header') === header) {
              // Don't toggle if clicking on action buttons
              if (event.target.dataset && event.target.dataset.action) {
                return;
              }
              const section = header.dataset.section;
              toggleSection(section);
            }
          });
        });
        
        // Update summaries when state changes
        function updateSummaries() {
          // Quote summary
          const quoteSummary = document.getElementById('quote-summary');
          if (quoteSummary && window.currentQuote?.text) {
            const text = window.currentQuote.text.substring(0, 50);
            quoteSummary.textContent = text + (window.currentQuote.text.length > 50 ? '...' : '');
          }
          
          // Media summary
          const mediaSummary = document.getElementById('media-summary');
          if (mediaSummary && window.selectedAsset) {
            const asset = window.selectedAsset;
            let summary = '';
            if (asset.provider === 'pexels') {
              summary = `Pexels ‚Ä¢ ${asset.query || 'Image'}`;
            } else if (asset.provider === 'ai') {
              summary = `AI ‚Ä¢ ${asset.query || 'Generated'}`;
            } else if (asset.provider === 'uploaded') {
              summary = 'Uploaded file';
            }
            mediaSummary.textContent = summary;
          }
          
          // Voice summary
          const voiceSummary = document.getElementById('voice-summary');
          if (voiceSummary && window.currentVoiceId) {
            const voiceSelect = document.getElementById('voiceover-voice');
            const selectedOption = voiceSelect?.selectedOptions[0];
            const voiceName = selectedOption?.text || window.currentVoiceId;
            voiceSummary.textContent = voiceName;
          }
        }
        
        // Hook into existing state updates
        const originalDisplayQuote = window.displayQuote;
        if (originalDisplayQuote) {
          window.displayQuote = function(quote) {
            originalDisplayQuote(quote);
            updateSummaries();
          };
        }
        
        // Update summaries on load
        setTimeout(updateSummaries, 1000);
        
        // Update preview height based on media selection
        function updatePreviewHeight() {
          const previewContainer = document.getElementById('live-preview-container');
          if (previewContainer) {
            if (window.selectedAsset) {
              previewContainer.classList.add('has-media');
            } else {
              previewContainer.classList.remove('has-media');
            }
          }
        }
        
        // Hook into asset selection to update preview height
        const originalAssetSelection = window.onAssetSelect;
        if (originalAssetSelection) {
          window.onAssetSelect = function(asset) {
            originalAssetSelection(asset);
            updatePreviewHeight();
          };
        }
        
        // Update preview height on load
        setTimeout(updatePreviewHeight, 1000);
        
        // Media buttons are now handled by ui-actions.js delegated event system
      })();
    </script>


</body>
</html>
