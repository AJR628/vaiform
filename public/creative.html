<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Studio - Vaiform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Unified Header and Auth -->
    <script type="module">
        import { createUnifiedHeader, initializeHeader } from "/components/header.js";
        import { initializeAuth } from "/components/auth-utils.js";
        
        // Load unified header
        document.getElementById('unified-header').innerHTML = createUnifiedHeader();
        initializeHeader();
        
        // Initialize auth after a short delay to ensure Firebase is ready
        setTimeout(() => {
            initializeAuth();
        }, 100);
    </script>
    
    <!-- Firebase SDK - Load the same way as main site -->
    <script type="module" src="./js/firebaseClient.js"></script>
    <!-- Auth bridge: expose auth & wire token provider before page code -->
    <script type="module" src="./auth-bridge.js"></script>
    <script type="module" src="/js/credits-ui.js?v=20250920b"></script>
    <script type="module">
        // Make credits functions globally available
        import { updateCreditsDisplay, fetchAndUpdateCredits } from '/js/credits-ui.js?v=20250920b';
        window.updateCreditsDisplay = updateCreditsDisplay;
        window.fetchAndUpdateCredits = fetchAndUpdateCredits;
    </script>
    <script type="module">
        // Import render payload helper functions for SSOT preview workflow
        try {
            const { 
                getSavedOverlayMeta, 
                validateOverlayCaption,
                validateBeforeRender,
                showPreviewSavedIndicator,
                markPreviewUnsaved
            } = await import('/js/render-payload-helper.js');
            
            // Make globally available
            window.getSavedOverlayMeta = getSavedOverlayMeta;
            window.validateOverlayCaption = validateOverlayCaption;
            window.validateBeforeRender = validateBeforeRender;
            window.showPreviewSavedIndicator = showPreviewSavedIndicator;
            window.markPreviewUnsaved = markPreviewUnsaved;
            
            console.log('[module] render-payload-helper functions loaded successfully');
        } catch (error) {
            console.error('[module] Failed to load render-payload-helper:', error);
            // Set up fallback functions
            window.showPreviewSavedIndicator = function(containerSelector = '#preview-status') {
                const container = document.querySelector(containerSelector);
                if (!container) return;
                
                const meta = window.getSavedOverlayMeta ? window.getSavedOverlayMeta() : null;
                
                if (meta) {
                    container.innerHTML = `
                        <div class="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded text-sm">
                            <span>‚úì</span>
                            <span>Preview saved - ready to render</span>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="flex items-center gap-2 px-3 py-2 bg-yellow-600 text-white rounded text-sm">
                            <span>‚ö†</span>
                            <span>No preview saved - generate preview before rendering</span>
                        </div>
                    `;
                }
                container.classList.remove('hidden');
            };
            
            window.getSavedOverlayMeta = function() {
                if (window._overlayMeta) return window._overlayMeta;
                try {
                    const stored = localStorage.getItem('overlayMetaV3');
                    if (stored) {
                        const meta = JSON.parse(stored);
                        // Validate ssotVersion === 3
                        if (meta.ssotVersion !== 3) {
                            console.warn('[fallback] Ignoring saved meta with wrong ssotVersion:', meta.ssotVersion);
                            localStorage.removeItem('overlayMetaV3');
                            return null;
                        }
                        window._overlayMeta = meta;
                        return meta;
                    }
                } catch (err) {
                    console.warn('[fallback] Failed to load from localStorage:', err.message);
                }
                return null;
            };
        }
        
        // Initialize preview saved flag
        if (typeof window._previewSavedForCurrentText === 'undefined') {
            window._previewSavedForCurrentText = false;
        }
    </script>
    <script type="module" src="./frontend.js"></script>
    <!-- Shared geometry utilities for caption positioning -->
    <script src="./js/caption-geom.js"></script>
    <!-- Hybrid caption preview system -->
    <script type="module" src="./js/caption-live.js"></script>
    <!-- Import shared line extraction function -->
    <script type="module">
        import { extractRenderedLines, extractLinesStable } from './js/caption-overlay.js';
        window.extractRenderedLines = extractRenderedLines;
        window.extractLinesStable = extractLinesStable;
    </script>
    <!-- Delegated event system for action buttons -->
    <script src="./js/ui-actions.js"></script>
    <link rel="stylesheet" href="/creative.css" />
    <!-- Font loading handled by creative.css (DejaVu Sans variants via /assets/fonts/) -->
    <!-- Caption rendering now uses server-side PNG overlay - no fonts needed -->
    <style>
        .loading { opacity: 0.6; pointer-events: none; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        
        /* Force dark mode for content boxes */
        .dark .content-box {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        .dark .content-box h2 {
            color: #ffffff !important;
        }
        
        /* Force dark mode for quote result box */
        .dark #quote-result {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for quote text display */
        .dark #quote-text-display {
            color: #ffffff !important;
        }
        
        /* Force dark mode for quote edit textarea */
        .dark #quote-edit {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for remix area */
        .dark #remix-area {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for remix area heading */
        .dark #remix-area h3 {
            color: #d1d5db !important; /* gray-300 */
        }
        
        /* Force dark mode for remix assets container */
        .dark #remix-assets {
            background-color: transparent !important;
        }
        
        /* Force dark mode for AI result preview */
        .dark #ai-result-preview {
            background-color: #111827 !important; /* gray-900 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for render preview box */
        .dark #render-preview {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for preview text elements */
        .dark #preview-quote {
            color: #ffffff !important;
        }
        
        .dark #preview-asset,
        .dark #preview-caption-style,
        .dark #preview-voiceover {
            color: #9ca3af !important; /* gray-400 */
        }
        
        /* Force dark mode for remix input text */
        .dark #remix-input {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for clip picker container */
        .dark #clip-picker {
            background-color: #1f2937 !important; /* gray-800 */
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for clip picker heading */
        .dark #clip-picker h3 {
            color: #ffffff !important;
        }
        
        /* Force dark mode for clip picker close button */
        .dark #clip-picker-close {
            color: #9ca3af !important; /* gray-400 */
        }
        
        .dark #clip-picker-close:hover {
            color: #ffffff !important;
        }
        
        /* Force dark mode for clip search input */
        .dark #clip-search-input {
            background-color: #111827 !important; /* gray-900 */
            color: #ffffff !important;
            border-color: #4b5563 !important; /* gray-600 */
        }
        
        /* Force dark mode for clip picker pagination buttons */
        .dark #clip-picker-prev {
            background-color: #374151 !important; /* gray-700 */
            color: #ffffff !important;
        }
        
        .dark #clip-picker-prev:hover:not(:disabled) {
            background-color: #4b5563 !important; /* gray-600 */
        }
        
        /* --- Caption overlay stacking & sizing --- */
        #live-preview-container { position: relative; }
        #live-preview-canvas { position: relative; z-index: 1; display: block; width: 100%; height: auto; }
        #caption-overlay {
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 1;
        }
        /* Make sure preview media and any legacy containers never steal pointer events */
        #stage img, #stage video, #previewMedia, .preview-overlay, #previewOverlayCanvas, #previewOverlayImg {
            pointer-events: none;
            z-index: 1;
        }
        /* Draggable box must sit on top */
        .caption-box, .caption-box .drag-handle { touch-action: none; }
        .caption-box { z-index: 9999; }
        
        /* Add beat button - minimal "+" sign with hover effect */
        .add-beat-btn {
            transition: transform 0.2s ease;
            cursor: pointer;
        }
        .add-beat-btn:hover {
            transform: scale(1.2);
        }
        .beat-text-editing {
            outline: 2px solid #3b82f6;
            outline-offset: -2px;
            background-color: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
        }
    </style>
    <!-- Respect saved theme before paint - default to dark -->
    <script>
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "light") {
            document.documentElement.classList.remove("dark");
        } else {
            document.documentElement.classList.add("dark");
        }
    </script>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">
    <!-- Unified Header -->
    <div id="unified-header"></div>

    <!-- Hero Section -->
    <section class="w-full md:max-w-5xl md:mx-auto px-4 sm:px-6 lg:px-8 py-8 md:py-12">
        <div class="flex flex-col md:flex-row md:items-start md:justify-between md:gap-8">
            <div class="flex-1">
                <p class="text-sm text-gray-500 dark:text-gray-100 mb-3">Articles ‚Üí Shorts</p>
                <h1 class="text-3xl md:text-4xl font-bold text-gray-900 dark:text-white mb-4">Turn articles into vertical explainers in minutes.</h1>
                <p class="text-base text-gray-600 dark:text-gray-100 leading-relaxed">Transform long-form content into engaging short-form videos with AI-powered scripting, storyboarding, and voiceover.</p>
            </div>
            <div class="mt-6 md:mt-0 md:flex-shrink-0">
                <div class="space-y-3 text-sm text-gray-600 dark:text-gray-100">
                    <div class="flex items-start gap-2">
                        <span class="text-lg">‚ë†</span>
                        <span>Paste article</span>
                    </div>
                    <div class="flex items-start gap-2">
                        <span class="text-lg">‚ë°</span>
                        <span>Edit script & storyboard</span>
                    </div>
                    <div class="flex items-start gap-2">
                        <span class="text-lg">‚ë¢</span>
                        <span>Render short</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <main class="w-full md:max-w-5xl md:mx-auto px-4 sm:px-6 lg:px-8 pb-16 space-y-6">
        <!-- Mode Toggle Tabs -->
        <div class="flex gap-2 mb-2 md:mb-4">
            <button
                id="mode-quotes-tab"
                data-action="setModeQuotes"
                type="button"
                class="px-4 py-2 rounded bg-blue-600 text-white font-medium"
            >
                Quotes
            </button>
            <button
                id="mode-articles-tab"
                data-action="setModeArticles"
                type="button"
                class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white font-medium"
            >
                Articles
            </button>
        </div>

        <!-- Accordion Layout -->
        <!-- Mobile order: quote ‚Üí CTA ‚Üí preview. Desktop: preview ‚Üí quote ‚Üí CTA -->
        <div class="studio-accordion-layout flex flex-col md:grid md:grid-cols-2">
            <!-- Left: Accordion Sections -->
            <div class="studio-accordion-left order-1 md:order-2">
                <!-- Quote Section -->
                <div class="accordion-section" data-mode="quotes">
                    <div class="accordion-header active" data-section="quote">
                        <div class="accordion-title">
                            <span class="accordion-icon">‚ñº</span>
                            <span class="accordion-label">Step 1 ‚Äì Your Quote</span>
                        </div>
                        <div class="accordion-summary" id="quote-summary">Write your own quote or let AI suggest one.</div>
                    </div>
                    <div class="accordion-body active" id="quote-body">

                        <!-- Quote Generation Section -->
                        <div id="section-quote" class="content-box bg-gray-50/80 dark:bg-slate-900/60 border border-gray-200/50 dark:border-white/5 rounded-2xl p-4 md:p-6 space-y-4 shadow-sm w-full">
                            <div class="text-xs text-gray-400 dark:text-gray-500 mb-2">Step 1 ¬∑ Your quote</div>
                            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Generate Quote</h2>
                            <p class="text-sm text-gray-600 dark:text-gray-400 leading-tight">Describe the kind of quote you want, or type your own.</p>
            
            <div class="flex flex-col gap-2 md:flex-row md:items-center md:gap-4">
                <input
                    type="text"
                    id="quote-text"
                    value="Create a motivational quote about success"
                    placeholder="Describe the quote you want‚Ä¶"
                    class="w-full md:flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <div class="hidden md:block text-xs text-gray-500 dark:text-gray-400 w-20 text-right" id="quote-char-count">0/200</div>
                <div class="flex flex-col sm:flex-row gap-2 md:gap-4">
                    <select id="quote-tone" class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="default">Default</option>
                        <option value="motivational">Motivational</option>
                        <option value="witty">Witty</option>
                        <option value="poetic">Poetic</option>
                        <option value="bold">Bold</option>
                        <option value="calm">Calm</option>
                    </select>
                    <button
                        id="generate-quote-btn"
                        data-action="generateQuote"
                        type="button"
                        class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded whitespace-nowrap"
                    >
                        Generate Quote
                    </button>
                </div>
            </div>

            <div id="quote-error" class="error text-sm hidden"></div>

            <div id="quote-result" class="bg-gray-100 dark:bg-gray-800 rounded p-3 md:p-4 space-y-3 border border-gray-200 dark:border-gray-700">
                <div class="flex items-start justify-between gap-3">
                    <div class="flex-1">
                        <div id="quote-text-display" class="text-lg font-medium text-gray-900 dark:text-white hidden"></div>
                        <textarea id="quote-edit" class="w-full bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm text-gray-900 dark:text-white" rows="4" placeholder="Enter your quote here or generate one above..."></textarea>
                        <!-- Primary actions row -->
                        <div class="flex gap-2 mt-2">
                            <button id="save-quote-btn" data-action="saveQuote" type="button" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded text-base font-medium text-white">Save</button>
                            <button id="cancel-quote-btn" data-action="cancelEdit" type="button" class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-base font-medium text-white hidden">Cancel</button>
                        </div>
                    </div>
                    <div class="flex flex-col gap-2 items-end">
                        <div id="regen-info" class="hidden md:block text-xs text-gray-400">Regens left: 10</div>
                        <div class="flex gap-2">
                            <button id="edit-quote-btn" data-action="editQuote" type="button" class="px-3 py-1 bg-gray-600 dark:bg-neutral-700 hover:bg-gray-700 dark:hover:bg-neutral-600 rounded text-sm text-white hidden">Edit</button>
                        </div>
                    </div>
                </div>
                <div id="quote-author" class="text-sm text-gray-400 hidden"></div>
                <div id="quote-tone-tag" class="text-xs text-blue-400 hidden"></div>
                
                <!-- Secondary actions row (less emphasis) -->
                <div id="remix-buttons" class="flex gap-2 mt-2">
                    <button id="regenerate-btn" data-action="regenerateQuote" type="button" class="px-3 py-1.5 border border-purple-600 dark:border-purple-500 text-purple-600 dark:text-purple-400 hover:bg-purple-50 dark:hover:bg-purple-900/20 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm">
                        Regenerate
                    </button>
                    <button id="rephrase-btn" data-action="rephraseQuote" type="button" class="px-3 py-1.5 border border-purple-600 dark:border-purple-500 text-purple-600 dark:text-purple-400 hover:bg-purple-50 dark:hover:bg-purple-900/20 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm">
                        Rephrase
                    </button>
                    <button id="tone-shift-btn" data-action="changeTone" type="button" class="px-3 py-1.5 border border-purple-600 dark:border-purple-500 text-purple-600 dark:text-purple-400 hover:bg-purple-50 dark:hover:bg-purple-900/20 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm">
                        Change Tone
                    </button>
                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Media Section -->
                <div class="accordion-section" data-mode="quotes">
                    <div class="accordion-header" data-section="media">
                        <div class="accordion-title">
                            <span class="accordion-icon">‚ñ∂</span>
                            <span class="accordion-label">Step 2 ‚Äì Background</span>
                        </div>
                        <div class="accordion-summary" id="media-summary">No background selected</div>
                    </div>
                    <div class="accordion-body" id="media-body">
                        <!-- Asset Selection Section -->
                        <div id="section-media" class="content-box bg-gray-50/80 dark:bg-slate-900/60 border border-gray-200/50 dark:border-white/5 rounded-2xl p-4 md:p-6 space-y-4 shadow-sm">
                            <div class="text-xs text-gray-400 dark:text-gray-500 mb-2">Step 2 ¬∑ Background</div>
                            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Background</h2>
            
            <!-- Asset Type Tabs -->
            <div class="flex gap-2">
                <button id="images-tab" data-action="setMediaTab" type="button" class="px-4 py-2 rounded bg-blue-600 text-white" data-type="images">
                    Images
                </button>
                <button id="videos-tab" data-action="setMediaTab" type="button" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white" data-type="videos">
                    Videos
                </button>
                <button id="ai-tab" class="px-4 py-2 rounded bg-gray-600 dark:bg-gray-700 text-white hidden" data-type="ai">
                    AI Images
                </button>
            </div>

            <!-- Remix Area -->
            <div id="remix-area" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-4 hidden border border-gray-200 dark:border-gray-700">
                <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Remix References (up to 2)</h3>
                <div id="remix-assets" class="flex gap-4">
                    <!-- Remix assets will be added here -->
                </div>
                <!-- AI result preview slot -->
                <div id="ai-result-block" class="mt-3 hidden">
                    <div class="flex flex-col items-center gap-2">
                        <div id="ai-ref-preview" class="flex gap-2 justify-center"></div>
                        <div id="ai-result-preview" class="relative w-full rounded overflow-hidden border border-gray-600 bg-black" style="aspect-ratio: 9/16;"></div>
                        <div class="mt-2">
                            <button id="ai-save-use-btn" class="px-3 py-1 bg-green-600 hover:bg-green-500 text-white text-xs rounded">Save & Use</button>
                        </div>
                    </div>
                </div>
                <!-- Inline AI prompt + style for ideogram remix -->
                <div class="mt-3 flex flex-wrap items-center gap-3">
                    <input
                        type="text"
                        id="ai-prompt"
                        value="A serene mountain landscape at sunset"
                        placeholder="Describe what to create from these references..."
                        class="flex-1 min-w-[16rem] bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-sm text-gray-900 dark:text-white"
                    />
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-400">Realistic</span>
                        <input type="range" id="ai-style-slider" min="0" max="1" step="0.1" value="0.5" class="w-24" />
                        <span class="text-xs text-gray-400">Creative</span>
                    </div>
                </div>
                <div class="mt-3 flex items-center gap-2">
                    <button
                        id="clear-remix-btn"
                        class="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-xs rounded"
                    >
                        Clear All
                    </button>
                    <button
                        id="remix-generate-btn"
                        class="px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded"
                        title="Generate a new AI image using the selected references"
                    >
                        20 Credits
                    </button>
                </div>
            </div>

            <!-- Search Controls -->
            <div id="search-controls" class="flex gap-4 items-center">
                <input
                    type="text"
                    id="asset-query"
                    value="nature"
                    placeholder="Search for images/videos..."
                    class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                />
                <button
                    id="search-assets-btn"
                    data-action="searchAssets"
                    type="button"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded text-white"
                >
                    Search
                </button>
                <button
                    id="upload-asset-btn"
                    class="px-3 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 rounded text-white"
                    title="Upload your own image or video"
                >
                    üìÅ
                </button>
                <input
                    type="file"
                    id="asset-upload-input"
                    accept="image/*,video/*"
                    class="hidden"
                />
            </div>

            <!-- AI Images Controls removed (inline controls are now in remix-area) -->
            <div id="ai-error" class="error text-sm hidden"></div>

            <div id="asset-error" class="error text-sm hidden"></div>

            <!-- Asset Grid (3 rows √ó 4 columns ‚âà 12 results) -->
            <div id="asset-grid" class="grid grid-cols-4 gap-4">
                <!-- Assets will be populated here -->
            </div>

            <!-- Pagination Controls -->
            <div id="pagination-container" class="flex justify-between items-center mt-4 hidden">
                <button
                    id="prev-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    ‚Üê Previous
                </button>
                <span id="page-info" class="text-sm text-gray-600 dark:text-gray-400">Page 1</span>
                <button
                    id="next-page-btn"
                    class="px-4 py-2 bg-gray-600 dark:bg-gray-700 hover:bg-gray-700 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:opacity-50 rounded flex items-center gap-2 text-white"
                >
                    Next ‚Üí
                </button>
            </div>

            <!-- Free Plan Notice -->
            <div id="free-notice" class="text-center text-sm text-gray-400 hidden">
                Showing 12 curated assets. 
                <span class="text-blue-400"> Upgrade to Pro</span> for larger pages and AI images.
            </div>
        </div>

        <!-- Caption Style Section (Hidden during transition) -->
        <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-6 space-y-4 border border-gray-200 dark:border-gray-600" style="display: none;">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Caption Style</h2>
            
            <!-- Overlay Mode Toggle -->
            <div class="mb-4">
                <label class="flex items-center gap-2">
                    <input type="checkbox" id="overlay-mode-toggle" class="rounded" />
                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Use Draggable Overlay</span>
                </label>
            </div>
            
            <!-- Overlay Controls (shown when overlay mode is enabled) -->
            <div id="overlay-controls" class="mb-4 space-y-3" style="display: none;">
                <div>
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="show-outline-toggle" class="rounded" checked />
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Show outline</span>
                    </label>
                </div>
                <div>
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="responsive-text-toggle" class="rounded" checked />
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Responsive text</span>
                    </label>
                </div>
            </div>
            
            
            
            <div class="grid grid-cols-2 gap-4">
                <!-- Font Family -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Font</label>
                    <select id="caption-font" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="system">System</option>
                        <option value="bold">Bold</option>
                        <option value="cinematic">Cinematic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                
                <!-- Font Weight -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Weight</label>
                    <select id="caption-weight" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                    </select>
                </div>
                
                <!-- Size -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Size: <span id="size-value">80px</span></label>
                    <input
                        type="range"
                        id="caption-size"
                        min="0"
                        max="100"
                        value="60"
                        class="w-full"
                    />
                </div>
                
                <!-- Opacity -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Opacity: <span id="opacity-value">80%</span></label>
                    <input
                        type="range"
                        id="caption-opacity"
                        min="30"
                        max="100"
                        value="80"
                        class="w-full"
                    />
                </div>
                
                <!-- Placement -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Placement</label>
                    <select id="caption-placement" class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                        <option value="top">Top</option>
                        <option value="middle">Middle</option>
                        <option value="bottom" selected>Bottom</option>
                    </select>
                </div>
                
                <!-- Background Box -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Background</label>
                    <div class="flex items-center gap-4">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="caption-background" class="rounded" />
                            <span class="text-sm">Show box</span>
                        </label>
                        <div class="flex-1">
                            <label class="block text-xs text-gray-400 mb-1">Box opacity: <span id="bg-opacity-value">50%</span></label>
                            <input
                                type="range"
                                id="caption-bg-opacity"
                                min="0"
                                max="100"
                                value="50"
                                class="w-full"
                            />
                        </div>
                    </div>
                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Voiceover Section -->
                <div class="accordion-section md:hidden">
                    <div class="accordion-header" data-section="voice">
                        <div class="accordion-title">
                            <span class="accordion-icon">‚ñ∂</span>
                            <span class="accordion-label">Step 3 ‚Äì Voiceover (optional)</span>
                        </div>
                        <div class="accordion-summary" id="voice-summary">No voice selected</div>
                    </div>
                    <div class="accordion-body" id="voice-body">
                        <!-- Voiceover Section -->
                        <div id="section-voice" class="content-box bg-gray-50/80 dark:bg-slate-900/60 border border-gray-200/50 dark:border-white/5 rounded-2xl p-4 md:p-6 space-y-4 shadow-sm">
                            <div class="text-xs text-gray-400 dark:text-gray-500 mb-2">Step 3 ¬∑ Voiceover</div>
                            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Voiceover</h2>
                            <p class="text-sm text-gray-600 dark:text-gray-400 leading-tight">Add AI voice if you want audio, or leave this empty for a silent image or video.</p>
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Voice</label>
                    <div class="flex gap-2">
                        <select id="voiceover-voice" class="flex-1 bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white">
                            <option value="">Loading voices...</option>
                        </select>
                        <button id="retry-voices-btn" onclick="loadVoices()" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm">
                            üîÑ
                        </button>
                    </div>
                </div>
                <div class="flex items-end gap-2">
                    <button
                        id="preview-voice-btn"
                        class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white"
                        disabled
                    >
                        Preview Voice
                    </button>
                    <audio id="voice-preview-audio" class="hidden" controls></audio>
                </div>
            </div>
            
            <!-- TTS Settings -->
            <div class="grid grid-cols-2 gap-4 mt-4" data-mode="quotes">
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Stability</label>
                    <input type="range" id="tts-stability" min="0" max="1" step="0.1" value="0.5" class="w-full">
                    <div class="text-xs text-gray-500 mt-1">Value: <span id="stability-value">0.5</span></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Similarity Boost</label>
                    <input type="range" id="tts-similarity" min="0" max="1" step="0.1" value="0.75" class="w-full">
                    <div class="text-xs text-gray-500 mt-1">Value: <span id="similarity-value">0.75</span></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Style</label>
                    <input type="range" id="tts-style" min="0" max="100" step="1" value="0" class="w-full">
                    <div class="text-xs text-gray-500 mt-1">Value: <span id="style-value">0</span></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Speaker Boost</label>
                    <input type="checkbox" id="tts-speaker-boost" checked class="rounded">
                    <div class="text-xs text-gray-500 mt-1">Enhance speaker characteristics</div>
                </div>
            </div>
            
                            <div id="voice-preview-status" class="text-sm text-gray-400 hidden"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Article Mode Section (full width on desktop) -->
            <div data-mode="articles" class="content-box bg-gray-50/80 dark:bg-slate-900/60 border border-gray-200/50 dark:border-white/5 rounded-2xl p-4 md:p-6 space-y-2 shadow-sm w-full md:col-span-2" style="display: none;">
                <div class="text-xs text-gray-400 dark:text-gray-500 mb-2">Step 1 ¬∑ Article explainer</div>
                <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Article Explainer</h2>
                <p class="text-sm text-gray-600 dark:text-gray-400 leading-tight">Paste an article link or text to create an explainer video.</p>
                
                <!-- Input Section -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Style</label>
                    <select
                        id="article-style-select"
                        class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                    >
                        <option value="default">Default (Explainer)</option>
                        <option value="hype">Hype</option>
                        <option value="cozy">Cozy</option>
                    </select>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Paste article link or text</label>
                    <textarea
                        id="article-input"
                        rows="4"
                        placeholder="Paste article URL or text here..."
                        class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                    ></textarea>
                    <button
                        id="summarize-article-btn"
                        data-action="summarizeArticle"
                        type="button"
                        class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 rounded text-white"
                    >
                        Summarize into script
                    </button>
                    <div id="article-error" class="error text-sm hidden"></div>
                </div>

                <!-- Script Preview Section -->
                <div id="article-script-section" class="space-y-2 mt-2">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Script Preview</label>
                    <p class="text-xs text-gray-500 dark:text-gray-400 leading-tight">Each line will become one clip.</p>
                    <textarea
                        id="article-script-preview"
                        rows="4"
                        placeholder="Script will appear here after summarization..."
                        class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                    ></textarea>
                </div>

                <!-- Prepare Storyboard Button -->
                <div class="mt-2 mb-1">
                    <button
                        id="prepare-storyboard-btn"
                        data-action="prepareStoryboard"
                        type="button"
                        class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:cursor-not-allowed rounded text-white"
                    >
                        Prepare storyboard
                    </button>
                </div>

                <!-- Storyboard Section -->
                <div id="storyboard" class="mt-2 hidden">
                    <div class="text-xs text-gray-400 dark:text-gray-500 mb-2">Step 2 ¬∑ Storyboard</div>
                    <h3 class="text-lg font-semibold mb-2 text-gray-900 dark:text-white">Storyboard</h3>
                    <div id="storyboard-row" class="flex gap-3 overflow-x-auto pb-2"></div>
                </div>

                <!-- Clip Picker Drawer -->
                <div id="clip-picker" class="mt-2 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg p-4 hidden max-h-[75vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-sm font-semibold text-gray-900 dark:text-white">Choose a clip for this line</h3>
                        <button id="clip-picker-close" class="text-xs text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white px-2 py-1">Close</button>
                    </div>
                    <div class="flex items-center gap-2 mb-3">
                        <input
                            id="clip-search-input"
                            type="text"
                            class="flex-1 px-2 py-1 rounded bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 text-sm text-gray-900 dark:text-white placeholder-gray-400"
                            placeholder="Search clips for this sentence..."
                        />
                        <button
                            id="clip-search-btn"
                            class="px-3 py-1 rounded bg-blue-600 hover:bg-blue-500 text-sm font-medium text-white"
                        >
                            Search
                        </button>
                    </div>
                    <div id="clip-picker-grid" class="grid grid-cols-2 md:grid-cols-4 gap-2 max-h-96 overflow-y-auto"></div>
                    <div id="clip-picker-pagination" class="flex justify-center items-center gap-2 mt-3 hidden">
                        <button
                            id="clip-picker-prev"
                            class="px-3 py-1 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm font-medium text-gray-900 dark:text-white disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            Previous
                        </button>
                        <button
                            id="clip-picker-more"
                            class="px-3 py-1 rounded bg-blue-600 hover:bg-blue-500 text-sm font-medium text-white disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            More clips
                        </button>
                    </div>
                </div>

                <!-- Voice Selection -->
                <div class="space-y-2 mt-2">
                    <div class="text-xs text-gray-400 dark:text-gray-500 mb-2">Step 3 ¬∑ Voice & render</div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Voice</label>
                    <select
                        id="article-voice-preset"
                        class="w-full bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded px-3 py-2 text-gray-900 dark:text-white"
                    >
                        <option value="male_calm">Neutral</option>
                        <option value="male_friendly">Warm</option>
                        <option value="male_energetic">Energetic</option>
                    </select>
                </div>

                <!-- Render Button -->
                <div class="mt-2">
                    <button
                        id="render-article-btn"
                        data-action="renderArticle"
                        type="button"
                        class="w-full px-6 py-3 bg-green-600 hover:bg-green-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-base font-semibold text-white shadow-md transition-colors"
                    >
                        Render video
                    </button>
                </div>

                <!-- Last Render Video Player -->
                <div id="article-render-result" class="mt-2 hidden">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Last render</h3>
                    <video
                        id="article-render-video"
                        controls
                        class="w-full rounded border border-gray-300 dark:border-gray-700"
                    ></video>
                    <div id="article-render-links" class="mt-2 space-y-1">
                        <a id="article-video-url" href="#" target="_blank" class="text-sm text-blue-600 dark:text-blue-400 hover:underline">Open video</a>
                    </div>
                </div>
            </div>

            <!-- Right: Preview Section -->
            <div class="studio-accordion-right order-3 md:order-1">
                <!-- Render Section -->
                <div class="content-box bg-white dark:bg-gray-800 rounded-lg p-4 md:p-6 space-y-4 border border-gray-200 dark:border-gray-600 w-full" data-mode="quotes">
                    <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Live Preview</h2>
            
            <!-- Caption Toolbar Container (docked) -->
            <div id="caption-toolbar-container" class="my-3 flex justify-center items-center flex-wrap gap-2 hidden">
                <!-- Toolbar will be inserted here by JS -->
            </div>
            
            <!-- Live Preview Canvas -->
            <div id="live-preview-container" class="opacity-0 transition-opacity duration-300" style="min-height: 400px; width: 360px;">
                <!-- Fix A: Give the preview wrapper a predictable size -->
                <div class="relative mx-auto bg-black rounded-lg overflow-hidden" style="width: 360px; aspect-ratio: 9 / 16;">
                    <canvas id="live-preview-canvas" class="w-full h-full block"></canvas>
                    <!-- One-Click status overlay -->
                    <div
                      id="one-click-status"
                      class="pointer-events-none absolute inset-0 z-40 flex items-center justify-center text-center px-4 text-sm sm:text-base font-semibold text-white bg-black/60 opacity-0 transition-opacity duration-200"
                      aria-hidden="true"
                    >
                      <span id="one-click-status-text"></span>
                    </div>
                    <!-- Legacy caption overlay (hidden when using new overlay system) -->
                    <img
                      id="caption-overlay"
                      class="absolute inset-0 pointer-events-none block w-full h-full"
                      style="z-index:2"
                    />
                    <!-- Hybrid preview layers for live text + PNG swap -->
                    <div id="caption-live" contenteditable="true" style="position:absolute; inset:0; pointer-events:auto; z-index:20; display:none; font-family: 'DejaVu Sans', sans-serif; color: white; text-align: center; padding: 24px; box-sizing: border-box;"></div>
                    <img id="preview-raster-img" alt="caption png" style="position:absolute; inset:0; pointer-events:none; z-index:10; display:none; object-fit: contain;" />
                    <!-- New draggable caption overlay container -->
                    <div id="stage" class="absolute inset-0 w-full h-full" style="z-index:3; display:none;">
                        <img id="previewMedia" class="w-full h-full object-cover" />
                    </div>
                    </div>
                </div>
                
                <!-- Mobile Toolbar (visible only on mobile) -->
                <div id="mobile-studio-toolbar" class="hidden w-full" data-mode="quotes">
                    <div class="flex items-center gap-2 w-full" style="max-width: 100%;">
                        <!-- Step Tabs -->
                        <button
                            id="mobile-tab-quote"
                            class="mobile-studio-tab flex-1 px-3 py-2 text-sm font-medium rounded-lg border transition-colors"
                            data-section="quote"
                        >
                            Quote
                        </button>
                        <button
                            id="mobile-tab-background"
                            class="mobile-studio-tab flex-1 px-3 py-2 text-sm font-medium rounded-lg border transition-colors"
                            data-section="media"
                        >
                            Background
                        </button>
                        <button
                            id="mobile-tab-voiceover"
                            class="mobile-studio-tab flex-1 px-3 py-2 text-sm font-medium rounded-lg border transition-colors"
                            data-section="voice"
                        >
                            Voiceover
                        </button>
                        <!-- Create Button -->
                        <button
                            id="mobile-create-btn"
                            class="px-4 py-2 bg-green-600 hover:bg-green-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-sm font-semibold text-white shadow-md transition-colors whitespace-nowrap"
                            title="Create your short"
                        >
                            Create
                        </button>
                        <!-- One-Click Short Button (Mobile) -->
                        <button
                            id="mobile-one-click-btn"
                            data-action="oneClickShort"
                            class="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-sm font-semibold text-white shadow-md transition-colors whitespace-nowrap"
                            title="One-click: Generate quote, find background, and render automatically"
                        >
                            One-Click
                        </button>
                    </div>
                </div>
                
                <!-- Helper text for empty preview -->
                <div id="preview-helper-text" class="mt-3 text-center text-sm text-gray-500 dark:text-gray-400 hidden">
                    Start by writing a quote, then choose an image or video background.
                </div>
                
                <!-- Render buttons below preview -->
                <div class="mt-4 flex flex-col items-center gap-3">
                    <!-- Preview Status Indicator -->
                    <div id="preview-status" class="hidden"></div>
                    
                    <!-- Action Buttons -->
                    <div class="flex gap-3" data-mode="quotes">
                        <!-- Create Button (combines Save Preview + Render) -->
                        <button
                            id="render-btn"
                            class="px-6 py-3 bg-green-600 hover:bg-green-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-base font-semibold text-white shadow-md transition-colors"
                            title="Create your short"
                        >
                            Create
                        </button>
                    </div>
                </div>
                
                <div id="render-preview" class="bg-gray-100 dark:bg-gray-800 rounded p-4 hidden border border-gray-200 dark:border-gray-700">
                    <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">Preview:</div>
                    <div id="preview-quote" class="text-lg font-medium mb-2 text-gray-900 dark:text-white"></div>
                    <div id="preview-asset" class="text-sm text-gray-600 dark:text-gray-400"></div>
                    <div id="preview-caption-style" class="text-sm text-gray-600 dark:text-gray-400"></div>
                    <div id="preview-voiceover" class="text-sm text-gray-600 dark:text-gray-400"></div>
                </div>
            </div>
            
            <!-- One-Click Short Button (reordered for mobile) -->
            <div class="order-2 md:order-3 md:col-start-2 flex justify-center md:justify-start md:hidden" data-mode="quotes">
                <button
                    id="one-click-btn"
                    data-action="oneClickShort"
                    class="px-6 py-3 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-400 disabled:cursor-not-allowed rounded-lg text-base font-semibold text-white shadow-md transition-colors w-full md:w-auto"
                    title="One-click: Generate quote, find background, and render automatically"
                >
                    One-Click Short
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { BACKEND as BACKEND_FROM_CONFIG } from '/config.js';

        const API_BASE_FALLBACK = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        // Hard-force the backend origin to Replit to avoid Netlify handling /cdn
        const API_BASE_FIXED = "https://17e0d1d1-e327-483d-b1ea-c41bea08fb59-00-1ef93t84nlhq6.janeway.replit.dev";
        function getApiBase(){
            return API_BASE_FIXED.replace(/\/$/, '');
        }

        // --- Simple mobile mode detection ---
        function isSimpleMobile() {
            return window.innerWidth <= 768 || window.matchMedia('(pointer: coarse)').matches;
        }
        window.isSimpleMobile = isSimpleMobile;

        // --- Helper to mark desktop-only elements as hidden ---
        function markDesktopOnly(el, description) {
            if (el) {
                el.style.display = 'none';
                console.log('[simple-mobile] hiding desktop-only element:', description);
            }
        }

        // --- Auth ready (wait for Firebase to finish initializing exactly once) ---
        window.__authReady = window.__authReady || new Promise((resolve) => {
          try {
            // If firebase auth is already available, attach listener; otherwise poll briefly
            const attach = () => {
              if (window.firebase && window.firebase.auth) {
                window.firebase.auth().onAuthStateChanged((user) => {
                  window.__currentUser = user || null;
                  resolve(user || null);
                });
                return true;
              }
              return false;
            };
            if (!attach()) {
              const t = setInterval(() => {
                if (attach()) clearInterval(t);
              }, 50);
              setTimeout(() => { clearInterval(t); resolve(null); }, 5000); // worst-case resolve
            }
          } catch {
            resolve(null);
          }
        });

        // --- Caption sizing constants (HOISTED) ---
        const UI_MIN_PX = 48;     // slider min visual (increased to prevent text disappearing)
        const UI_MID_PX = 72;     // slider mid visual (more reasonable middle)
        const UI_MAX_PX = 120;    // slider max visual (capped to prevent overflow)
        const API_MIN_PX = 32;    // backend clamp lower bound
        const API_MAX_PX = 120;   // backend clamp upper bound (match server ABS_MAX_FONT)

        // --- Caption size mapping (define BEFORE any usage)
        function mapSliderToPx(sliderVal) {
          // non-linear map slider value to pixel range, then clamp to API bounds
          const raw = Number(sliderVal);
          
          if (!isFinite(raw)) {
            return API_MIN_PX + (API_MAX_PX - API_MIN_PX) / 2; // fallback to middle
          }
          
          const v = Math.max(0, Math.min(100, raw));
          const t = v / 100;
          // Non-linear mapping: size = 32 + (120-32)*Math.pow(t,0.6)
          const size = API_MIN_PX + (API_MAX_PX - API_MIN_PX) * Math.pow(t, 0.6);
          
          return Math.max(API_MIN_PX, Math.min(API_MAX_PX, Math.round(size)));
        }

        function getCaptionPx() {
            const el = document.getElementById('caption-size');
            return mapSliderToPx(el ? el.value : 50);
        }
        
        // Font size clamping to prevent overflow with binary search for better responsiveness
        function fitFontPx(targetFontPx, text, W = 1080, H = 1920) {
            const min = 24, max = 160;
            const padPctTop = 0.08, padPctBottom = 0.08;
            const maxWidthPct = 0.90; // increased from 0.85
            const lineHeight = 1.05; // reduced from 1.1
            const maxTextWidth = W * maxWidthPct;
            const maxTextHeight = H * (1 - padPctTop - padPctBottom);
            
            function measureFits(fontPx) {
                // Simple word wrapping simulation
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine ? `${currentLine} ${word}` : word;
                    // Rough width estimation (fontPx * 0.6 is approximate)
                    const estimatedWidth = testLine.length * fontPx * 0.6;
                    
                    if (estimatedWidth <= maxTextWidth && currentLine) {
                        currentLine = testLine;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                const totalHeight = lines.length * fontPx * lineHeight;
                return totalHeight <= maxTextHeight;
            }
            
            let lo = min, hi = Math.min(max, targetFontPx), best = lo;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1; // binary search
                if (measureFits(mid)) { 
                    best = mid; 
                    lo = mid + 1; 
                } else { 
                    hi = mid - 1; 
                }
            }
            
            if (best !== targetFontPx) {
                console.log(`[caption] Font size ${targetFontPx}px fitted to ${best}px for better responsiveness`);
            }
            
            return best;
        }

        // Fix D: Preview geometry helper using proper CSS/backing separation
        function getPreviewGeometry(canvas) {
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const cssW = canvas.clientWidth;  // CSS size
            const cssH = canvas.clientHeight; // CSS size
            const backingW = canvas.width;    // Backing store size
            const backingH = canvas.height;   // Backing store size
            const scaleX = cssW / 1080; // CSS size to PNG native size
            const scaleY = cssH / 1920;
            
            return { dpr, cssW, cssH, backingW, backingH, scaleX, scaleY };
        }

        // expose for other code
          window.getCaptionPx = getCaptionPx;
        window.__captionSizeMapping = { mapSliderToPx, API_MIN_PX, API_MAX_PX, UI_MIN_PX, UI_MID_PX, UI_MAX_PX };

        // --- Auth-aware login warning function ---
        async function ensureLoggedInOrWarn() {
          const warnEl = document.getElementById('asset-error'); // the red text element
          if (!warnEl) return true; // nothing to do
          const user = await window.__authReady;
          const isLoggedIn = !!user;
          if (isLoggedIn) {
            warnEl.style.display = 'none'; // hide when logged in
          }
          return isLoggedIn;
        }

        // --- Helper to get active asset type ---
        function getActiveAssetType() {
          const activeTab = document.querySelector('[data-type].bg-blue-600') ||
                            document.querySelector('[data-type]');
          return activeTab?.dataset.type || 'images'; // fallback to images (default tab)
        }

        // --- High-quality Pexels preview URL helper ---
        function bestPexelsPreviewUrl(photo, targetWidth = 720, targetHeight = 1280) {
          if (!photo || !photo.src) return null;
          
          const src = photo.src;
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
          
          // Prefer portrait, then large2x, then large, fallback to original/medium
          let baseUrl = src.portrait || src.large2x || src.large || src.original || src.medium;
          
          if (!baseUrl) return null;
          
          // Add Pexels optimization parameters for high-quality preview
          const params = new URLSearchParams({
            auto: 'compress',
            cs: 'tinysrgb',
            dpr: dpr.toString(),
            fit: 'crop',
            w: targetWidth.toString(),
            h: targetHeight.toString()
          });
          
          return `${baseUrl}?${params.toString()}`;
        }

        // === Pexels Preview Quality + Trace Helpers ===
        function _isHiResPreviewUrl(url) {
          if (!url) return false;
          // Must NOT be just h=350; should include fit=crop and explicit w/h and dpr
          return /fit=crop/.test(url) && /[?&]w=\d+/.test(url) && /[?&]h=\d+/.test(url);
        }
        
        function _pexelsPreviewUrlFromPhoto(photo, needW, needH, headroom = 1.2) {
          const base =
            (photo?.src?.portrait) ||
            (photo?.src?.large2x) ||
            (photo?.src?.large) ||
            (photo?.src?.original) ||
            (photo?.src?.medium);
          if (!base) return null;
          const join = base.includes('?') ? '&' : '?';
          const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
          const w = Math.ceil(needW * headroom);
          const h = Math.ceil(needH * headroom);
          return `${base}${join}auto=compress&cs=tinysrgb&fit=crop&dpr=${dpr}&w=${w}&h=${h}`;
        }
        
        // Fix B: Updated HiDPI canvas setup using sizeCanvasToCSS
        function _setupHiDPICanvas(canvas, cssW, cssH) {
          // Use the new sizing function
          if (!sizeCanvasToCSS(canvas)) {
            // Fallback to manual setup if sizeCanvasToCSS fails
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width  = Math.round(cssW * dpr);
            canvas.height = Math.round(cssH * dpr);
            canvas.style.width  = `${cssW}px`;
            canvas.style.height = `${cssH}px`;
          }
          
          const ctx = canvas.getContext('2d');
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          return { ctx, dpr };
        }
        
        // Visual breadcrumb on the canvas so we know who drew last
        const DEBUG_CANVAS = false;
        function _tapCanvas(label) {
          if (!DEBUG_CANVAS) return;
          try {
            const c = document.getElementById('live-preview-canvas');
            if (!c) return;
            const x = c.getContext('2d');
            x.save();
            x.font = '12px system-ui';
            x.fillStyle = 'rgba(255,255,255,.95)';
            x.strokeStyle = 'rgba(0,0,0,.6)';
            x.strokeText(label, 8, 18);
            x.fillText(label, 8, 18);
            x.restore();
          } catch {}
        }

        // Legacy function - now calls the new helper
        function pexelsPreviewUrl(photo, needW, needH, headroom = 1.2) {
          return _pexelsPreviewUrlFromPhoto(photo, needW, needH, headroom);
        }

        // --- Pexels hi-res intercept helpers (preview-only) ---
        function _buildHiResPexelsUrlFromBase(baseUrl, needW, needH) {
          try {
            const u = new URL(baseUrl);
            if (u.hostname !== 'images.pexels.com') return baseUrl;
            // We always prefer fit=crop + explicit w/h + dpr
            const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
            u.searchParams.set('auto', 'compress');
            u.searchParams.set('cs', 'tinysrgb');
            u.searchParams.set('fit', 'crop');
            u.searchParams.set('dpr', String(dpr));
            u.searchParams.set('w', String(Math.ceil(needW * 1.2)));
            u.searchParams.set('h', String(Math.ceil(needH * 1.2)));
            // remove stray h=350 if present
            return u.toString();
          } catch { return baseUrl; }
        }

        // Given whatever the app thinks is the preview URL, ensure it is hi-res for the canvas draw.
        function _ensureHiResPreviewUrl(rawUrl, canvas) {
          if (!rawUrl) return rawUrl;
          const needW = canvas.width || canvas.clientWidth;
          const needH = canvas.height || canvas.clientHeight;
          return _buildHiResPexelsUrlFromBase(rawUrl, needW, needH);
        }

        // Fix A: Use predictable wrapper dimensions
        function layoutPreviewDims() {
          const box = document.querySelector('#live-preview-container .relative');
          if (box) {
            // Use the fixed wrapper dimensions
            const cssW = box.clientWidth || 360; // fallback to our fixed width
            const cssH = Math.round(cssW * 16 / 9); // lock to 9:16 portrait
            return { cssW, cssH };
          }
          // Fallback to default dimensions
          return { cssW: 360, cssH: 640 };
        }

        function drawCover(ctx, img, cssW, cssH) {
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.max(cssW / iw, cssH / ih); // COVER (fill + crop)
          const dw = iw * scale, dh = ih * scale;
          const dx = (cssW - dw) / 2, dy = (cssH - dh) / 2;
          ctx.clearRect(0, 0, cssW, cssH);
          ctx.drawImage(img, dx, dy, dw, dh);
        }

        function setupHiDPICanvas(canvas, cssW, cssH) {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          canvas.width  = Math.round(cssW * dpr);
          canvas.height = Math.round(cssH * dpr);
          canvas.style.width  = `${cssW}px`;
          canvas.style.height = `${cssH}px`;
          const ctx = canvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          return { ctx, dpr };
        }

        // --- High-quality canvas drawing helper with HiDPI support ---
        function drawPreviewOnCanvas(canvas, ctx, img, targetWidth = 400, targetHeight = 711) {
          const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
          
          // Set up HiDPI canvas
          canvas.width = targetWidth * dpr;
          canvas.height = targetHeight * dpr;
          canvas.style.width = `${targetWidth}px`;
          canvas.style.height = `${targetHeight}px`;
          
          // Enable high-quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // Set transform for HiDPI
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          
          // Calculate cover-fit dimensions (fill canvas without distortion)
          const imgAspect = img.naturalWidth / img.naturalHeight;
          const canvasAspect = targetWidth / targetHeight;
          
          let drawWidth, drawHeight, drawX, drawY;
          
          if (imgAspect > canvasAspect) {
            // Image is wider - fit height, crop width
            drawHeight = targetHeight;
            drawWidth = drawHeight * imgAspect;
            drawX = (targetWidth - drawWidth) / 2;
            drawY = 0;
          } else {
            // Image is taller - fit width, crop height
            drawWidth = targetWidth;
            drawHeight = drawWidth / imgAspect;
            drawX = 0;
            drawY = (targetHeight - drawHeight) / 2;
          }
          
          // Draw the image with cover-fit
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        // --- Race protection for preview loading ---
        let _previewReqId = 0;
        let _currentPexelsPhoto = null; // Track current photo for resize re-rendering

        async function _drawBackground(url, canvas, cssW, cssH, who='drawBackground') {
          const my = ++_previewReqId;
          const startTime = performance.now();
          console.log('[asset-load] Starting background load:', { url: url.substring(0, 50), who, my });
          
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.decoding = 'async';
          img.src = url;
          await img.decode();
          if (my !== _previewReqId) return;
          
          const loadTime = performance.now() - startTime;
          console.log('[asset-load] Background loaded:', { 
            duration: Math.round(loadTime), 
            naturalWidth: img.naturalWidth, 
            naturalHeight: img.naturalHeight,
            who, my 
          });
          
          const ctx = canvas.getContext('2d');
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.max(cssW/iw, cssH/ih);
          const dw = iw*scale, dh = ih*scale;
          const dx = (cssW - dw)/2, dy = (cssH - dh)/2;
          ctx.clearRect(0,0,cssW,cssH);
          ctx.drawImage(img, dx, dy, dw, dh);
          
          console.log('[asset-load] First drawImage completed:', { 
            duration: Math.round(performance.now() - startTime),
            canvasSize: `${cssW}x${cssH}`,
            imageSize: `${iw}x${ih}`,
            drawSize: `${dw}x${dh}`,
            who, my 
          });
          window._currentPreviewUrl = url;
          _tapCanvas(`${who}`);
        }

        // --- Debounced caption overlay refresh (prevents blocking assets) ---
        let overlayRefreshTimer = null;
        function queueCaptionOverlayRefresh() {
          // Legacy function - no longer used in overlay mode
          if (overlayRefreshTimer) clearTimeout(overlayRefreshTimer);
          overlayRefreshTimer = setTimeout(() => {
            try {
              // Call existing caption overlay update function
              if (typeof updateCaptionOverlay === 'function' && currentQuote?.text) {
                updateCaptionOverlay(currentQuote.text.trim(), true);
              }
            } catch (e) {
              console.warn('[caption-overlay] preview failed (non-fatal)', e);
            }
          }, 120); // 120ms debounce to reduce server load
        }

        // Safe placeholder if real loader is attached later
        window.loadVoices = window.loadVoices || (async function () {
          console.debug('[voice] loadVoices placeholder (no-op)');
          // If you have a real loader like populateVoicesDropdown(), call it here instead:
          // return populateVoicesDropdown();
        });

        // Helper for clearer logging
        window.__log = (...args) => console.log('[assets]', ...args);

        // Global state
        let currentLimits = null;
        let currentQuote = null;
        let selectedAsset = null;
        let currentStorySessionId = null;
        let currentStoryUrl = null;
        // SSOT: Use window scope so ui-actions.js can update it
        window.currentAssetType = window.currentAssetType || 'images';

        // Mode switching SSOT function
        window.setStudioMode = function(mode) {
            document.querySelectorAll('[data-mode]').forEach(el => {
                el.style.display = el.dataset.mode === mode ? '' : 'none';
            });
            window.currentStudioMode = mode; // optional, handy for debugging
            
            // Update tab styles
            const quotesTab = document.getElementById('mode-quotes-tab');
            const articlesTab = document.getElementById('mode-articles-tab');
            if (quotesTab && articlesTab) {
                if (mode === 'quotes') {
                    quotesTab.classList.remove('bg-gray-600', 'dark:bg-gray-700');
                    quotesTab.classList.add('bg-blue-600');
                    articlesTab.classList.remove('bg-blue-600');
                    articlesTab.classList.add('bg-gray-600', 'dark:bg-gray-700');
                } else {
                    articlesTab.classList.remove('bg-gray-600', 'dark:bg-gray-700');
                    articlesTab.classList.add('bg-blue-600');
                    quotesTab.classList.remove('bg-blue-600');
                    quotesTab.classList.add('bg-gray-600', 'dark:bg-gray-700');
                }
            }
        };
        let currentAssetPage = 1;
        let hasMoreAssets = false;
        let currentCredits = 0;
        let remixAssets = [];
        let assetCache = new Map(); // Cache for pagination
        let uploadedAssets = [];
        let availableVoices = [];
        let currentVoiceId = null;

        // Helper functions - PNG overlay system
        let captionOverlayState = null;
        let captionDebounceTimer = null;
        
        // New draggable overlay system
        let overlaySystemInitialized = false;
        let useOverlayMode = true; // Default to overlay mode as SSOT (V3 raster)
        
        // ‚úÖ Clear legacy V2 cache to prevent schema mixing
        try {
            const v2Keys = ['overlayMetaV2', 'overlayMeta', 'lastCaptionOverlay'];
            v2Keys.forEach(key => {
                const stored = localStorage.getItem(key);
                if (stored) {
                    const meta = JSON.parse(stored);
                    if (meta.ssotVersion !== 3) {
                        console.log('[v3:cleanup] Removing legacy V2 cache:', key);
                        localStorage.removeItem(key);
                    }
                }
            });
        } catch (e) {
            console.warn('[v3:cleanup] Cache cleanup failed:', e);
        }

        // Helper functions for overlay management
        const must = (sel) => {
            const el = typeof sel === 'string' ? document.querySelector(sel) : sel;
            if (!el) throw new Error('MISSING_EL: ' + sel);
            return el;
        };

        const canOverlay = () => useOverlayMode && overlaySystemInitialized;

        function setQuoteUI(text) {
            const out = document.querySelector('#quote-result');
            if (out) out.textContent = text;
        }

        async function maybeUpdateOverlay(text, force = true) {
            try {
                await ensureOverlayActive();
                if (canOverlay()) {
                    await updateOverlayCaption(text.trim(), force);
                } else {
                    setQuoteUI(text);
                }
            } catch (e) {
                console.warn('[overlay] fallback to text-only UI', e);
                setQuoteUI(text);
            }
        }

        // Ensure overlay is active and initialized
        async function ensureOverlayActive() {
            try {
                useOverlayMode = true;
                const chk = document.getElementById('overlay-mode-toggle');
                if (chk && !chk.checked) chk.checked = true;
                if (!overlaySystemInitialized) {
                    await initOverlaySystem();
                }
                // Apply current quote text into overlay and refresh background
                if (currentQuote?.text) {
                    try { const { setQuote } = await import('./js/caption-overlay.js');
                      setQuote(currentQuote.text.trim());
                      console.log('[overlay-caption] set:', currentQuote.text.trim().substring(0,80));
                    } catch {}
                }
                if (typeof updateOverlayCanvasBackground === 'function') updateOverlayCanvasBackground();
                // Reflect UI: show stage, hide legacy image
                const stage = document.getElementById('stage');
                const legacyOverlay = document.getElementById('caption-overlay');
                if (stage) {
                    stage.style.display = 'block';
                    // Ensure stage has minimum height and black background when no media
                    if (!selectedAsset) {
                        stage.style.minHeight = '400px';
                        stage.style.backgroundColor = '#000';
                        const previewMedia = document.getElementById('previewMedia');
                        if (previewMedia) {
                            previewMedia.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
                            previewMedia.style.display = 'block';
                        }
                    }
                }
                if (legacyOverlay) legacyOverlay.style.display = 'none';
                
                // Unhide container if there's a quote
                if (currentQuote?.text) {
                    const container = document.getElementById('live-preview-container');
                    if (container) {
                        container.classList.remove('opacity-0');
                        // Only set inline opacity if style is currently empty (to not override transitions)
                        if (!container.style.opacity) {
                            container.style.opacity = '1';
                        }
                        // Force layout recalculation on mobile
                        void container.offsetHeight;
                    }
                }
                
                console.log('[overlay] ensureOverlayActive: stage visible, hasMedia:', !!selectedAsset);
            } catch (e) { console.warn('[overlay] ensureOverlayActive failed', e); }
        }
        
        // Debounced caption preview generator
        function debouncedPreview(delay = 200) {
            // Legacy function - no longer used in overlay mode
            clearTimeout(captionDebounceTimer);
            captionDebounceTimer = setTimeout(() => {
                if (currentQuote?.text?.trim()) {
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            }, delay);
        }
        
        function maybeGenerateCaptionPreview() {
            const txt = currentQuote?.text?.trim() || '';
            if (txt.length && selectedAsset) {
                debouncedPreview();
            }
        }
        
        async function updateCaptionOverlay(text = '', show = true) {
            // Legacy function - use maybeUpdateOverlay instead for new overlay system
            console.log('[preview-init] updateCaptionOverlay called with:', { text: text?.substring(0, 50), show });
            
            // Unhide container when showing a quote
            if (show === true) {
                const container = document.getElementById('live-preview-container');
                if (container) {
                    container.classList.remove('opacity-0');
                    // Only set inline opacity if style is currently empty (to not override transitions)
                    if (!container.style.opacity) {
                        container.style.opacity = '1';
                    }
                    // Force layout recalculation on mobile
                    void container.offsetHeight;
                }
            }
            
            const overlay = document.getElementById('caption-overlay');
            if (!overlay) return;
            
            // Ensure container is visible and has a size before drawing
            const container = document.getElementById('live-preview-container');
            if (!container) return;
            
            // Fallback gate: Don't proceed if container is effectively hidden (but allow opacity-0 if has dimensions)
            if (container.offsetParent === null) {
                console.log('[preview-init] Container not visible, skipping caption overlay');
                return;
            }
            
            // If container has opacity-0 but has dimensions, proceed (will be made visible)
            if (container.classList.contains('opacity-0')) {
                console.log('[preview-init] Container has opacity-0 but has dimensions, proceeding...');
            }
            
            container.classList.remove('opacity-0');
            
            // Log container dimensions
            const containerRect = container.getBoundingClientRect();
            console.log('[preview-init] container dimensions:', { 
                cssW: containerRect.width, 
                cssH: containerRect.height, 
                dpr: window.devicePixelRatio 
            });
            
            // New canvas ready logic with feature flag
            if (window.__PREVIEW_FIX__) {
                const canvas = document.getElementById('live-preview-canvas');
                if (!canvas || !canvasReadyState.ready) {
                    console.log('[canvas-ready] Canvas not ready, scheduling render');
                    scheduleRender();
                    return;
                }
            } else {
                // Legacy logic for fallback
                const ensureSized = () =>
                    (container.clientWidth > 0 && container.clientHeight > 0) ? true : false;
                if (!ensureSized()) {
                    await new Promise(requestAnimationFrame);
                }
                if (!ensureSized()) {
                    console.warn('[caption-overlay] Container still has no size, skipping overlay');
                    return;
                }
                
                const canvas = document.getElementById('live-preview-canvas');
                if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                    console.log('[canvas-ready] Canvas not ready, scheduling retry...', {
                        canvasExists: !!canvas,
                        clientWidth: canvas?.clientWidth,
                        clientHeight: canvas?.clientHeight,
                        canvasWidth: canvas?.width,
                        canvasHeight: canvas?.height
                    });
                    // Two RAF deferral as suggested
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    const retryCanvas = document.getElementById('live-preview-canvas');
                    if (!retryCanvas || retryCanvas.clientWidth === 0 || retryCanvas.clientHeight === 0) {
                        console.warn('[canvas-ready] Canvas still not ready after deferral, skipping overlay');
                        return;
                    }
                }
            }
            
            // Clear existing overlay
            overlay.innerHTML = '';
            
            if (!show || !text?.trim()) {
                captionOverlayState = null;
                return;
            }

            // Get caption style parameters from UI
            const sizePx = 54; // Default - will be overridden by server SSOT
            const opacityPct = parseInt(document.getElementById('caption-opacity')?.value || '85', 10);
            const placement = (document.getElementById('caption-placement')?.value || 'bottom').toLowerCase();
            const showBoxToggle = document.getElementById('caption-background')?.checked || false;
            const boxOpacityPct = parseInt(document.getElementById('caption-bg-opacity')?.value || '50', 10);
            const selectedWeight = document.getElementById('caption-weight')?.value || 'bold';
            
            console.log('[preview-scaling]', { 
                mappedSizePx: sizePx
            });

            // Map UI selection to server placement format
            function placementToServerFormat(placement) {
                switch ((placement || 'bottom').toLowerCase()) {
                    case 'top':    return { placement: 'top' };
                    case 'middle': 
                    case 'center': return { placement: 'center' };
                    case 'bottom': 
                    default:       return { placement: 'bottom' };
                }
            }
            
            // Validate yPct to prevent extreme values
            function validateYPct(yPct) {
                const clamped = Math.max(0.05, Math.min(0.95, Number(yPct)));
                if (clamped !== Number(yPct)) {
                    console.warn(`[caption] yPct ${yPct} clamped to ${clamped} to prevent off-screen positioning`);
                }
                return clamped;
            }
            
            const placementData = placementToServerFormat(placement);
            
            console.log('[caption-debug] Placement mapping:', {
                uiPlacement: placement,
                serverPlacement: placementData.placement
            });
            
            // Map UI font selection to server font names (only use registered fonts)
            const fontMapping = {
                'system': { family: 'DejaVu Sans', weightCss: 'normal' },
                'bold': { family: 'DejaVu Sans', weightCss: 'bold' },
                'cinematic': { family: 'DejaVu Sans', weightCss: 'bold' }, // Fallback to DejaVu until we add more fonts
                'minimal': { family: 'DejaVu Sans', weightCss: 'normal' }
            };
            
            const selectedFont = document.getElementById('caption-font')?.value || 'system';
            const fontConfig = fontMapping[selectedFont] || fontMapping['system'];
            
            const captionStyle = {
                text: text.trim(),
                fontFamily: fontConfig.family,
                weightCss: fontConfig.weightCss,
                fontPx: sizePx, // Use fitted size
                color: "#FFFFFF",
                opacity: opacityPct / 100,
                shadow: true,
                showBox: showBoxToggle,
                boxColor: `rgba(0,0,0,${boxOpacityPct/100})`,
                placement: placementData.placement,
                yPct: placementData.placement === 'bottom' ? 0.90 : placementData.placement === 'top' ? 0.10 : 0.50, // Set yPct based on placement
                lineHeight: 1.05, // reduced for better stacking
                padding: 24,
                maxWidthPct: 0.90, // increased for bigger text
                borderRadius: 16
            };
            
            console.log('[caption-debug] Final captionStyle:', {
                placement: captionStyle.placement,
                yPct: captionStyle.yPct,
                text: captionStyle.text.substring(0, 50) + '...'
            });

            // Debounce caption generation
            clearTimeout(captionDebounceTimer);
            captionDebounceTimer = setTimeout(async () => {
                try {
                    // If draggable overlay mode is on, apply styles to overlay and skip legacy PNG path
                    if (useOverlayMode) {
                        try {
                            const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js');
                            
                            // Check if overlay is initialized before using getCaptionMeta
                            if (typeof window.getCaptionMeta !== 'function') {
                                console.warn('[overlay-style] Overlay not initialized yet, skipping style update');
                                return; // Skip style update, will retry after initialization
                            }
                            
                            const meta = getCaptionMeta && getCaptionMeta();
                            if (meta) {
                                // Update overlay style based on current UI controls
                                meta.fontPx = captionStyle.fontPx;
                                meta.fontFamily = captionStyle.fontFamily;
                                meta.weightCss = captionStyle.weightCss || captionStyle.weight;
                                meta.color = '#FFFFFF';
                                meta.opacity = captionStyle.opacity;
                                
                                if (applyCaptionMeta) {
                                    applyCaptionMeta(meta);
                                } else {
                                    console.warn('[overlay-style] applyCaptionMeta not available');
                                }
                            } else {
                                console.warn('[overlay-style] getCaptionMeta returned null, overlay may not be initialized');
                            }
                            // Keep the stage background in sync with the canvas
                            if (typeof updateOverlayCanvasBackground === 'function') updateOverlayCanvasBackground();
                        } catch (e) {
                            console.warn('[overlay-style] apply failed; falling back to legacy preview', e);
                        }
                        return; // Do not generate PNG while overlay mode is active
                    }

                    console.log('[caption-overlay] Generating PNG preview...');
                    
                    // Ensure preview container is visible before generating overlay
                    document.getElementById('live-preview-container')?.classList.remove('opacity-0');
                    
                    // Import the caption preview function
                    const { generateCaptionPreview, getLastCaptionPNG, createCaptionOverlay } = await import('./js/caption-preview.js');
                    
                    // Import the new draggable overlay system
                    const { initCaptionOverlay, getCaptionMeta, applyCaptionMeta, setQuote } = await import('./js/caption-overlay.js');
                    
                    // Build proper payload with all controls wired
                    const payload = buildCaptionPayload(text, captionStyle);
                    
                    // Generate caption PNG with new payload
                    await generateCaptionPreview(payload);
                    const result = getLastCaptionPNG();
                    captionOverlayState = result;
                    
                    console.log('[apply-font] Caption style applied:', {
                        fontFamily: payload.fontFamily,
                        weight: payload.weight,
                        fontPx: payload.fontPx,
                        opacity: payload.opacity,
                        placement: payload.placement
                    });
                    
                    console.log('[caption-overlay] meta:', {
                        fontPx: result?.meta?.fontPx,
                        lineSpacing: result?.meta?.lineSpacing,
                        yPct: result?.meta?.yPct,
                        placement: result?.meta?.placement,
                        fontFamilyUsed: result?.meta?.fontFamilyUsed,
                        wPx: result?.meta?.wPx,
                        hPx: result?.meta?.hPx
                    });
                    
                    console.log('[caption-overlay] PNG preview generated:', result);
                    
                    // Calculate preview scaling using geometry helper
                    const previewContainer = document.getElementById('live-preview-container');
                    const previewCanvas = document.getElementById('live-preview-canvas');
                    const geometry = getPreviewGeometry(previewCanvas);
                    
                    // Debug logging for scaling
                    console.debug('[preview-scaling]', {
                        cssW: geometry.cssW,
                        cssH: geometry.cssH,
                        backingW: geometry.backingW,
                        backingH: geometry.backingH,
                        dpr: geometry.dpr,
                        scaleX: geometry.scaleX,
                        scaleY: geometry.scaleY,
                        ovW: result.meta?.wPx || 1080,
                        ovH: result.meta?.hPx || 1920,
                        placement: captionStyle.placement,
                        yPct: result.meta?.yPct,
                        fontPx: result.meta?.fontPx
                    });
                    
                    // If overlay mode is inactive, render legacy PNG overlay image
                    try {
                        if (!useOverlayMode) {
                            createCaptionOverlay(result, overlay, { 
                                previewW: geometry.cssW, 
                                previewH: geometry.cssH,
                                placement: captionStyle.placement
                            });
                        }
                    } catch {}
                    
                    // Debug logging
                    console.log('[preview-scaling]', { 
                        previewW: geometry.cssW, 
                        previewH: geometry.cssH 
                    });
                    
                    console.log('[caption-overlay] PNG overlay created successfully');
                    
                    // Log font fallback info if available
                    if (result.meta?.fontFamilyUsed) {
                        console.log('[caption-overlay] Font used:', result.meta.fontFamilyUsed);
                    }
                    
                } catch (error) {
                    console.error('[caption-overlay] Failed to generate PNG:', error);
                    console.error('[caption-overlay] Error details:', error.message);
                    
                    // TASK 7: Disable HTML fallback to prevent mega-sized text issues
                    // The fallback was causing the "yo" situation mentioned in the task
                    console.log('[caption-overlay] PNG generation failed, not using HTML fallback');
                    overlay.innerHTML = ''; // Clear overlay instead of showing fallback text
                }
            }, 300); // 300ms debounce
        }
        
        // New draggable overlay system functions
        async function initOverlaySystem() {
            if (overlaySystemInitialized) return;
            
            try {
                const { initCaptionOverlay, getCaptionMeta, applyCaptionMeta, setQuote, ensureOverlayTopAndVisible, bindCaptionDrag } = await import('./js/caption-overlay.js');
                
                // Ensure stage is visible before initializing overlay
                const stage = document.querySelector('#stage');
                if (stage) {
                    stage.style.display = 'block';
                    stage.style.minHeight = '400px';
                    stage.style.backgroundColor = '#000';
                }
                
                // Initialize the overlay system
                initCaptionOverlay({ stageSel: '#stage', mediaSel: '#previewMedia' });
                
                // Set default caption box geometry if not already set
                if (!window.__overlayMeta || !window.__overlayMeta.wPct) {
                    const stage = document.querySelector('#stage');
                    const w = stage?.clientWidth || 360;
                    const h = stage?.clientHeight || 640;
                    
                    // Default box ~88% width, readable font, near top (SSOT: decimal fractions 0-1)
                    const defaultMeta = {
                        text: (currentQuote?.text || '').trim(),
                        xPct: 0.04,              // 4% left margin (decimal)
                        yPct: 0.10,              // 10% from top (decimal)
                        wPct: 0.88,              // 88% of stage width (decimal)
                        fontFamily: 'Inter, system-ui, sans-serif',
                        weightCss: '700',
                        fontPx: Math.max(28, Math.min(96, Math.round(h * 0.08))),
                        color: '#FFFFFF',
                        opacity: 1,
                        textAlign: 'center',
                        paddingPx: 12,
                    };
                    
                    try {
                        applyCaptionMeta(defaultMeta);
                        window.__overlayMeta = { ...defaultMeta, ...getCaptionMeta() };
                        console.log('[overlay-default] applied:', { wPct: defaultMeta.wPct, xPct: defaultMeta.xPct, yPct: defaultMeta.yPct, fontPx: defaultMeta.fontPx });
                    } catch (e) {
                        console.warn('[overlay-system] Failed to apply default meta:', e);
                    }
                }
                
                try { ensureOverlayTopAndVisible('#stage'); } catch {}
                
                // Set up the preview media source - wait for canvas to be ready
                const setupCanvasBackground = () => {
                    const previewMedia = document.getElementById('previewMedia');
                    const canvas = document.getElementById('live-preview-canvas');
                    
                    if (previewMedia && canvas && canvas.width > 0 && canvas.height > 0) {
                        // Convert canvas to image for the overlay system
                        const dataUrl = canvas.toDataURL('image/png');
                        previewMedia.src = dataUrl;
                        console.log('[overlay-system] Canvas background set');
                        return true;
                    }
                    return false;
                };
                
                // Try to set canvas background immediately
                if (!setupCanvasBackground()) {
                    // If canvas not ready, wait for it
                    const checkCanvas = () => {
                        if (setupCanvasBackground()) {
                            console.log('[overlay-system] Canvas background set after wait');
                            try { ensureOverlayTopAndVisible('#stage'); } catch {}
                        } else {
                            // Retry in 100ms
                            setTimeout(checkCanvas, 100);
                        }
                    };
                    checkCanvas();
                }
                
                // Set initial quote if available
                if (currentQuote?.text) {
                    setQuote(currentQuote.text);
                    try { ensureOverlayTopAndVisible('#stage'); } catch {}
                    
                    // Unhide container when initial quote exists
                    const container = document.getElementById('live-preview-container');
                    if (container) {
                        container.classList.remove('opacity-0');
                        // Only set inline opacity if style is currently empty (to not override transitions)
                        if (!container.style.opacity) {
                            container.style.opacity = '1';
                        }
                        // Force layout recalculation on mobile
                        void container.offsetHeight;
                    }
                }
                
                // Initialize hybrid caption preview system
                try {
                    const { initHybridCaptionPreview } = await import('./js/caption-live.js');
                    await initHybridCaptionPreview();
                    console.log('[overlay-system] Hybrid caption preview initialized');
                } catch (error) {
                    console.warn('[overlay-system] Failed to initialize hybrid caption preview:', error);
                }
                
                overlaySystemInitialized = true;
                console.log('[overlay-system] Initialized draggable overlay');
                
                // Ensure stage is not display:none after initialization
                const stageEl = document.getElementById('stage');
                if (stageEl && getComputedStyle(stageEl).display === 'none') {
                    stageEl.style.display = 'block';
                }
                
                // Mark preview as unsaved when caption text changes (SSOT workflow)
                try {
                    const captionContent = document.querySelector('.caption-box .content');
                    if (captionContent) {
                        // Debounce the reset to avoid triggering on every keystroke
                        let resetDebounceTimer = null;
                        captionContent.addEventListener('input', () => {
                            clearTimeout(resetDebounceTimer);
                            resetDebounceTimer = setTimeout(() => {
                                // Only reset if preview was previously saved
                                if (window._previewSavedForCurrentText) {
                                    resetPreviewSavedState();
                                }
                            }, 500); // Wait 500ms after user stops typing
                        });
                        console.log('[overlay-system] Added caption change listener for preview state');
                    }
                    
                    // Also listen to quote edit textarea for unsaved changes
                    const quoteEdit = document.getElementById('quote-edit');
                    if (quoteEdit) {
                        let resetDebounceTimer2 = null;
                        quoteEdit.addEventListener('input', () => {
                            clearTimeout(resetDebounceTimer2);
                            resetDebounceTimer2 = setTimeout(() => {
                                // Only reset if preview was previously saved
                                if (window._previewSavedForCurrentText) {
                                    resetPreviewSavedState();
                                }
                            }, 500);
                        });
                        console.log('[overlay-system] Added quote edit change listener for preview state');
                    }
                } catch (e) {
                    console.warn('[overlay-system] Failed to add change listeners:', e);
                }
            } catch (error) {
                console.error('[overlay-system] Failed to initialize:', error);
            }
        }
        
        async function toggleOverlayMode() {
            const toggle = document.getElementById('overlay-mode-toggle');
            const stage = document.getElementById('stage');
            const legacyOverlay = document.getElementById('caption-overlay');
            const overlayControls = document.getElementById('overlay-controls');
            
            useOverlayMode = toggle.checked;
            
            if (useOverlayMode) {
                // Show new overlay system
                stage.style.display = 'block';
                legacyOverlay.style.display = 'none';
                try { overlayControls.style.display = 'block'; } catch {}
                
                // Initialize overlay system if not already done
                if (!overlaySystemInitialized) {
                    await initOverlaySystem();
                }
                
                // Wait a moment for the overlay to be ready
                setTimeout(async () => {
                    // Update overlay with current quote if available
                    if (currentQuote?.text) {
                        await updateOverlayCaption(currentQuote.text.trim(), true);
                    }
                }, 100);
            } else {
                // Show legacy overlay system
                stage.style.display = 'none';
                legacyOverlay.style.display = 'block';
                try { overlayControls.style.display = 'none'; } catch {}
            }
            
            console.log('[overlay-mode] Switched to:', useOverlayMode ? 'draggable overlay' : 'legacy overlay');
        }
        
        // New overlay-based caption update function
        async function updateOverlayCaption(text = '', show = true) {
            // Unhide container at the top (before early return)
            const container = document.getElementById('live-preview-container');
            if (container) {
                container.classList.remove('opacity-0');
                if (!container.style.opacity) {
                    container.style.opacity = '1';
                }
            }
            
            if (!useOverlayMode || !overlaySystemInitialized) return;
            
            // Ensure stage is visible
            const stage = document.getElementById('stage');
            if (stage) {
                stage.style.display = 'block';
            }
            
            try {
                const { setQuote, getCaptionMeta, applyCaptionMeta, ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                
                if (show && text?.trim()) {
                    setQuote(text);
                }
                
                // Update canvas background if needed
                updateOverlayCanvasBackground();
                
                console.log('[overlay-caption] Updated overlay with text:', text?.substring(0, 50));
                try { ensureOverlayTopAndVisible('#stage'); } catch {}
            } catch (error) {
                console.error('[overlay-caption] Failed to update overlay:', error);
            }
        }
        
        // Update overlay canvas background
        async function updateOverlayCanvasBackground() {
            if (!useOverlayMode || !overlaySystemInitialized) return;
            
            try {
                const previewMedia = document.getElementById('previewMedia');
                const canvas = document.getElementById('live-preview-canvas');
                
                if (previewMedia && canvas && canvas.width > 0 && canvas.height > 0) {
                    const dataUrl = canvas.toDataURL('image/png');
                    previewMedia.src = dataUrl;
                    console.log('[overlay-canvas] Background updated');
                    try { const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js'); ensureOverlayTopAndVisible('#stage'); } catch {}
                }
            } catch (error) {
                console.warn('[overlay-canvas] Failed to update background:', error);
            }
        }
        
        // Convert overlay meta to SSOT payload
        function overlayMetaToSSOT(meta) {
            // ‚úÖ Extract pixels computed by emitCaptionState
            return {
                ssotVersion: 3,
                mode: 'raster',
                text: meta.text || meta.textRaw || '',
                textRaw: meta.textRaw,
                
                // ‚úÖ CANONICAL PIXELS (no percentages!)
                frameW: 1080,
                frameH: 1920,
                fontPx: meta.fontPx,
                lineSpacingPx: meta.lineSpacingPx,
                letterSpacingPx: meta.letterSpacingPx,
                rasterW: meta.rasterW,
                rasterH: meta.rasterH,  // ‚úÖ Client canonical value
                yPx_png: meta.yPx_png,
                rasterPadding: meta.rasterPadding || 24,  // ‚úÖ Use consistent naming
                xExpr_png: meta.xExpr_png || '(W-overlay_w)/2',
                
                // lines array is already included in browserGeometry above
                
                // Styles
                fontFamily: meta.fontFamily || 'DejaVu Sans',
                weightCss: meta.weightCss || '700',
                fontStyle: meta.fontStyle || 'normal',
                textAlign: meta.textAlign || 'center',
                textTransform: meta.textTransform || 'none',
                color: meta.color || 'rgb(255,255,255)',
                opacity: meta.opacity ?? 1.0,
                strokePx: meta.strokePx || 0,
                strokeColor: meta.strokeColor || 'rgba(0,0,0,0.85)',
                shadowColor: meta.shadowColor || 'rgba(0,0,0,0.6)',
                shadowBlur: meta.shadowBlur ?? 12,
                shadowOffsetX: meta.shadowOffsetX ?? 0,
                shadowOffsetY: meta.shadowOffsetY ?? 2
            };
        }
        
        // Preview function for overlay system
        async function previewOverlayCaption() {
            if (!useOverlayMode || !overlaySystemInitialized) {
                console.warn('[overlay-preview] Overlay mode not ready:', { useOverlayMode, overlaySystemInitialized });
                return;
            }
            
            try {
                const { getCaptionMeta } = await import('./js/caption-overlay.js');
                const meta = getCaptionMeta();
                console.log('[overlay-preview] Got overlay meta:', meta);
                
                const payload = overlayMetaToSSOT(meta);
                console.log('[overlay-preview] Sending payload:', payload);
                
                // DEBUG_PARITY: Log font details before save (gated by DEBUG_PARITY flag)
                if (window.DEBUG_PARITY) {
                    console.log('[caption-overlay:save]', {
                        fontFamily: meta.fontFamily,
                        weightCss: meta.weightCss,
                        fontStyle: meta.fontStyle,
                        previewFontString: meta.previewFontString
                    });
                }
                
                const { apiFetch } = await import('./api.mjs');
                const result = await apiFetch('/caption/preview', { method: 'POST', body: payload });
                console.log('[overlay-preview] Server response:', result);
                
                // Store overlay preview meta to window.__lastCaptionOverlay for SSOT render payload
                if (result?.ok && result?.data) {
                    window.__lastCaptionOverlay = {
                        dataUrl: result.data.imageUrl,
                        width: result.data.wPx || 1080,
                        height: result.data.hPx || 1920,
                        meta: result.data.meta || {}
                    };
                    console.log('[overlay-preview] Stored server meta:', window.__lastCaptionOverlay.meta);
                    
                    // AUDIT: Log after-save comparison
                    console.info('[AUDIT:CLIENT:after-save]', {
                        sent: normalizedPayload.previewFontString,
                        returned: result.data.meta?.previewFontString,
                        equal: normalizedPayload.previewFontString === result.data.meta?.previewFontString
                    });
                }
                
                const previewMedia = document.getElementById('previewMedia');
                if (previewMedia && (result?.previewUrl || result?.data?.imageUrl)) {
                    previewMedia.src = result.previewUrl || result.data.imageUrl;
                    console.log('[overlay-preview] Preview image set');
                }
                
                console.log('[overlay-preview] Preview generated successfully');
            } catch (error) {
                console.error('[overlay-preview] Failed:', error);
                // Do not fall back to legacy while overlay mode is ON (keeps SSOT)
            }
        }
        
        // Render function for overlay system
        async function renderOverlayCaption() {
            if (!useOverlayMode || !overlaySystemInitialized) return;
            
            try {
                const { getCaptionMeta } = await import('./js/caption-overlay.js');
                const meta = getCaptionMeta();
                const payload = overlayMetaToSSOT(meta);
                
                const res = await fetch('/api/caption/render', {
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'}, 
                    body: JSON.stringify(payload)
                });
                
                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.detail || 'Render failed');
                }
                
                const { jobId, outputUrl } = await res.json();
                console.log('[overlay-render] Render job created:', jobId);
                
                // Handle job creation / redirect / poll as you already do
                // This would integrate with your existing render pipeline
                
            } catch (error) {
                console.error('[overlay-render] Failed:', error);
            }
        }
        
        // Regen helpers: only decrement on LLM actions
        window.VAI = window.VAI || {};
        VAI.state = VAI.state || { regensLeft: 10 };
        (function initRegens(){
            const info = document.getElementById('regen-info');
            if (!info) return;
            const m = String(info.textContent||'').match(/(\d+)/);
            const initial = m ? parseInt(m[1],10) : 10;
            if (!Number.isFinite(VAI.state.regensLeft)) VAI.state.regensLeft = initial;
            info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        })();
        function setRegensLeft(n){
            VAI.state.regensLeft = Math.max(0, Number(n||0));
            const info = document.getElementById('regen-info');
            if (info) info.textContent = `Regens left: ${VAI.state.regensLeft}`;
        }
        function decRegens(){
            setRegensLeft((VAI.state.regensLeft|0) - 1);
        }
        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function setLoading(buttonId, loading) {
            const button = document.getElementById(buttonId);
            button.disabled = loading;
            button.textContent = loading ? 'Loading...' : button.textContent.replace('Loading...', '');
        }

        // Load credits using existing system
        async function refreshCredits(force = true, retries = 1) {
            if (!window.auth?.currentUser) { 
                updateCreditUI(0); 
                return; 
            }
            try {
                // Use the apiFetch from the imported module
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch("/credits", { method: "GET" });
                const credits = Number(data?.credits ?? 0);
                updateCreditUI(Number.isNaN(credits) ? 0 : credits);
            } catch (err) {
                if (retries > 0) return refreshCredits(false, retries - 1);
                console.warn("Credits fetch failed:", err);
            }
        }

        function updateCreditUI(credits) {
            currentCredits = typeof credits === "number" ? credits : 0;
            const creditDisplay = document.getElementById('credit-display');
            const creditCount = document.getElementById('credit-count');
            if (creditDisplay) creditDisplay.classList.remove("hidden");
            if (creditCount) creditCount.textContent = String(currentCredits);
        }

        // Quote generation
        async function generateQuote() {
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to generate quotes');
                return;
            }
            
            const text = document.getElementById('quote-text').value;
            const tone = document.getElementById('quote-tone').value;
            
            if (!text.trim()) return;
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Check if input is a URL - use story service for 4-6 sentence summaries
                if (isUrl(text)) {
                    console.log('[generate-quote] Detected URL, using story service');
                    
                    // Step 1: Create story session
                    const startResp = await apiFetch('/story/start', {
                        method: 'POST',
                        body: {
                            input: text,
                            inputType: 'link'
                        }
                    });
                    
                    if (!startResp.success || !startResp.data?.id) {
                        throw new Error(startResp.error || 'Failed to create story session');
                    }
                    
                    const sessionId = startResp.data.id;
                    
                    // Store sessionId and URL for reuse in one-click short
                    currentStorySessionId = sessionId;
                    currentStoryUrl = text; // Store original URL
                    
                    // Step 2: Generate story (4-6 sentences)
                    const generateResp = await apiFetch('/story/generate', {
                        method: 'POST',
                        body: {
                            sessionId
                        }
                    });
                    
                    if (!generateResp.success || !generateResp.data?.story?.sentences) {
                        throw new Error(generateResp.error || 'Failed to generate story');
                    }
                    
                    // Join sentences into a single text
                    const sentences = generateResp.data.story.sentences;
                    const joinedText = Array.isArray(sentences) ? sentences.join(' ') : String(sentences);
                    
                    // Create quote object from the summary
                    currentQuote = {
                        text: joinedText,
                        author: null,
                        toneTag: tone === 'default' ? undefined : tone
                    };
                    
                    // Update textarea with the full summary
                    const quoteTextEl = document.getElementById('quote-text');
                    if (quoteTextEl) {
                        quoteTextEl.value = joinedText;
                    }
                    
                    await displayQuote(currentQuote, { skipPreview: true });
                    decRegens();
                    
                    // Update overlay if system is active
                    if (useOverlayMode && overlaySystemInitialized && currentQuote?.text) {
                        try {
                            await maybeUpdateOverlay(currentQuote.text.trim(), true);
                        } catch (e) {
                            console.warn('[generate-quote] overlay update failed', e);
                        }
                    }
                } else {
                    // Non-URL: use existing quote generation flow
                    const data = await apiFetch('/quotes/generate-quote', {
                        method: 'POST',
                        body: {
                            text,
                            tone: tone === 'default' ? undefined : tone,
                            maxChars: 120
                        }
                    });
                    
                    if (data.ok) {
                        currentQuote = data.data.quote;
                        await displayQuote(currentQuote, { skipPreview: true }); // keep textarea visible, skip preview update
                        decRegens();
                        
                        // Update overlay if system is active (for mobile visibility)
                        if (useOverlayMode && overlaySystemInitialized && currentQuote?.text) {
                            try {
                                await maybeUpdateOverlay(currentQuote.text.trim(), true);
                            } catch (e) {
                                console.warn('[generate-quote] overlay update failed', e);
                            }
                        }
                    } else {
                        showError('quote-error', data.reason || 'Failed to generate quote');
                    }
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        // Expose to window scope for ui-actions.js
        window.generateQuote = generateQuote;

        async function displayQuote(quote, options = {}) {
            document.getElementById('quote-text-display').textContent = quote.text;
            const editEl = document.getElementById('quote-edit');
            editEl.value = quote.text;
            // Always keep the inlaid editor visible
            document.getElementById('quote-text-display').classList.add('hidden');
            editEl.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            
            // Update char counter from textarea content
            try {
              const cc = document.getElementById('quote-char-count');
              if (cc) cc.textContent = `${Math.min(200, (editEl.value||'').length)}/200`;
            } catch {}
            document.getElementById('quote-author').textContent = quote.author ? `‚Äî ${quote.author}` : '';
            document.getElementById('quote-author').classList.toggle('hidden', !quote.author);
            document.getElementById('quote-tone-tag').textContent = quote.toneTag ? `Tone: ${quote.toneTag}` : '';
            document.getElementById('quote-tone-tag').classList.toggle('hidden', !quote.toneTag);
            document.getElementById('quote-result').classList.remove('hidden');
            // Always expose LLM iterate buttons when a quote is present
            const remix = document.getElementById('remix-buttons');
            if (remix) remix.classList.remove('hidden');
            updateRenderPreview();
            
            // Preview is handled by updateRenderPreview() which now shows container even without asset
        }

        // Asset loading with pagination and caching
        async function loadAssets(page = 1) {
            if (currentAssetType === 'ai') return;
            if (!window.auth?.currentUser) {
                showError('asset-error', 'Please log in to load assets');
                return;
            }
            
            setLoading('search-assets-btn', true);
            hideError('asset-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const perPage = 12; // fuller grid per request
                const query = document.getElementById('asset-query').value;
                const cacheKey = `${currentAssetType}-${query}-${page}`;
                
                console.log('[assets] loadAssets called:', { type: currentAssetType, query, page });
                
                // Check cache first
                if (assetCache.has(cacheKey)) {
                    const cachedData = assetCache.get(cacheKey);
                    displayAssets(cachedData.items);
                    hasMoreAssets = cachedData.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                    setLoading('search-assets-btn', false);
                    console.log('[assets] Loaded from cache:', cacheKey);
                    return;
                }
                
                const data = await apiFetch('/assets/options', {
                    method: 'POST',
                    body: {
                        type: currentAssetType,
                        query,
                        page,
                        perPage
                    }
                });
                
                if (data.ok) {
                    console.log('[assets] Response received:', { 
                        meta: data.data.meta, 
                        count: data.data.items?.length 
                    });
                    
                    // Cache the results
                    assetCache.set(cacheKey, {
                        items: data.data.items,
                        nextPage: data.data.nextPage
                    });
                    
                    displayAssets(data.data.items);
                    hasMoreAssets = data.data.nextPage;
                    currentAssetPage = page;
                    updatePagination();
                } else {
                    showError('asset-error', data.reason || 'Failed to load assets');
                }
            } catch (error) {
                showError('asset-error', error.message || 'Network error');
            } finally {
                setLoading('search-assets-btn', false);
            }
        }

        // Expose to window scope for ui-actions.js
        window.loadAssets = loadAssets;

        function displayAssets(assets) {
            const grid = document.getElementById('asset-grid');
            grid.innerHTML = '';
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function appendAssets(assets) {
            const grid = document.getElementById('asset-grid');
            assets.forEach(asset => {
                const assetElement = createAssetElement(asset);
                grid.appendChild(assetElement);
            });
        }

        function createAssetElement(asset) {
            const div = document.createElement('div');
            div.className = `relative border-2 rounded overflow-hidden transition-colors group ${
                selectedAsset?.id === asset.id ? 'border-blue-500' : 'border-gray-700'
            }`;
            
            let media;
            if (asset.provider === 'ai' || asset.type === 'ai-generated') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
            } else if (currentAssetType === 'images') {
                media = `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-32 object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
            } else {
                media = `<video src="${asset.fileUrl}" class="w-full h-32 object-cover" muted playsinline preload="metadata" onerror="this.style.display='none'"></video>`;
            }
            
            const attribution = asset.provider === 'ai' 
                ? '<div class="text-purple-400 truncate">AI Generated</div>'
                : asset.photographer 
                    ? `<div class="text-gray-400 truncate">by ${asset.photographer}</div>`
                    : '';
            
            div.innerHTML = `
                ${media}
                <div class="p-2 text-xs">
                    <div class="truncate">${asset.query}</div>
                    ${attribution}
                </div>
                <!-- Action Buttons Overlay -->
                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-all duration-200 flex items-end justify-center pb-2 opacity-0 group-hover:opacity-100">
                    <div class="flex gap-2">
                        <button 
                            class="use-asset-btn px-3 py-1 bg-blue-600 hover:bg-blue-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Use
                        </button>
                        <button 
                            class="remix-asset-btn px-3 py-1 bg-purple-600 hover:bg-purple-500 text-white text-xs rounded transition-colors"
                            data-asset-id="${asset.id}"
                        >
                            Remix
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners for the buttons
            const useBtn = div.querySelector('.use-asset-btn');
            const remixBtn = div.querySelector('.remix-asset-btn');
            
            useBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                useAsset(asset);
            });
            
            remixBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                addToRemix(asset);
            });
            
            return div;
        }

        function selectAsset(asset) {
            selectedAsset = asset;
            // Re-render grid to update selection
            loadAssets(1);
            updateRenderPreview();
            updateRenderButtonState();
            
            // Trigger caption preview immediately after asset selection
            maybeGenerateCaptionPreview();
        }

        function updatePagination() {
            const container = document.getElementById('pagination-container');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const pageInfo = document.getElementById('page-info');
            
            if (currentAssetType === 'ai') {
                container.classList.add('hidden');
                return;
            }
            
            // Show pagination for non-AI asset types
            container.classList.remove('hidden');
            prevBtn.disabled = currentAssetPage <= 1;
            nextBtn.disabled = !hasMoreAssets;
            pageInfo.textContent = `Page ${currentAssetPage}`;
        }

        // Use asset function
        async function useAsset(asset) {
            selectedAsset = asset;
            
            // Initialize window.state if needed
            if (!window.state) window.state = {};
            window.state.selectedAsset = asset;
            
            // Special handling for Pexels assets - high-quality preview
            if (asset.provider === 'pexels' && asset.src) {
                // Ensure the asset has the photo data for later use
                selectedAsset.photo = asset.src;
                await onPexelsUse(asset.src);
            }
            
            updateRenderPreview();
            updateRenderButtonState();
            
            // Show media + caption immediately in overlay (seamless flow with sync guarantee)
            try {
                await ensureOverlayActive();
                
                // Update overlay background with new media (wait for completion)
                if (useOverlayMode && overlaySystemInitialized) {
                    await updateOverlayCanvasBackground();
                    
                    // Wait one frame to ensure canvas/media has painted
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    
                    const hasText = !!(currentQuote?.text || '').trim();
                    console.log('[overlay-media] bg updated; hasText:', hasText);
                }
                
                // If we have a saved quote, show it on the new media
                const txt = (currentQuote?.text || '').trim();
                if (txt && useOverlayMode && overlaySystemInitialized) {
                    await updateOverlayCaption(txt, true);
                    console.log('[useAsset] Updated overlay caption');
                }
                
                // Ensure overlay is visible on top (final positioning)
                try {
                    const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                    ensureOverlayTopAndVisible('#stage');
                } catch {}
            } catch (e) {
                console.warn('[useAsset] overlay update failed', e);
            }
            
            // Legacy flow fallback
            if (currentQuote && !useOverlayMode) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
            
            // Scroll to render section
            document.getElementById('render-preview').scrollIntoView({ behavior: 'smooth' });
        }

        // High-quality Pexels preview handler with race protection
        async function onPexelsUse(photo) {
            const reqId = ++_previewReqId;
            _currentPexelsPhoto = photo; // Track for resize re-rendering

            const canvas = document.getElementById('live-preview-canvas');
            const container = canvas.parentElement;
            const cssW = container.clientWidth;
            const cssH = Math.round(cssW * 16 / 9);

            _setupHiDPICanvas(canvas, cssW, cssH);

            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const previewUrl = _pexelsPreviewUrlFromPhoto(photo, cssW * dpr, cssH * dpr, 1.2);

            // Persist both URLs for later redraws (resize/caption)
            if (!window.state) window.state = {};
            window.state.selectedAsset = {
                ...(window.state.selectedAsset || {}),
                provider: 'pexels',
                id: photo?.id,
                thumbUrl: photo?.src?.medium,
                previewUrl
            };
            
            // Also update the global selectedAsset to keep them in sync
            selectedAsset.previewUrl = previewUrl;

            console.log('[pexels-use] previewUrl', previewUrl);
            await _drawBackground(window.state.selectedAsset.previewUrl, canvas, cssW, cssH, 'bg:pexels-use');

            // Add write-trap to detect accidental overwrites
            try {
                const sa = window.state.selectedAsset;
                let _pv = sa.previewUrl;
                Object.defineProperty(sa, 'previewUrl', {
                    get() { return _pv; },
                    set(v) {
                        if (!_isHiResPreviewUrl(v)) {
                            console.warn('[trap] previewUrl being set to NON-hires url:', v);
                        }
                        _pv = v;
                    }
                });
            } catch {}
        }

        // Add to remix function
        function addToRemix(asset) {
            if (remixAssets.length >= 2) {
                showError('asset-error', 'Maximum 2 remix references allowed');
                return;
            }
            
            if (remixAssets.find(a => a.id === asset.id)) {
                showError('asset-error', 'Asset already in remix references');
                return;
            }
            
            remixAssets.push(asset);
            updateRemixArea();
        }

        // Update remix area display
        function updateRemixArea() {
            const remixArea = document.getElementById('remix-area');
            const remixAssetsContainer = document.getElementById('remix-assets');
            
            if (remixAssets.length === 0) {
                remixArea.classList.add('hidden');
                return;
            }
            
            remixArea.classList.remove('hidden');
            remixAssetsContainer.innerHTML = '';
            
            remixAssets.slice(0,2).forEach((asset, index) => {
                const assetDiv = document.createElement('div');
                assetDiv.className = 'relative w-20 h-20 rounded overflow-hidden border border-gray-600';
                
                const media = asset.provider === 'ai' || asset.type === 'ai-generated'
                    ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`
                    : currentAssetType === 'images'
                        ? `<img src="${asset.thumbUrl || asset.fileUrl}" alt="${asset.query}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`
                        : `<video src="${asset.fileUrl}" class="w-full h-full object-cover" muted playsinline preload="metadata" onerror="this.style.display='none'"></video>`;
                
                assetDiv.innerHTML = `
                    ${media}
                    <button 
                        class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 hover:bg-red-500 text-white text-xs rounded-full flex items-center justify-center"
                        onclick="removeFromRemix(${index})"
                    >
                        √ó
                    </button>
                `;
                
                remixAssetsContainer.appendChild(assetDiv);
            });
        }

        // Remove from remix
        function removeFromRemix(index) {
            remixAssets.splice(index, 1);
            updateRemixArea();
        }

        // Handle file upload
        function handleFileUpload(files) {
            if (!files || !files[0]) return;
            const file = files[0];
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const uploadedAsset = {
                    id: `uploaded-${Date.now()}`,
                    fileUrl: e.target.result,
                    thumbUrl: e.target.result,
                    query: file.name,
                    provider: 'uploaded',
                    type: file.type.startsWith('video/') ? 'video' : 'image'
                };
                
                uploadedAssets.push(uploadedAsset);
                
                // Add to current grid
                const grid = document.getElementById('asset-grid');
                const assetElement = createAssetElement(uploadedAsset);
                grid.insertBefore(assetElement, grid.firstChild);
            };
            
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else if (file.type.startsWith('video/')) {
                reader.readAsDataURL(file);
            }
        }

        function updateRenderPreview() {
            const preview = document.getElementById('render-preview');
            const renderBtn = document.getElementById('render-btn');
            
            // Show preview container if we have any feature selected
            if (currentQuote || selectedAsset || currentVoiceId) {
                // Handle quote display
                if (currentQuote) {
                    document.getElementById('preview-quote').textContent = currentQuote.text;
                } else {
                    document.getElementById('preview-quote').textContent = 'Quote: None';
                }
                
                // Show asset info if available
                if (selectedAsset) {
                    document.getElementById('preview-asset').textContent = 
                        `Background: ${selectedAsset.provider === 'ai' ? 'AI Image' : selectedAsset.provider === 'uploaded' ? 'Uploaded' : `${currentAssetType} - ${selectedAsset.query}`}`;
                } else {
                    document.getElementById('preview-asset').textContent = 'Background: Default (solid black)';
                }
                
                // Update caption style preview
                const font = document.getElementById('caption-font').value;
                const weight = document.getElementById('caption-weight').value;
                const size = window.getCaptionPx();
                const opacity = document.getElementById('caption-opacity').value;
                const placement = document.getElementById('caption-placement').value;
                const background = document.getElementById('caption-background').checked;
                
                document.getElementById('preview-caption-style').textContent = 
                    `Caption: ${font} ${weight}, ${size}px, ${opacity}% opacity, ${placement}${background ? ', with background' : ''}`;
                
                // Update voiceover preview
                const voiceId = document.getElementById('voiceover-voice').value;
                const selectedVoice = availableVoices.find(v => v.id === voiceId);
                const voiceName = selectedVoice ? selectedVoice.name : 'Not selected';
                const stability = document.getElementById('tts-stability').value;
                const similarity = document.getElementById('tts-similarity').value;
                const style = document.getElementById('tts-style').value;
                const speakerBoost = document.getElementById('tts-speaker-boost').checked;
                
                // Show normalized style value (0-1 range) in preview
                const normalizedStyle = (parseInt(style) / 100).toFixed(2);
                document.getElementById('preview-voiceover').textContent = `Voice: ${voiceName} (Stability: ${stability}, Similarity: ${similarity}, Style: ${normalizedStyle}, Boost: ${speakerBoost ? 'On' : 'Off'})`;
                
                preview.classList.remove('hidden');
                // Always show render button when we have any feature
                renderBtn.classList.remove('hidden');
                // Always show preview container when we have any feature
                document.getElementById('live-preview-container').classList.remove('opacity-0');
                
                // Hide helper text when we have quote and background
                const helperText = document.getElementById('preview-helper-text');
                if (helperText) {
                    if (currentQuote && selectedAsset) {
                        helperText.classList.add('hidden');
                    } else {
                        helperText.classList.remove('hidden');
                    }
                }
                
                // Wait a frame for the container to be visible, then update preview
                requestAnimationFrame(() => {
                    // Ensure proper sequence: Container ‚Üí Canvas ‚Üí Preview ‚Üí Caption
                    console.log('[preview-init] Triggering preview sequence...');
                    if (selectedAsset) {
                        updateLivePreview();
                    }
                    if (currentQuote) {
                        // Small delay to ensure preview is rendered before caption
                        setTimeout(() => {
                            if (useOverlayMode && overlaySystemInitialized) {
                                updateOverlayCaption(currentQuote.text.trim(), true);
                            } else {
                                updateCaptionOverlay(currentQuote.text.trim(), true);
                            }
                        }, 100);
                    }
                });
            } else {
                // No features selected - hide preview but keep button visible
                preview.classList.add('hidden');
                renderBtn.classList.remove('hidden'); // Keep button visible
                document.getElementById('live-preview-container').classList.add('opacity-0');
                
                // Show helper text when nothing is configured
                const helperText = document.getElementById('preview-helper-text');
                if (helperText) {
                    helperText.classList.remove('hidden');
                }
            }
            updateRenderButtonState();
        }

        // Update caption style values
        function updateCaptionStyleValues() {
            const px = window.getCaptionPx();
            document.getElementById('size-value').textContent = `${px}px`;
            document.getElementById('opacity-value').textContent = document.getElementById('caption-opacity').value + '%';
            document.getElementById('bg-opacity-value').textContent = document.getElementById('caption-bg-opacity').value + '%';
            updateRenderPreview();
            updateLivePreview();
            try { updateCaptionOverlay((currentQuote?.text||'').trim(), true); } catch {}
        }

        // Feature flag for preview fixes
        window.__PREVIEW_FIX__ = true;
        
        // Canvas ready state tracking
        let canvasReadyState = { ready: false, observer: null, intersectionObserver: null };
        
        // Fix B: Set the canvas backing store AFTER CSS size exists
        function sizeCanvasToCSS(canvas) {
            const wCSS = canvas.clientWidth;
            const hCSS = canvas.clientHeight;
            
            console.log('[preview-init] Canvas sizing check:', {
                cssW: wCSS, cssH: hCSS, dpr: window.devicePixelRatio,
                canvasw: canvas.width, canvasH: canvas.height,
                rectWidth: canvas.getBoundingClientRect().width, 
                rectHeight: canvas.getBoundingClientRect().height
            });
            
            if (wCSS === 0 || hCSS === 0) {
                console.log('[preview-init] Canvas sized immediately:', {
                    cssW: wCSS, cssH: hCSS, dpr: window.devicePixelRatio,
                    canvasw: canvas.width, canvasH: canvas.height
                });
                return false;
            }

            const dpr = window.devicePixelRatio || 1;
            const wBS = Math.round(wCSS * dpr);
            const hBS = Math.round(hCSS * dpr);

            if (canvas.width !== wBS || canvas.height !== hBS) {
                canvas.width = wBS;
                canvas.height = hBS;
                const ctx = canvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            
            canvasReadyState.ready = true;
            return true;
        }
        
        // IntersectionObserver + ResizeObserver for robust canvas ready detection
        function setupCanvasObserver() {
            if (!window.__PREVIEW_FIX__) return;
            
            const container = document.getElementById('live-preview-container');
            const canvas = document.getElementById('live-preview-canvas');
            if (!container || !canvas) return;
            
            // Clean up existing observers
            if (canvasReadyState.observer) {
                canvasReadyState.observer.disconnect();
            }
            if (canvasReadyState.intersectionObserver) {
                canvasReadyState.intersectionObserver.disconnect();
            }
            
            // Use IntersectionObserver to detect when container becomes visible
            canvasReadyState.intersectionObserver = new IntersectionObserver(entries => {
                for (const entry of entries) {
                    if (entry.isIntersecting) {
                        console.log('[canvas-ready] Container became visible, checking canvas');
                        if (sizeCanvasToCSS(canvas)) {
                            console.log('[canvas-ready] Canvas ready, triggering render');
                            scheduleRender();
                        }
                    }
                }
            }, { threshold: 0.1 });
            
            // Use ResizeObserver for dimension changes
            canvasReadyState.observer = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const { width, height } = entry.contentRect;
                    if (width > 0 && height > 0) {
                        console.log('[canvas-ready] Container resized, checking canvas:', { width, height });
                        if (sizeCanvasToCSS(canvas)) {
                            console.log('[canvas-ready] Canvas ready, triggering render');
                            scheduleRender();
                        }
                    }
                }
            });
            
            // Observe both intersection and resize
            canvasReadyState.intersectionObserver.observe(container);
            canvasReadyState.observer.observe(container);
        }
        
        // Idempotent render scheduler with RAF cancellation
        let renderScheduled = false;
        let renderRafId = null;
        function scheduleRender() {
            if (!window.__PREVIEW_FIX__) return;
            if (renderScheduled) return;
            
            // Cancel any pending RAF to prevent stacking
            if (renderRafId !== null) {
                cancelAnimationFrame(renderRafId);
                renderRafId = null;
            }
            
            renderScheduled = true;
            renderRafId = requestAnimationFrame(() => {
                renderScheduled = false;
                renderRafId = null;
                if (canvasReadyState.ready && currentQuote?.text && selectedAsset) {
                    console.log('[canvas-ready] Executing scheduled render');
                    updateLivePreview();
                    updateCaptionOverlay(currentQuote.text.trim(), true);
                }
            });
        }
        
        // Font parity map for client-side consistency
        const FONT_MAP = { 
            'DejaVu Sans': 'DejaVu Sans', 
            'DejaVu Serif': 'DejaVu Serif' 
        };
        
        // Helper function to derive yPct from placement
        function yPctFromPlacement(placement) {
            switch (placement) {
                case 'top': return 0.15;
                case 'center': return 0.50;
                case 'bottom': return 0.80; // Reduced from 0.90 to prevent cutoff at bottom
                default: return 0.50;
            }
        }
        
        // Helper function for precise float conversion
        function preciseFloat0to1(value) {
            // Fix: If value is already 0-1 range, don't divide by 100
            const numValue = Number(value);
            if (numValue <= 1) {
                return Math.max(0, Math.min(1, numValue));
            }
            // If value is 0-100 range, convert to 0-1
            return Math.max(0, Math.min(1, numValue / 100));
        }
        
        // Build proper payload with all controls wired
        function buildCaptionPayload(text, captionStyle) {
            // SSOT: Check if overlay mode is enabled and use overlay metadata
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const { getCaptionMeta } = window;
                    if (typeof getCaptionMeta === 'function') {
                        const overlayMeta = getCaptionMeta();
                        
                        // Validate overlay meta has required fields
                        if (overlayMeta && typeof overlayMeta.yPct === 'number' && overlayMeta.text) {
                            console.log('[overlay-payload] Using overlay metadata:', overlayMeta);
                            
                            // Convert overlay meta to SSOT payload format
                            return {
                                text: overlayMeta.text || text,
                                yPct: overlayMeta.yPct,
                                xPct: overlayMeta.xPct,
                                wPct: overlayMeta.wPct,
                                fontFamily: overlayMeta.fontFamily,
                                weightCss: overlayMeta.weightCss,
                                sizePx: overlayMeta.fontPx,
                                color: overlayMeta.color,
                                opacity: overlayMeta.opacity,
                                textAlign: overlayMeta.textAlign || 'center',
                                padding: overlayMeta.paddingPx ?? 12,
                                placement: 'custom',      // SSOT: signals server to use manual placement
                                maxWidthPct: Math.round((meta.wPct || 0.8) * 100),
                                showBox: meta.showBox ?? true,
                                boxColor: 'transparent',
                                responsiveText: meta.responsiveText ?? true
                            };
                        } else {
                            console.warn('[overlay-payload] Overlay meta incomplete, falling back to legacy');
                        }
                    }
                } catch (error) {
                    console.warn('[overlay-payload] Failed to get overlay metadata, falling back to legacy:', error);
                }
            }
            
            // Legacy payload format (existing logic)
            const placement = captionStyle.placement || 'center';
            const yPct = captionStyle.yPct ?? yPctFromPlacement(placement);
            const opacity = preciseFloat0to1(captionStyle.opacity || 80);
            
            const payload = {
                text,
                fontFamily: captionStyle.fontFamily || 'DejaVu Sans',
                weight: captionStyle.weightCss || captionStyle.weight || 'normal', // Fix: Use weightCss from captionStyle
                fontPx: captionStyle.fontPx || 48,
                opacity,
                placement,
                yPct
            };
            
            console.log('[caption-overlay] payload:', {
                weight: payload.weight,
                opacity: payload.opacity,
                placement: payload.placement,
                yPct: payload.yPct,
                fontPx: payload.fontPx
            });
            
            return payload;
        }

        // Fix C: Robust "wait for ready" without infinite loop
        async function waitForCanvasReady(canvas, { timeoutMs = 2000 } = {}) {
            const start = performance.now();

            return new Promise((resolve, reject) => {
                const check = () => {
                    const connected = canvas?.isConnected;
                    const rect = canvas?.getBoundingClientRect();
                    const container = document.getElementById('live-preview-container');
                    const containerVisible = container && !container.classList.contains('hidden');
                    const ready = connected && rect && rect.width > 0 && rect.height > 0 && containerVisible;

                    if (ready && sizeCanvasToCSS(canvas)) {
                        resolve(true);
                        return;
                    }
                    if (performance.now() - start > timeoutMs) {
                        reject(new Error('Canvas not ready: no size within timeout'));
                        return;
                    }
                    requestAnimationFrame(check);
                };
                check();
            });
        }

        // Fix E: Initialize preview system with immediate canvas sizing
        async function initPreviewSystem() {
            const canvas = document.getElementById('live-preview-canvas');
            const container = document.getElementById('live-preview-container');
            
            if (!canvas || !container) {
                console.warn('[preview-init] Canvas or container not found');
                return;
            }
            
            // Size canvas immediately from wrapper dimensions
            const wrapper = canvas.parentElement;
            const cssW = wrapper ? wrapper.clientWidth : 360; // fallback 360
            const cssH = wrapper ? wrapper.clientHeight : 640; // fallback 640
            
            // Set canvas.style.width/height in CSS pixels
            canvas.style.width = `${cssW}px`;
            canvas.style.height = `${cssH}px`;
            
            // Set canvas.width/height in device pixels (multiply by devicePixelRatio)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.round(cssW * dpr);
            canvas.height = Math.round(cssH * dpr);
            
            console.log('[preview-init] Canvas sized immediately:', { cssW, cssH, dpr, canvasW: canvas.width, canvasH: canvas.height });
            
            // Trigger initial preview if we have content
            if (currentQuote?.text && selectedAsset) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
        }

        // Manual trigger function for debugging
        function forcePreviewUpdate() {
            console.log('[preview-debug] Forcing preview update');
            if (currentQuote && selectedAsset) {
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            } else {
                console.log('[preview-debug] Missing quote or asset:', { 
                    hasQuote: !!currentQuote, 
                    hasAsset: !!selectedAsset 
                });
            }
        }

        // Make it globally available for debugging
        window.forcePreviewUpdate = forcePreviewUpdate;

        // Initialize caption size UI (safe DOM ready wrapper)
        function initCaptionSizeUI(){
          const el = document.getElementById('caption-size');
          const label = document.getElementById('size-value');
          if (!el || !label) return;
          
          function update() {
            try {
              const px = getCaptionPx(); // use the hoisted function
            label.textContent = `${px}px`;
              // refresh preview overlay without blocking rest of UI
              queueCaptionOverlayRefresh();
              // also update other caption style values
              if (typeof updateCaptionStyleValues === 'function') {
                updateCaptionStyleValues();
              }
            } catch (err) {
              console.error('[caption-size] update failed:', err);
            }
          }

          el.addEventListener('input', update);
          update(); // initial paint
        }
        
        /**
         * Actively load DejaVu Sans variants using Font Loading API
         * Returns true if all variants are ready, false if timeout/failure
         */
        async function ensureDejaVuVariantsReady(timeoutMs = 3000) {
          // Wait for font set to be ready first
          try { await document.fonts.ready; } catch {}

          // Explicitly request each face we care about
          const descriptors = [
            '16px "DejaVu Sans"',
            'bold 16px "DejaVu Sans"',
            'italic 16px "DejaVu Sans"',
            'italic bold 16px "DejaVu Sans"',
          ];

          // Actively load them (Chrome/Firefox/Safari support)
          const loadAll = Promise.all(descriptors.map(d => document.fonts.load(d)));

          // Optional timeout so we don't hang the UI forever
          await Promise.race([
            loadAll,
            new Promise((_, reject) => setTimeout(() => reject(new Error('font-load-timeout')), timeoutMs))
          ]).catch(err => {
            console.warn('[fonts] load() did not fully resolve:', err);
          });

          // Final check (now it should pass)
          const ok = descriptors.every(d => document.fonts.check(d));
          if (!ok) console.warn('[fonts] check() still false for some faces');
          return ok;
        }
        
        // --- robust page bootstrap (run after DOM is ready)
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize studio mode to quotes (default)
            if (typeof window.setStudioMode === 'function') {
                window.setStudioMode('quotes');
            }
            // Initialize studio mode to quotes (default)
            if (typeof window.setStudioMode === 'function') {
                window.setStudioMode('quotes');
            }
          // Wrap each init so one failure doesn't stop the others
          const safe = (label, fn) => { try { fn && fn(); } catch (e) { console.error(`[init] ${label} failed`, e); } };
          
          // Simple mobile mode: hide desktop Studio UI elements
          if (isSimpleMobile()) {
            console.log('[simple-mobile] enabled');
            
            // Hide all accordion headers (the chrome tabs)
            document.querySelectorAll('.accordion-header').forEach(header => {
              markDesktopOnly(header, 'accordion-header');
            });
            
            // Hide Background and Voiceover sections (keep Quote section visible)
            document.querySelectorAll('.accordion-section').forEach(section => {
              const header = section.querySelector('.accordion-header');
              if (header) {
                const sectionType = header.getAttribute('data-section');
                if (sectionType === 'media') {
                  markDesktopOnly(section, 'Background section');
                } else if (sectionType === 'voice') {
                  markDesktopOnly(section, 'Voiceover section');
                }
                // Quote section (data-section="quote") is NOT hidden - keep it visible
              }
            });
            
            // Hide mobile studio toolbar (tabs row)
            markDesktopOnly(document.getElementById('mobile-studio-toolbar'), 'mobile-studio-toolbar');
            
            // Hide desktop Create button
            markDesktopOnly(document.getElementById('render-btn'), 'render-btn (desktop Create)');
            
            // Hide mobile Create button
            markDesktopOnly(document.getElementById('mobile-create-btn'), 'mobile-create-btn');
            
            // Ensure One-Click Short buttons remain visible
            const oneClickBtn = document.getElementById('one-click-btn');
            if (oneClickBtn) oneClickBtn.style.display = '';
            const mobileOneClickBtn = document.getElementById('mobile-one-click-btn');
            if (mobileOneClickBtn) mobileOneClickBtn.style.display = '';
          }
          
          // AUDIT: Actively load fonts and check status
          if (document.fonts) {
            await ensureDejaVuVariantsReady(3000);
            console.info('[AUDIT:FONTS:client-load]', {
              regular: document.fonts.check('16px "DejaVu Sans"'),
              bold: document.fonts.check('bold 16px "DejaVu Sans"'),
              italic: document.fonts.check('italic 16px "DejaVu Sans"'),
              boldItalic: document.fonts.check('italic bold 16px "DejaVu Sans"')
            });
          }

          // PRIORITY: Initialize assets after auth is ready
          (async () => {
            try {
              console.log('[init] Starting asset browser initialization...');
              // Wait for auth to settle once, then decide what to do
              const ok = await ensureLoggedInOrWarn();
              // If logged in (or you want to allow anonymous browsing anyway), kick off first load
              if (ok) {
                const activeType = getActiveAssetType();   // 'images' | 'videos' | 'ai'
                const q = (document.getElementById('asset-query')?.value || 'nature').trim();
                const grid = document.getElementById(`${activeType}-grid`) ||
                             document.querySelector(`[data-grid="${activeType}"]`) ||
                             document.getElementById('asset-grid');
                
                console.log('[assets] Checking initial load:', { activeType, gridEmpty: grid?.childElementCount === 0, query: q });

            if (grid && grid.childElementCount === 0) {
                  console.log('[assets] Loading initial assets for', activeType);
              if (typeof loadAssets === 'function') {
                    currentAssetType = activeType; // Set the global state
                    await loadAssets(1); // Wait for assets to load
              } else {
                console.warn('[assets] loadAssets function not found');
              }
            }
              }
            } catch (e) {
              console.error('[init] Asset browser initialization failed:', e);
            }
          })();

          // Trigger caption preview if we have text and asset (legacy fallback only)
          safe('caption-preview-init', () => maybeGenerateCaptionPreview());

          // Default to overlay mode as soon as caption exists
          safe('overlay-default', () => {
            const hasCaption = !!(currentQuote?.text || document.getElementById('quote-text')?.value);
            if (hasCaption) ensureOverlayActive();
          });

          // SECONDARY: Initialize caption UI (non-blocking)
          safe('caption-size', () => (typeof initCaptionSizeUI === 'function') && initCaptionSizeUI());

          // Asset browser setup is now handled above in priority section
          // Tab switching is now handled by the delegated router in ui-actions.js
        });

        // Update render button state based on validation
        function updateRenderButtonState() {
            console.log('[render-validate] updateRenderButtonState called from:', new Error().stack?.split('\n')[2]?.trim() || 'unknown');
            
            const renderBtn = document.getElementById('render-btn');
            const hasValidAsset = selectedAsset && (selectedAsset.fileUrl || selectedAsset.url);
            const hasQuote = currentQuote;
            const hasVoiceover = !!currentVoiceId;
            const isLoggedIn = window.auth?.currentUser;
            
            console.log('[render-validate] Basic conditions:', {
                hasValidAsset,
                hasQuote,
                hasVoiceover,
                isLoggedIn: !!isLoggedIn,
                selectedAsset: selectedAsset?.url || selectedAsset?.fileUrl || 'none'
            });
            
            // NEW: Check if preview is saved AND current text matches saved text (SSOT workflow)
            let hasSavedPreview = false;
            
            // Debug: Log all validation conditions
            console.log('[render-validate] Checking preview state:', {
                hasGetSavedMeta: !!window.getSavedOverlayMeta,
                hasGetCaptionMeta: !!window.getCaptionMeta,
                flagSet: window._previewSavedForCurrentText,
                flagType: typeof window._previewSavedForCurrentText
            });
            
            if (window.getSavedOverlayMeta && window.getCaptionMeta && window._previewSavedForCurrentText) {
                console.log('[render-validate] All conditions met, checking meta...');
                
                const savedMeta = window.getSavedOverlayMeta();
                console.log('[render-validate] Saved meta exists:', !!savedMeta);
                
                if (savedMeta) {
                    try {
                        const currentMeta = window.getCaptionMeta();
                        console.log('[render-validate] Current meta exists:', !!currentMeta);
                        
                        // Normalize text for comparison - collapse all whitespace to single spaces
                        const normalizeTextForComparison = (text) => {
                            return (text || '').replace(/\s*\n\s*/g, ' ').replace(/\s+/g, ' ').trim();
                        };
                        
                        // Use textRaw if available (preserves user input), fallback to text
                        const savedTextRaw = savedMeta.textRaw || savedMeta.text || '';
                        const currentTextRaw = currentMeta.textRaw || currentMeta.text || '';
                        
                        // Normalize for comparison
                        const savedText = normalizeTextForComparison(savedTextRaw);
                        const currentText = normalizeTextForComparison(currentTextRaw);
                        
                        console.log('[render-validate] Text comparison:', {
                            savedLength: savedText.length,
                            currentLength: currentText.length,
                            match: savedText === currentText,
                            savedNormalized: savedText.substring(0, 100),
                            currentNormalized: currentText.substring(0, 100),
                            savedRaw: savedTextRaw.substring(0, 100),
                            currentRaw: currentTextRaw.substring(0, 100)
                        });
                        
                        // Preview is valid if flag is set AND text matches
                        hasSavedPreview = (savedText === currentText);
                        
                        if (!hasSavedPreview && savedText && currentText && savedText !== currentText) {
                            console.log('[preview-state] Text mismatch detected - saved vs current differ');
                        }
                    } catch (err) {
                        console.warn('[preview-state] Error comparing caption text:', err);
                        hasSavedPreview = false;
                    }
                } else {
                    console.log('[render-validate] No saved meta found');
                }
            } else {
                console.log('[render-validate] Prerequisites not met:', {
                    getSavedOverlayMeta: !!window.getSavedOverlayMeta,
                    getCaptionMeta: !!window.getCaptionMeta,
                    previewSavedFlag: window._previewSavedForCurrentText
                });
            }
            
            console.log('[render-validate] Final hasSavedPreview:', hasSavedPreview);
            
            // Render requires: features + logged in (preview will be saved on-demand)
            const canRender = (hasQuote || hasValidAsset || hasVoiceover) && isLoggedIn;
            
            console.log('[render-validate] Final render decision:', {
                hasQuote,
                hasValidAsset,
                hasVoiceover,
                isLoggedIn: !!isLoggedIn,
                hasSavedPreview,
                canRender,
                buttonWillBeDisabled: !canRender
            });
            
            renderBtn.disabled = !canRender;
            
            // Also update mobile Create button state
            const mobileCreateBtn = document.getElementById('mobile-create-btn');
            if (mobileCreateBtn) {
                mobileCreateBtn.disabled = !canRender;
            }
            
            if (!canRender) {
                let reason = '';
                if (!isLoggedIn) reason = 'Please log in';
                else if (!hasQuote && !hasValidAsset && !hasVoiceover) reason = 'Please add a quote, select media, or choose a voiceover';
                else if (!hasSavedPreview) reason = 'Save preview first';
                
                console.log('[render-validate] Button disabled, reason:', reason);
                renderBtn.title = reason;
                if (mobileCreateBtn) mobileCreateBtn.title = reason;
            } else {
                console.log('[render-validate] Button ENABLED - ready to render!');
                renderBtn.title = 'Ready to render with saved preview';
                if (mobileCreateBtn) mobileCreateBtn.title = 'Ready to render with saved preview';
            }
        }

        // Fix C: Live preview functionality without infinite retry
        function updateLivePreview() {
            if (!currentQuote || !selectedAsset) return;
            
            const container = document.getElementById('live-preview-container');
            const canvas = document.getElementById('live-preview-canvas');
            
            // Check if container is visible first - allow opacity-0 if container has dimensions
            if (!container || container.offsetParent === null) {
                console.log('[preview-scaling] Container not visible, skipping preview');
                return;
            }
            
            // If container has opacity-0 but has dimensions, proceed (will be made visible)
            if (container.classList.contains('opacity-0')) {
                console.log('[preview-scaling] Container has opacity-0 but has dimensions, proceeding...');
            }
            
            // Fix C: Check if canvas has real dimensions, with improved retry logic
            if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                console.log('[preview-scaling] Canvas not ready, scheduling retry...');
                // Force canvas sizing if container has dimensions
                if (container && container.clientWidth > 0 && container.clientHeight > 0) {
                    console.log('[preview-scaling] Container has dimensions, forcing canvas sizing...');
                    const wrapper = canvas.parentElement;
                    if (wrapper) {
                        canvas.style.width = `${wrapper.clientWidth}px`;
                        canvas.style.height = `${wrapper.clientHeight}px`;
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = Math.round(wrapper.clientWidth * dpr);
                        canvas.height = Math.round(wrapper.clientHeight * dpr);
                        console.log('[preview-scaling] Canvas force-sized:', { 
                            cssW: canvas.clientWidth, cssH: canvas.clientHeight,
                            canvasW: canvas.width, canvasH: canvas.height 
                        });
                    }
                }
                
                // Retry once on next frame
                requestAnimationFrame(() => {
                    const retryCanvas = document.getElementById('live-preview-canvas');
                    if (retryCanvas && retryCanvas.clientWidth > 0 && retryCanvas.clientHeight > 0) {
                        console.log('[preview-scaling] Canvas ready on retry, proceeding...');
                        updateLivePreview();
                    } else {
                        console.warn('[preview-scaling] Canvas still not ready after retry, skipping preview');
                    }
                });
                return;
            }
            
            container.classList.remove('opacity-0');
            
            // If a <video> is present for preview, hide overlay to avoid double text
            try {
                const ov = document.getElementById('caption-overlay');
                const hasVideo = !!document.querySelector('#live-preview-container video, #preview-holder video');
                if (ov) ov.style.display = hasVideo ? 'none' : 'block';
            } catch {}

            // 9:16 CSS sizing + HiDPI backing
            const { cssW, cssH } = layoutPreviewDims();
            const { ctx } = _setupHiDPICanvas(canvas, cssW, cssH);

            // Choose the background URL from whatever the app thinks it should be
            let url = selectedAsset?.previewUrl || selectedAsset?.url || selectedAsset?.thumbUrl || selectedAsset?.fileUrl;
            
            // >>> Insert this one line to force hi-res for Pexels:
            url = _ensureHiResPreviewUrl(url, canvas);

            // Load & draw the background
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.decoding = 'async';
            img.src = url;
            
            img.onload = () => {
                // COVER draw (no stretching)
                drawCover(ctx, img, cssW, cssH);
                
                // Debug
                window._currentPreviewUrl = url;
                _tapCanvas('bg:updateLivePreview');
            };
        }

        function drawCaptionOverlay(ctx, canvasWidth, canvasHeight) {
            if (!currentQuote) return;
            
            const font = document.getElementById('caption-font').value;
            const weight = document.getElementById('caption-weight').value;
            const size = window.getCaptionPx();
            const opacity = parseInt(document.getElementById('caption-opacity').value) / 100;
            const placement = document.getElementById('caption-placement').value;
            const showBackground = document.getElementById('caption-background').checked;
            const bgOpacity = parseInt(document.getElementById('caption-bg-opacity').value) / 100;
            
            // Set font - ensure weight mapping matches FFmpeg
            const cssWeight = (String(weight).toLowerCase() === 'bold' || Number(weight) >= 600) ? 'bold' : 'normal';
            ctx.font = `${cssWeight} ${size}px ${getFontFamily(font)}`;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add stroke to match FFmpeg rendering
            ctx.lineWidth = 3;
            ctx.strokeStyle = `rgba(0, 0, 0, 0.85)`;
            ctx.miterLimit = 2;
            
            // Calculate text position
            let y;
            const padding = 20;
            switch (placement) {
                case 'top':
                    y = padding + size / 2;
                    break;
                case 'middle':
                    y = canvasHeight / 2;
                    break;
                case 'bottom':
                    y = canvasHeight - padding - size / 2;
                    break;
            }
            
            // Wrap text if needed
            const maxWidth = canvasWidth - 40;
            const words = currentQuote.text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);
            
            // Draw background if enabled
            if (showBackground) {
                const lineHeight = size * 1.2;
                const totalHeight = lines.length * lineHeight;
                const bgY = y - totalHeight / 2;
                const bgHeight = totalHeight + padding;
                const bgWidth = canvasWidth - 20;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${bgOpacity})`;
                ctx.fillRect(10, bgY - padding / 2, bgWidth, bgHeight);
            }
            
            // Draw text lines
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            const lineHeight = size * 1.2;
            const startY = y - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                const x = canvasWidth / 2;
                const y = startY + index * lineHeight;
                
                // Draw stroke first (matches FFmpeg layering)
                ctx.strokeText(line, x, y);
                // Draw fill text on top
                ctx.fillText(line, x, y);
            });
        }

        function getFontFamily(font) {
            const fontMap = {
                'system': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif',
                'bold': 'DejaVu Sans Local, system-ui, -apple-system, sans-serif', 
                'cinematic': 'DejaVu Sans Local, Georgia, serif',
                'minimal': 'DejaVu Sans Local, Helvetica, Arial, sans-serif'
            };
            return fontMap[font] || 'DejaVu Sans Local, system-ui, sans-serif';
        }

        // Compute preview-fitted lines using canvas metrics to mirror overlay width
        function computeFittedTextForPreview(text, { font, weight, sizePx, previewWidthPx }) {
            try {
                const raw = String(text || '').trim();
                if (!raw) {
                    return '';
                }
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const family = "DejaVu Sans Local";
                const weightCss = (String(weight).toLowerCase() === 'bold') ? '700' : '400';
                const size = Math.max(10, Number(sizePx) || 48);
                ctx.font = `${weightCss} ${size}px ${family}`;
                
                // Match overlay: max content width ‚âà 92% of preview width
                const maxWidth = Math.max(20, Math.round((Number(previewWidthPx)||360) * 0.92));
                
                const words = raw.split(/\s+/);
                const lines = [];
                let cur = '';
                for (const w of words) {
                    const next = cur ? cur + ' ' + w : w;
                    const width = ctx.measureText(next).width;
                    if (width > maxWidth && cur) { lines.push(cur); cur = w; } else { cur = next; }
                }
                if (cur) lines.push(cur);
                
                const result = lines.join('\n');
                return result;
            } catch (error) {
                return String(text || '').trim();
            }
        }

        // Voice loading and preview functions
        window.loadVoices = async function loadVoices() {
            try {
                // Wait for auth to be ready
                if (!window.auth?.currentUser) {
                    // Wait a bit for auth to initialize
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (!window.auth?.currentUser) {
                        showError('voice-preview-status', 'Please log in to load voices');
                        return;
                    }
                }

                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/voice/voices', {
                    method: 'GET'
                });

                if (data.success) {
                    availableVoices = data.data.voices;
                    populateVoiceSelect();
                    hideError('voice-preview-status');
                } else {
                    showError('voice-preview-status', data.error || 'Failed to load voices');
                }
            } catch (error) {
                console.error('Voice loading error:', error);
                showError('voice-preview-status', error.message || 'Network error');
            }
        }

        function populateVoiceSelect() {
            const select = document.getElementById('voiceover-voice');
            const retryBtn = document.getElementById('retry-voices-btn');
            select.innerHTML = '';
            
            if (availableVoices.length === 0) {
                select.innerHTML = '<option value="">No voices available</option>';
                retryBtn.title = 'Retry loading voices';
                return;
            }

            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = `${voice.name} - ${voice.description}`;
                select.appendChild(option);
            });

            // Enable preview button and hide retry button
            document.getElementById('preview-voice-btn').disabled = false;
            retryBtn.style.display = 'none';
        }

        async function previewVoice() {
            const voiceSelect = document.getElementById('voiceover-voice');
            const voiceId = voiceSelect.value;
            
            if (!voiceId || voiceId === '') {
                showError('voice-preview-status', 'Please select a voice');
                return;
            }

            const statusEl = document.getElementById('voice-preview-status');
            const previewBtn = document.getElementById('preview-voice-btn');
            const audioEl = document.getElementById('voice-preview-audio');

            statusEl.classList.remove('hidden');
            statusEl.textContent = 'Generating preview...';
            previewBtn.disabled = true;

            try {
                // Get TTS settings from UI and normalize to 0-1 range
                const stability = parseFloat(document.getElementById('tts-stability').value);
                const similarity_boost = parseFloat(document.getElementById('tts-similarity').value);
                const style = parseInt(document.getElementById('tts-style').value);
                const use_speaker_boost = document.getElementById('tts-speaker-boost').checked;
                
                // Normalize style from 0-100 to 0-1 range
                const normalizedStyle = Math.max(0, Math.min(1, style / 100));
                
                // Get caption text for preview if available, otherwise use default
                const captionText = document.getElementById('quote-text-display')?.textContent?.trim() || 
                                  document.getElementById('quote-edit')?.value?.trim() || 
                                  'Hello, this is a preview of my voice. How does it sound?';
                
                // Trim caption if too long (max ~240 chars for preview)
                const previewText = captionText.length > 240 ? captionText.substring(0, 240) + '...' : captionText;
                
                const ttsPayload = {
                    text: previewText,
                    voiceId,
                    modelId: 'eleven_multilingual_v2',
                    outputFormat: 'mp3_44100_128',
                    voiceSettings: {
                        stability,
                        similarity_boost,
                        style: normalizedStyle, // Now 0-1 range
                        use_speaker_boost
                    }
                };
                
                console.log('[tts.preview] POST /api/tts/preview', { voiceId, settings: ttsPayload.voiceSettings });
                
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/tts/preview', {
                    method: 'POST',
                    body: ttsPayload
                });
                
                console.log('[tts.preview] Response received:', { success: data.success, hasAudio: !!data.data?.audio });

                if (data.success) {
                    audioEl.src = data.data.audio;
                    audioEl.classList.remove('hidden');
                    statusEl.textContent = 'Preview ready - click play to listen';
                    
                    // Auto-play the preview
                    audioEl.play().catch(e => {
                        console.warn('[tts.preview] Autoplay prevented:', e.message);
                        statusEl.textContent = 'Preview ready - click play to listen';
                    });
                    console.log('[tts.preview] Playing preview audio');
                } else {
                    console.error('[tts.preview] Failed:', data.error || 'Unknown error');
                    showError('voice-preview-status', data.error || 'Failed to generate preview');
                }
            } catch (error) {
                console.error('[tts.preview] Error:', error);
                showError('voice-preview-status', error.message || 'Network error');
            } finally {
                previewBtn.disabled = false;
            }
        }

        // Helper function for better error messages
        function summarizeCreateError(err) {
            try {
                const msg = String(err?.message || err);
                const json = JSON.parse(msg.replace(/^Error:\s*/, ''));
                const fe = json?.detail?.fieldErrors || {};
                if (fe.caption?.length) return `Caption: ${fe.caption.join(', ')}`;
            } catch {}
            return null;
        }


        // Helper functions for payload construction
        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        
        // Drop undefined keys before fetch; keeps payload clean
        function stripUndefined(obj) {
            return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined));
        }

        // Convert placement/% to absolute yPx_png
        function toRasterYPx({frameH, rasterH, placement, yPct, internalPaddingPx}) {
            const pad = Number.isFinite(internalPaddingPx) ? internalPaddingPx : Math.round((yPct ?? 0) * frameH);
            if (placement === 'bottom') return frameH - rasterH - pad;
            if (placement === 'center') return Math.round((frameH - rasterH)/2);
            return pad; // top
        }

        // Integer/non-negative normalization for server strict validation
        function int(n) { 
            return Number.isFinite(n) ? Math.round(n) : 0; 
        }

        function nonneg(n) { 
            return Math.max(0, int(n)); 
        }

        // Extract clean text from the preview editor (SSOT for caption text)
        function getEditorPlainText() {
            // Use the preview content as the SSOT for text
            const el = document.querySelector('.caption-box .content');
            if (!el) {
                console.warn('[getEditorPlainText] No .caption-box .content element found');
                return { textRaw: '', text: '' };
            }
            
            // innerText preserves line breaks; normalize them to spaces for `text`
            const raw = (el.innerText || '').trim();
            return {
                textRaw: raw,                 // keep line breaks for debugging if you like
                text: raw.replace(/\s*\n\s*/g, ' ').replace(/\s+/g, ' ').trim(), // schema expects a string; no HTML
            };
        }

        function normalizeRasterPayload(p) {
            // Extract text from DOM as SSOT (guarantees text always exists)
            const { text, textRaw } = getEditorPlainText();
            
            // Use existing lines if present; otherwise derive from text
            const safeLines = Array.isArray(p.lines) && p.lines.length
                ? p.lines
                : (text ? text.split(/\s*\n\s*/g).filter(Boolean) : []);

            return {
                ...p,
                
                // ‚úÖ Force-fill text fields (server schema-friendly)
                text: (p.text && p.text.trim() ? p.text.trim() : text).trim(),
                textRaw: (p.textRaw && p.textRaw.trim() ? p.textRaw.trim() : textRaw).trim(),
                
                // Use safe lines array
                lines: safeLines,
                
                // integers the server expects
                frameW: int(p.frameW),
                frameH: int(p.frameH),
                rasterW: int(p.rasterW),
                rasterH: int(p.rasterH),
                rasterPadding: int(p.rasterPadding || 0),
                fontPx: int(p.fontPx),
                
                // Client canonical values (required for V3 raster)
                clientRasterW: int(p.clientRasterW || p.rasterW),
                clientRasterH: int(p.clientRasterH || p.rasterH),
                clientRasterPadding: int(p.clientRasterPadding || p.rasterPadding || 0),
                lineSpacingPx: int(p.lineSpacingPx),
                letterSpacingPx: int(p.letterSpacingPx || 0),
                totalTextH: int(p.totalTextH),
                yPxFirstLine: int(p.yPxFirstLine),
                
                // placement must be >= 0
                xPx_png: nonneg(p.xPx_png ?? 0),
                yPx_png: int(p.yPx_png ?? 0),
                
                // strings ‚Äì ensure they're present
                fontFamily: String(p.fontFamily || ''),
                fontStyle: String(p.fontStyle || 'normal'),
                weightCss: String(p.weightCss || '400'),
                previewFontString: String(p.previewFontString || ''),
                
                
                // remove percent fields to avoid ambiguity in raster mode
                xPct: undefined,
                yPct: undefined,
                wPct: undefined
            };
        }

        // Reset preview saved state when caption text changes
        function resetPreviewSavedState() {
            console.log('[preview-state] Resetting preview saved state - caption changed');
            
            // Hide Preview Saved status indicator
            const statusContainer = document.querySelector('#preview-status');
            if (statusContainer) {
                statusContainer.innerHTML = '';
                statusContainer.classList.add('hidden');
            }
            
            // Mark saved preview as stale (don't clear localStorage, just invalidate flag)
            window._previewSavedForCurrentText = false;
            
            // Update render button state (will disable it since preview is no longer saved)
            updateRenderButtonState();
        }

        // ---- Browser-as-Visual-Truth Helper Functions ----
        
        // Parse pixel values safely
        const px = v => (typeof v === 'number' ? v : parseFloat(v || 0)) || 0;

        // Convert CSS px (preview) -> frame px (e.g., 1080x1920)
        function toFramePx(cssPx, { frameW, previewCssW }) {
            const scale = frameW / previewCssW;      // e.g., 1080 / 360 = 3
            return Math.round(cssPx * scale);
        }

        // Collect computed styles we need (what the user actually sees)
        function readComputed(el) {
            const cs = getComputedStyle(el);
            const fontPx = Math.round(px(cs.fontSize));  // ‚úÖ Round immediately
            const lineHeightPx = cs.lineHeight === 'normal'
                ? Math.ceil(fontPx * 1.2)             // browser default fallback
                : Math.round(px(cs.lineHeight));  // ‚úÖ Round
            const lineSpacingPx = Math.max(0, Math.round(lineHeightPx - fontPx));  // ‚úÖ Round
            const letterSpacingPx = Math.round(px(cs.letterSpacing));  // ‚úÖ Round

            return {
                fontFamily: cs.fontFamily,
                fontStyle: cs.fontStyle,
                weightCss: cs.fontWeight,
                fontPx,
                lineHeightPx,
                lineSpacingPx,
                letterSpacingPx,
            };
        }


        // Build raster geometry exactly like the user sees
        function buildRasterFromBrowser({
            stageEl,        // the draggable/resize box element (POSITIONED)
            contentEl,        // the inner text element (where computed styles apply)
            frameW = 1080,  // video width
            frameH = 1920,  // video height
            previewCssW,   // CSS width of the live preview (e.g., 360)
        }) {
            // 1) Styles (browser truth)
            const s = readComputed(contentEl);

            // 2) Visual lines - use stable line extraction with retry and caching
            const metrics = {
                fontPx: s.fontPx,
                lineSpacingPx: s.lineSpacingPx
            };
            const extractionResult = window.extractLinesStable(contentEl, metrics);
            const lines = extractionResult.lines;
            const linesCount = Math.max(1, lines.length);
            
            // Log extraction result for debugging
            console.log('[lines:save]', {
                source: extractionResult.source,
                count: lines.length,
                clientWidth: contentEl.clientWidth,
                maxWidthUsed: contentEl.clientWidth - (parseInt(getComputedStyle(contentEl).paddingLeft, 10) || 0) - (parseInt(getComputedStyle(contentEl).paddingRight, 10) || 0),
                fontPx: metrics.fontPx,
                lineSpacingPx: metrics.lineSpacingPx,
            });

            // 3) Get container for relative positioning
            const stageContainer = stageEl.parentElement || stageEl;
            const containerRect = stageContainer.getBoundingClientRect();
            const box = stageEl.getBoundingClientRect();

            // Calculate position relative to container (not viewport)
            const relativeTopCss = box.top - containerRect.top;
            const relativeLeftCss = box.left - containerRect.left;

            // 4) Convert typography to frame pixels
            const fontPxFrame = toFramePx(s.fontPx, { frameW, previewCssW });
            const lineSpacingPxFrame = toFramePx(s.lineSpacingPx, { frameW, previewCssW });
            const letterSpacingPxFrame = toFramePx(s.letterSpacingPx, { frameW, previewCssW });

            // 5) Calculate totalTextH in frame space
            const totalTextHFrame = fontPxFrame * linesCount + lineSpacingPxFrame * (linesCount - 1);

            // 6a) Read actual padding from content element (if any)
            const sContent = getComputedStyle(contentEl);
            const contentPadTopCss = parseFloat(sContent.paddingTop) || 0;
            const paddingFramePx = Math.round(toFramePx(contentPadTopCss, { frameW, previewCssW }));

            // 6b) Convert to frame pixels
            const rW = toFramePx(box.width, { frameW, previewCssW });
            
            // Use CaptionGeom to compute rasterH with descender/shadow safety
            const shadow = window.CaptionGeom ? window.CaptionGeom.parseShadow(sContent.textShadow) : { blur: 12, y: 2 };
            const rH = window.CaptionGeom ? window.CaptionGeom.computeRasterH({
                totalTextH: totalTextHFrame,
                padTop: paddingFramePx,
                padBottom: paddingFramePx,
                shadowBlur: shadow.blur,
                shadowOffsetY: shadow.y
            }) : totalTextHFrame + (paddingFramePx * 2);

            const xPx_png = toFramePx(relativeLeftCss, { frameW, previewCssW });
            let yPx_png = toFramePx(relativeTopCss, { frameW, previewCssW });
            
            // Clamp negative yPx_png to 0 as safety net (overlay may be off-screen on mobile)
            if (yPx_png < 0) {
                console.warn('[browser-geom] Clamping negative yPx_png:', yPx_png, '-> 0');
                yPx_png = 0;
            }

            // Compute asymmetric padding
            const padTop = paddingFramePx;
            const padBottom = paddingFramePx + (window.CaptionGeom ? window.CaptionGeom.DESCENDER_PAD + window.CaptionGeom.SHADOW_BLUR_DEFAULT + Math.max(0, shadow.y) : 0);

            console.log('[browser-geom]', { 
                rW, rH, yPx_png, yPxFirstLine: yPx_png + paddingFramePx, 
                padTop, padBottom,
                lines: lines.length 
            });

            return {
                // DOM truth - correct field names for server
                lines,                    // string[] - the actual line text (server derives count from lines.length)
                totalTextH: totalTextHFrame,      // Frame pixels
                yPxFirstLine: yPx_png + paddingFramePx,

                // Fonts & spacing (converted to frame space)
                fontPx: fontPxFrame,
                lineSpacingPx: lineSpacingPxFrame,
                letterSpacingPx: letterSpacingPxFrame,
                fontFamily: 'DejaVu Sans',  // Always send base family
                fontStyle: s.fontStyle,
                weightCss: s.weightCss,
                previewFontString: (() => {
                    const baseFamily = 'DejaVu Sans';
                    const weightToken = (String(s.weightCss) === '700' || s.weightCss === 'bold') ? 'bold' : 'normal';
                    return `${s.fontStyle} ${weightToken} ${fontPxFrame}px "${baseFamily}"`;
                })(),

                // Raster box (tight to the content box)
                rasterW: rW,
                rasterH: rH,
                rasterPadding: paddingFramePx, // legacy
                padTop,
                padBottom,

                // Placement in frame space
                xPx_png,                          // or use xExpr_png='(W-overlay_w)/2' if you center
                yPx_png,

                // Frame (unchanged)
                frameW, frameH,
            };
            
            // Font parity verification log
            console.log('[font-parity:client]', {
                previewFontString: browserGeometry.previewFontString,
                fontFamily: browserGeometry.fontFamily,
                fontStyle: browserGeometry.fontStyle,
                weightCss: browserGeometry.weightCss
            });
            
            // AUDIT: Log build-raster font construction
            console.info('[AUDIT:CLIENT:build-raster]', {
                previewFontString: browserGeometry.previewFontString,
                fontFamily: browserGeometry.fontFamily,
                weightCss: browserGeometry.weightCss,
                fontStyle: browserGeometry.fontStyle
            });
            
            return browserGeometry;
        }

        // Save Preview function (SSOT workflow)
        async function savePreview(buttonElement = null) {
            if (!window.auth?.currentUser) {
                alert('Please log in to save preview');
                return false;
            }

            const saveBtn = buttonElement || document.getElementById('save-preview-btn');
            const originalText = saveBtn ? saveBtn.textContent : 'Save Preview';
            
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
            }

            try {
                // Wait for fonts to be ready before measuring DOM
                await document.fonts.ready;
                
                // Actively load all DejaVu Sans variants
                const fontsReady = await ensureDejaVuVariantsReady(3000);
                if (!fontsReady) {
                    // TTFs are fetched; don't hard-block the user
                    // Continue with soft warning - parity is still very likely correct
                    console.warn('[savePreview] Proceeding even though some faces did not confirm via check()');
                }
                
                // Get current caption meta from overlay system
                const meta = window.getCaptionMeta();
                
                if (!meta || !meta.text || !meta.text.trim()) {
                    alert('Please add caption text first');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = originalText;
                    }
                    return false;
                }
                
                // Find the correct elements for browser measurement
                const liveEl = document.getElementById('caption-live');
                const stageEl = document.querySelector('.caption-box') || liveEl?.parentElement;
                const overlayEl = document.querySelector('.caption-box .content');
                const contentEl = overlayEl || liveEl; // Prefer overlay, fallback to live
                const container = document.getElementById('live-preview-container');
                const previewCssW = container?.clientWidth || 360;
                
                if (!contentEl) {
                    alert('Preview text element not found');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = originalText;
                    }
                    return false;
                }
                
                // Diagnostic logging (temporary)
                console.log('[savePreview:element-debug]', {
                    using: overlayEl ? '.caption-box .content' : '#caption-live',
                    clientWidth: contentEl?.clientWidth,
                    styleWidth: getComputedStyle(contentEl).width,
                    padL: getComputedStyle(contentEl).paddingLeft,
                    padR: getComputedStyle(contentEl).paddingRight,
                    font: getComputedStyle(contentEl).font,
                    textPreview: (contentEl?.innerText || '').slice(0, 60),
                });
                
                // Get browser-rendered geometry using shared line extraction
                const browserGeometry = buildRasterFromBrowser({
                    stageEl,
                    contentEl,
                    frameW: 1080,
                    frameH: 1920,
                    previewCssW
                });
                
                // Validate browser geometry
                if (browserGeometry.lines.length < 1) {
                    alert('Unable to detect text lines - please try again');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = originalText;
                    }
                    return false;
                }
                
                // SSOT-first: use window.__serverCaptionMeta if available
                const ssot = window.__serverCaptionMeta || {};
                const cs = liveEl ? getComputedStyle(liveEl) : null;
                const scale = (typeof window.computePreviewScale === 'function') 
                              ? window.computePreviewScale() : 0.333;

                // Guard helper for numeric values
                const guardNum = (val, fallback) => Number.isFinite(val) ? val : fallback;

                // Typography
                const fontFamily = ssot.fontFamily || meta.fontFamily || 'DejaVu Sans';
                const fontPx = guardNum(ssot.fontPx, guardNum(meta.fontPx, 48));
                const lineSpacingPx = guardNum(ssot.lineSpacingPx, guardNum(meta.lineSpacingPx, 8));
                const letterSpacingPx = guardNum(ssot.letterSpacingPx, 0);
                const weightCss = ssot.weightCss || meta.weightCss || '700';
                const fontStyle = ssot.fontStyle || 'normal';
                const textAlign = ssot.textAlign || meta.textAlign || 'center';
                const textTransform = ssot.textTransform || 'none';

                // Color & effects
                const color = ssot.color || meta.color || 'rgb(255,255,255)';
                const opacity = guardNum(ssot.opacity, guardNum(meta.opacity, 0.85));
                const strokePx = guardNum(ssot.strokePx, 0);
                const strokeColor = ssot.strokeColor || 'rgba(0,0,0,0.85)';
                const shadowColor = ssot.shadowColor || 'rgba(0,0,0,0.6)';
                const shadowBlur = guardNum(ssot.shadowBlur, 12);
                const shadowOffsetX = guardNum(ssot.shadowOffsetX, 0);
                const shadowOffsetY = guardNum(ssot.shadowOffsetY, 2);

                // Geometry
                const rasterW = guardNum(ssot.rasterW, 864);
                const rasterH = guardNum(ssot.rasterH, 200);
                const yPx_png = guardNum(ssot.yPx_png, 960);
                const rasterPadding = guardNum(ssot.rasterPadding, 24);
                const xExpr_png = ssot.xExpr_png || '(W-overlay_w)/2';

                // Get raw text from overlay input (source of truth for user edits)
                // Use currentQuote as source of truth instead of visual DOM element
                // This prevents innerText from corrupting text with missing spaces at line breaks
                const textRaw = 
                  (currentQuote?.text?.trim()) ||
                  (document.querySelector('#caption-input')?.value?.trim()) ||
                  (liveEl?.textContent?.trim()) ||  // textContent preserves text nodes better than innerText
                  meta.text || '';
                
                // Normalize for server and downstream features:
                // - Convert newlines to spaces
                // - Collapse multiple spaces into one
                // - Trim whitespace
                const text = textRaw.replace(/\s*\n\s*/g, ' ').replace(/\s+/g, ' ').trim();

                const payload = {
                    ssotVersion: 3,
                    mode: 'raster',
                    textRaw,  // NEW: preserve original with newlines
                    text,     // normalized canonical version
                    
                    // Browser-rendered line data (REQUIRED)
                    lines: browserGeometry.lines,              // string[] - the actual line text (server derives count from lines.length)
                    totalTextH: browserGeometry.totalTextH,
                    yPxFirstLine: browserGeometry.yPxFirstLine,
                    
                    // Typography (from browser)
                    fontFamily: browserGeometry.fontFamily,
                    fontPx: browserGeometry.fontPx,
                    lineSpacingPx: browserGeometry.lineSpacingPx,
                    letterSpacingPx: browserGeometry.letterSpacingPx,
                    weightCss: browserGeometry.weightCss,
                    fontStyle: browserGeometry.fontStyle,
                    previewFontString: browserGeometry.previewFontString,
                    textAlign,
                    textTransform,
                    
                    // Color & effects (from existing logic)
                    color,
                    opacity,
                    strokePx,
                    strokeColor,
                    shadowColor,
                    shadowBlur,
                    shadowOffsetX,
                    shadowOffsetY,
                    
                    // Geometry (from browser)
                    rasterW: browserGeometry.rasterW,
                    rasterH: browserGeometry.rasterH,
                    rasterPadding: browserGeometry.rasterPadding,
                    xPx_png: browserGeometry.xPx_png,
                    yPx_png: browserGeometry.yPx_png,
                    xExpr_png,
                    
                    // Client canonical values for server (required for V3 raster)
                    clientRasterW: browserGeometry.rasterW,
                    clientRasterH: browserGeometry.rasterH,
                    clientRasterPadding: browserGeometry.rasterPadding,
                    
                    // Frame dimensions
                    frameW: 1080,
                    frameH: 1920
                };

                // Derive V2 percentage fields from SSOT raster values for backward compatibility
                const frameW = 1080, frameH = 1920;
                payload.wPct = Number.isFinite(browserGeometry.rasterW) ? +(browserGeometry.rasterW / frameW).toFixed(6) : undefined;
                // Clamp yPct to [0, 1] range to prevent negative values
                const rawYPct = Number.isFinite(browserGeometry.yPx_png) ? +(browserGeometry.yPx_png / frameH).toFixed(6) : undefined;
                if (Number.isFinite(rawYPct)) {
                    payload.yPct = Math.max(0, Math.min(1, rawYPct));
                    if (rawYPct < 0 || rawYPct > 1) {
                        console.warn('[savePreview] Clamped yPct from', rawYPct, 'to', payload.yPct);
                    }
                } else {
                    payload.yPct = undefined;
                }
                payload.xPct = Number.isFinite(payload.wPct) ? +((1 - payload.wPct) / 2).toFixed(6) : undefined;

                // Validate payload before POST
                const preNormalizationFields = ['totalTextH', 'yPxFirstLine', 'rasterW', 'rasterH', 'fontPx', 'lineSpacingPx', 'letterSpacingPx'];
                const preInvalidFields = preNormalizationFields.filter(field => !Number.isFinite(payload[field]));
                
                if (preInvalidFields.length > 0) {
                    throw new Error(`Invalid numeric fields: ${preInvalidFields.join(', ')}`);
                }
                
                if (!Array.isArray(payload.lines) || payload.lines.length === 0) {
                    throw new Error('lines must be a non-empty array');
                }
                

                console.log('[savePreview] Final payload (before normalization):', payload);

                // ‚úÖ Normalize payload for server strict validation
                const normalizedPayload = normalizeRasterPayload(payload);

                // AUDIT: Log final payload before POST
                console.info('[AUDIT:CLIENT:final-payload]', {
                    previewFontString: normalizedPayload.previewFontString,
                    fontFamily: normalizedPayload.fontFamily,
                    weightCss: normalizedPayload.weightCss,
                    fontStyle: normalizedPayload.fontStyle,
                    sample: (normalizedPayload.text ?? '').slice(0, 60)
                });
                
                // ‚úÖ Comprehensive validation of normalized payload
                const numericFields = ['frameW', 'frameH', 'rasterW', 'rasterH', 'rasterPadding', 'fontPx', 'lineSpacingPx', 'letterSpacingPx', 'totalTextH', 'yPxFirstLine', 'xPx_png', 'yPx_png'];
                const invalidFields = numericFields.filter(field => {
                    const val = normalizedPayload[field];
                    return !Number.isFinite(val) || !Number.isInteger(val);
                });
                
                if (invalidFields.length > 0) {
                    console.error('[savePreview:validation] Invalid numeric fields after normalization:', invalidFields);
                    throw new Error(`Normalization failed for fields: ${invalidFields.join(', ')}`);
                }
                
                // Guard against negative or NaN yPx_png
                if (normalizedPayload.yPx_png < 0 || !Number.isFinite(normalizedPayload.yPx_png)) {
                    console.error('[savePreview:validation] Invalid yPx_png:', normalizedPayload.yPx_png);
                    throw new Error(`yPx_png must be >= 0, got: ${normalizedPayload.yPx_png}`);
                }
                
                
                // Validate string fields are present
                const stringFields = ['fontFamily', 'fontStyle', 'weightCss', 'previewFontString'];
                const missingStringFields = stringFields.filter(field => !normalizedPayload[field] || normalizedPayload[field].trim() === '');
                
                if (missingStringFields.length > 0) {
                    console.warn('[savePreview:validation] Missing string fields:', missingStringFields);
                }
                
                // Log normalized payload for debugging
                console.log('[savePreview:normalized]', {
                    frameW: normalizedPayload.frameW,
                    frameH: normalizedPayload.frameH,
                    rasterW: normalizedPayload.rasterW,
                    rasterH: normalizedPayload.rasterH,
                    fontPx: normalizedPayload.fontPx,
                    lineSpacingPx: normalizedPayload.lineSpacingPx,
                    letterSpacingPx: normalizedPayload.letterSpacingPx,
                    yPx_png: normalizedPayload.yPx_png,
                    xPx_png: normalizedPayload.xPx_png,
                    lines: normalizedPayload.lines?.length || 0,
                    allIntegers: numericFields.every(field => Number.isInteger(normalizedPayload[field])),
                    allNonNegative: ['xPx_png'].every(field => normalizedPayload[field] >= 0)
                });

                console.log('[savePreview:parity]', {
                    hasSSOT: !!window.__serverCaptionMeta,
                    fontPx: normalizedPayload.fontPx,
                    lineSpacingPx: normalizedPayload.lineSpacingPx,
                    letterSpacingPx: normalizedPayload.letterSpacingPx,
                    rasterW: normalizedPayload.rasterW,
                    rasterH: normalizedPayload.rasterH,
                    yPx_png: normalizedPayload.yPx_png,
                    rasterPadding: normalizedPayload.rasterPadding,
                    lines: normalizedPayload.lines?.length || 0,
                    linesCount: normalizedPayload.lines?.length,
                    allNumsFinite: Object.entries(normalizedPayload)
                        .filter(([k, v]) => typeof v === 'number')
                        .every(([k, v]) => Number.isFinite(v))
                });

                // Preflight validation to catch MISSING_SPLITLINES early
                console.log('[preflight]', {
                    hasLinesArray: Array.isArray(normalizedPayload.lines),
                    linesLen: normalizedPayload.lines?.length,
                });

                // Diagnostic logging of final payload before POST
                console.log('[savePreview:final]', { 
                    keys: Object.keys(normalizedPayload), 
                    textLen: normalizedPayload.text?.length, 
                    textRawLen: normalizedPayload.textRaw?.length,
                    sample: normalizedPayload.text?.slice(0, 80),
                    hasText: !!normalizedPayload.text,
                    hasTextRaw: !!normalizedPayload.textRaw,
                    linesCount: normalizedPayload.lines?.length || 0
                });

                // Call preview API with normalized payload
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/caption/preview', {
                    method: 'POST',
                    body: normalizedPayload
                });

                if (!data?.ok) {
                    throw new Error(data?.detail || data?.reason || 'Preview generation failed');
                }

                console.log('[savePreview] Preview saved successfully:', data.data.meta);

                // CRITICAL: Read from correct locations
                const resp = data?.data || {};
                const m = resp.meta || {};

                // Accept both field names from server (coerce to numbers)
                const totalTextH = Number(m.totalTextH ?? m.totalTextHPx);
                const serverLineSpacingPx = Number(m.lineSpacingPx ?? 0);
                const linesCount = m.lines?.length || 0;

                // Server-authoritative geometry - overwrite client values
                const serverRasterW = Number.isFinite(m.rasterW) ? m.rasterW : rasterW;
                const serverRasterH = Number.isFinite(m.rasterH) ? m.rasterH : 200;
                const serverRasterPadding = Number.isFinite(m.rasterPadding) ? m.rasterPadding : rasterPadding;
                let serverYPxPng = Number.isFinite(m.yPx_png) ? m.yPx_png : null;
                const serverXExprPng = m.xExpr_png || xExpr_png;
                const serverPreviewFontString = m.previewFontString || '';
                const serverPreviewFontHash = m.previewFontHash || '';

                // If server omits yPx_png, compute via toRasterYPx helper
                if (!Number.isFinite(serverYPxPng)) {
                    const frameH = m.frameH || 1920;
                    const placement = m.placement || 'center';
                    const yPct = m.yPct || 0.5;
                    serverYPxPng = toRasterYPx({frameH, rasterH: serverRasterH, placement, yPct, internalPaddingPx: serverRasterPadding});
                    console.log('[savePreview] Computed yPx_png from placement:', {placement, yPct, serverYPxPng});
                }

                // Compute yPxFirstLine from yPx_png + rasterPadding (server no longer returns top-level yPx)
                const yPxFirstLine = Number.isFinite(serverYPxPng) && Number.isFinite(serverRasterPadding)
                    ? serverYPxPng + serverRasterPadding
                    : NaN;

                // Verify we got real values before saving
                console.log('[savePreview] SSOT fields extracted:', {
                    totalTextH,
                    yPxFirstLine,
                    lineSpacingPx,
                    lines: linesCount,
                    serverRasterW,
                    serverRasterH,
                    serverYPxPng,
                    serverRasterPadding,
                    source: {
                        'data.yPx': resp.yPx,
                        'meta.totalTextH': m.totalTextH,
                        'meta.totalTextHPx': m.totalTextHPx,
                        'meta.lines': m.lines?.length
                    }
                });

                const normalizedMeta = {
                    ssotVersion: 3,
                    mode: 'raster',
                    
                    // Pass through ALL server SSOT fields verbatim
                    text: m.text || meta.text,
                    
                    // Geometry lock (render frame dimensions)
                    frameW: m.frameW,
                    frameH: m.frameH,
                    bgScaleExpr: m.bgScaleExpr,
                    bgCropExpr: m.bgCropExpr,
                    
                    // PNG raster data - use server-authoritative values
                    rasterUrl: m.rasterUrl,
                    rasterW: serverRasterW,
                    rasterH: serverRasterH,
                    rasterPadding: serverRasterPadding,  // CRITICAL
                    
                    // PNG placement (absolute coordinates) - use server-authoritative values
                    xExpr_png: serverXExprPng,
                    yPx_png: serverYPxPng,  // Server-computed or computed via helper
                    
                    // Verification hashes - use server values
                    rasterHash: m.rasterHash,
                    previewFontString: serverPreviewFontString,
                    previewFontHash: serverPreviewFontHash,
                    
                    // Typography (informational only for v3 raster)
                    fontPx: Number(m.fontPx || meta.fontPx || 48),
                    fontFamily: m.fontFamily || meta.fontFamily || 'DejaVu Sans',
                    weightCss: m.weightCss || meta.weightCss || 'normal',
                    fontStyle: m.fontStyle || 'normal',
                    textAlign: m.textAlign || 'center',
                    letterSpacingPx: Number(m.letterSpacingPx ?? 0),
                    textTransform: m.textTransform || 'none',
                    
                    // Color & effects (informational)
                    color: m.color || meta.color || '#ffffff',
                    opacity: Number(m.opacity ?? meta.opacity ?? 1.0),
                    strokePx: Number(m.strokePx ?? 0),
                    strokeColor: m.strokeColor || 'rgba(0,0,0,0.85)',
                    shadowColor: m.shadowColor || 'rgba(0,0,0,0.6)',
                    shadowBlur: Number(m.shadowBlur ?? 12),
                    shadowOffsetX: Number(m.shadowOffsetX ?? 0),
                    shadowOffsetY: Number(m.shadowOffsetY ?? 2),
                    
                    // Layout (informational)
                    placement: m.placement || 'custom',
                    internalPadding: Number(m.internalPadding ?? 32),
                    
                    // Diagnostics (keep for debugging, NOT used in render)
                    lineSpacingPx: serverLineSpacingPx,
                    lines: Array.isArray(m.lines) ? m.lines : [],
                    totalTextH: Number(m.totalTextH ?? 0),
                    
                    // Legacy compatibility fields (deprecated for v3 raster)
                    totalTextHPx: totalTextH,
                    yPxFirstLine: yPxFirstLine,
                    xPct: Number(m.xPct ?? meta.xPct ?? 0.5),
                    // PRIMARY FIX: Clamp yPct to [0, 1] range to prevent negative values
                    yPct: (() => {
                        const rawYPct = Number(m.yPct ?? meta.yPct ?? 0.5);
                        const clamped = Math.max(0, Math.min(1, rawYPct));
                        if (rawYPct < 0 || rawYPct > 1) {
                            console.warn('[savePreview] Clamped normalizedMeta.yPct from', rawYPct, 'to', clamped);
                        }
                        return clamped;
                    })(),
                    wPct: Number(m.wPct ?? meta.wPct ?? 0.8),
                    
                    // Additional raster aliases for compatibility
                    rasterDataUrl: m.rasterUrl,
                    rasterPng: m.rasterUrl,
                    xExpr: m.xExpr_png || '(W-overlay_w)/2'
                };

                // V3 raster mode validation - ensure all required fields are present
                if (normalizedMeta.mode === 'raster') {
                    const requiredRasterFields = [
                        'rasterUrl', 'rasterW', 'rasterH', 
                        'yPx_png', 'rasterPadding',
                        'frameW', 'frameH', 'bgScaleExpr', 'bgCropExpr',
                        'rasterHash', 'previewFontString'
                    ];
                    
                    const missingFields = requiredRasterFields.filter(f => normalizedMeta[f] == null);
                    
                    if (missingFields.length > 0) {
                        console.error('[savePreview-ERROR] Missing raster fields:', missingFields);
                        throw new Error(`Server returned incomplete raster metadata. Missing: ${missingFields.join(', ')}`);
                    }
                    
                console.log('[savePreview-v3] ‚úÖ All raster fields present (server-authoritative):', {
                    yPx_png: normalizedMeta.yPx_png,
                    rasterW: normalizedMeta.rasterW,
                    rasterH: normalizedMeta.rasterH,
                    rasterPadding: normalizedMeta.rasterPadding,
                    frameW: normalizedMeta.frameW,
                    frameH: normalizedMeta.frameH,
                    rasterHash: normalizedMeta.rasterHash?.slice(0, 8) + '...',
                    xExpr_png: normalizedMeta.xExpr_png,
                    previewFontString: normalizedMeta.previewFontString?.slice(0, 20) + '...'
                });
                }

                // Client-side guard: warn if raster dimensions look like full canvas
                if (normalizedMeta.mode === 'raster' &&
                    normalizedMeta.rasterW === 1080 &&
                    normalizedMeta.rasterH === 1920) {
                    console.warn('[client-guard] Raster size looks like full canvas. Preview meta not wired correctly.');
                }

                // Store normalized overlay meta for render (SSOT)
                window._overlayMeta = normalizedMeta;
                window.lastCaptionPNG = {
                    dataUrl: data.data?.imageUrl,
                    width: data.data?.wPx || 1080,
                    height: data.data?.hPx || 1920,
                    meta: normalizedMeta
                };
                window.__lastCaptionOverlay = window.lastCaptionPNG;

                // Persist to localStorage for "Save Preview" workflow (V3 storage key)
                try {
                    localStorage.setItem('overlayMetaV3', JSON.stringify(normalizedMeta));
                    console.log('[v3:savePreview] saved', { 
                        v: normalizedMeta.ssotVersion, 
                        mode: normalizedMeta.mode,
                        keys: Object.keys(normalizedMeta),
                        hasRaster: !!normalizedMeta.rasterUrl || !!normalizedMeta.rasterDataUrl
                    });
                } catch (err) {
                    console.warn('[savePreview] Failed to save to localStorage:', err.message);
                }

                // Set flag indicating preview is saved for current text
                window._previewSavedForCurrentText = true;
                console.log('[preview-state] Preview saved successfully for current caption text');
                
                // Mark preview as saved in overlay system (clears geometry dirty, enables raster mode)
                try {
                    const { markPreviewSaved } = await import('./js/caption-overlay.js');
                    markPreviewSaved();
                    console.log('[preview-state] Preview saved successfully, switching to raster mode');
                } catch (err) {
                    console.warn('[preview-state] Failed to mark preview as saved:', err);
                }
                
                // Apply saved server meta to live preview immediately
                if (typeof window.updateCaptionState === 'function' && normalizedMeta) {
                    // CRITICAL: Set server SSOT first
                    window.__serverCaptionMeta = normalizedMeta;
                    
                    const liveEl = document.getElementById('caption-live');
                    if (liveEl) {
                        // Build COMPLETE SSOT v3 raster state from normalizedMeta
                        const currentState = {
                            // Identity - use textRaw to preserve user's intended wraps
                            text: normalizedMeta.textRaw || normalizedMeta.text || '',
                            
                            // CRITICAL: Tell live layer to use raster branch
                            mode: normalizedMeta.mode || 'raster',
                            
                            // Geometry (raster) - ensure finite numbers
                            rasterW: Number.isFinite(normalizedMeta.rasterW) ? normalizedMeta.rasterW : 1080,
                            rasterH: Number.isFinite(normalizedMeta.rasterH) ? normalizedMeta.rasterH : 200,
                            rasterPadding: Number.isFinite(normalizedMeta.rasterPadding) ? normalizedMeta.rasterPadding : 24,
                            yPx_png: Number.isFinite(normalizedMeta.yPx_png) ? normalizedMeta.yPx_png : 24,
                            xExpr_png: normalizedMeta.xExpr_png || '(W-overlay_w)/2',
                            
                            // Typography - ensure finite numbers with safe defaults
                            fontFamily: normalizedMeta.fontFamily || 'DejaVu Sans',
                            fontPx: Number.isFinite(normalizedMeta.fontPx) ? normalizedMeta.fontPx : 48,
                            lineSpacingPx: Number.isFinite(normalizedMeta.lineSpacingPx) ? normalizedMeta.lineSpacingPx : 8,
                            letterSpacingPx: Number.isFinite(normalizedMeta.letterSpacingPx) ? normalizedMeta.letterSpacingPx : 0,
                            weightCss: normalizedMeta.weightCss || 'bold',
                            fontStyle: normalizedMeta.fontStyle || 'normal',
                            textAlign: normalizedMeta.textAlign || 'center',
                            textTransform: normalizedMeta.textTransform || 'none',
                            
                            // Colors & effects - ensure finite numbers with safe defaults
                            color: normalizedMeta.color || '#ffffff',
                            opacity: Number.isFinite(normalizedMeta.opacity) ? normalizedMeta.opacity : 1.0,
                            strokePx: Number.isFinite(normalizedMeta.strokePx) ? normalizedMeta.strokePx : 0,
                            strokeColor: normalizedMeta.strokeColor || 'rgba(0,0,0,0.85)',
                            shadowColor: normalizedMeta.shadowColor || 'rgba(0,0,0,0.6)',
                            shadowBlur: Number.isFinite(normalizedMeta.shadowBlur) ? normalizedMeta.shadowBlur : 12,
                            shadowOffsetX: Number.isFinite(normalizedMeta.shadowOffsetX) ? normalizedMeta.shadowOffsetX : 0,
                            shadowOffsetY: Number.isFinite(normalizedMeta.shadowOffsetY) ? normalizedMeta.shadowOffsetY : 2,
                            
                            // SSOT metadata
                            ssotVersion: normalizedMeta.ssotVersion || 3,
                            
                            // Legacy compatibility fields (informational only)
                            xPct: normalizedMeta.xPct || 0.5,
                            yPct: normalizedMeta.yPct || 0.5,
                            wPct: normalizedMeta.wPct || 0.8
                        };
                        
                        window.updateCaptionState(currentState);
                        console.log('[savePreview] Applied complete SSOT v3 raster state to live preview');
                    }
                }
                
                // Debug: Log what was saved
                console.log('[savePreview] Saved meta details:', {
                    mode: normalizedMeta.mode,
                    ssotVersion: normalizedMeta.ssotVersion,
                    text: normalizedMeta.text,
                    textLength: normalizedMeta.text?.length,
                    // Raster specifics
                    yPx_png: normalizedMeta.yPx_png,
                    rasterW: normalizedMeta.rasterW,
                    rasterH: normalizedMeta.rasterH,
                    rasterPadding: normalizedMeta.rasterPadding,
                    frameW: normalizedMeta.frameW,
                    frameH: normalizedMeta.frameH,
                    hasRasterUrl: !!normalizedMeta.rasterUrl,
                    rasterHash: normalizedMeta.rasterHash?.slice(0, 8) + '...'
                });
                
                // Sanity log: Show text diff snippet to catch regressions
                const normalizeForLog = (text) => (text || '').replace(/\s*\n\s*/g, ' ').replace(/\s+/g, ' ').trim();
                const savedNormalized = normalizeForLog(normalizedMeta.textRaw || normalizedMeta.text);
                const currentNormalized = normalizeForLog(currentQuote?.text || liveEl?.textContent);
                console.log('[savePreview:sanity] Text diff snippet:', {
                    savedRaw: (normalizedMeta.textRaw || '').substring(0, 50),
                    savedNormalized: savedNormalized.substring(0, 50),
                    currentNormalized: currentNormalized.substring(0, 50),
                    equality: savedNormalized === currentNormalized
                });
                
                // Debug: Verify functions are available
                console.log('[savePreview] Function availability after save:', {
                    getSavedOverlayMeta: !!window.getSavedOverlayMeta,
                    getCaptionMeta: !!window.getCaptionMeta,
                    previewSavedFlag: window._previewSavedForCurrentText
                });

                // --- OPTIONAL overlay / debug work below. Must never block a successful save. ---

                // Hide Save Preview button and show success indicator
                if (saveBtn) {
                    saveBtn.style.display = 'none';
                }
                
                // Show success indicator
                if (typeof window.showPreviewSavedIndicator === 'function') {
                    window.showPreviewSavedIndicator('#preview-status');
                } else {
                    // Fallback: directly update the preview status container
                    const container = document.querySelector('#preview-status');
                    if (container) {
                        container.innerHTML = `
                            <div class="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded text-sm">
                                <span>‚úì</span>
                                <span>Preview saved - ready to render</span>
                            </div>
                        `;
                        container.classList.remove('hidden');
                    }
                    console.warn('[savePreview] showPreviewSavedIndicator not available, using fallback');
                }
                
                // Enable render button (after localStorage save is complete)
                updateRenderButtonState();
                
                // ‚úÖ NEW: Show server PNG for WYSIWYG guarantee
                if (normalizedMeta?.rasterUrl) {
                    try {
                        const { showServerPNG } = await import('./js/caption-live.js');
                        showServerPNG(normalizedMeta.rasterUrl, normalizedMeta);
                        console.log('[savePreview] Swapped to server PNG for WYSIWYG');
                    } catch (error) {
                        console.warn('[savePreview] Failed to swap to PNG:', error);
                    }
                }
                
                // Preview saved successfully
                return true;

            } catch (error) {
                console.error('[savePreview] Error:', error);
                const msg = error?.message || String(error || '');
                const isStyleNull = msg.includes("Cannot read properties of null (reading 'style')");
                
                const metaAvailable = (() => {
                    try {
                        return typeof window.getSavedOverlayMeta === 'function' && !!window.getSavedOverlayMeta();
                    } catch (_) {
                        return false;
                    }
                })();
                
                if (isStyleNull && metaAvailable) {
                    console.warn('[savePreview][nonfatal] style=null after successful save, ignoring.', { msg });
                    return true;
                }
                
                alert(`Save preview failed: ${msg}`);
                return false;
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                }
            }
        }

        // Combined Create function (Save Preview + Render)
        async function createShort() {
            const renderBtn = document.getElementById('render-btn');
            const mobileCreateBtn = document.getElementById('mobile-create-btn');
            if (!renderBtn && !mobileCreateBtn) return;
            
            const originalText = renderBtn?.textContent || mobileCreateBtn?.textContent || 'Create';
            
            try {
                // Step 1: Save Preview
                if (renderBtn) {
                    renderBtn.disabled = true;
                    renderBtn.textContent = 'Saving preview...';
                }
                if (mobileCreateBtn) {
                    mobileCreateBtn.disabled = true;
                    mobileCreateBtn.textContent = 'Saving preview...';
                }
                
                const previewSaved = await savePreview(renderBtn || mobileCreateBtn);
                if (!previewSaved) {
                    // Error already shown by savePreview
                    if (renderBtn) {
                        renderBtn.disabled = false;
                        renderBtn.textContent = originalText;
                    }
                    if (mobileCreateBtn) {
                        mobileCreateBtn.disabled = false;
                        mobileCreateBtn.textContent = originalText;
                    }
                    return;
                }
                
                // Step 2: Render (renderShort will handle its own button state)
                await renderShort();
                
            } catch (error) {
                console.error('[createShort] Error:', error);
                alert(`Failed to create short: ${error.message}`);
                if (renderBtn) {
                    renderBtn.disabled = false;
                    renderBtn.textContent = originalText;
                }
                if (mobileCreateBtn) {
                    mobileCreateBtn.disabled = false;
                    mobileCreateBtn.textContent = originalText;
                }
            }
        }

        // Render short function
        async function renderShort() {
            // Require at least one feature (quote, asset, or voiceover)
            if (!currentQuote && !selectedAsset && !currentVoiceId) {
                alert('Please add a quote, select media, or choose a voiceover first');
                return;
            }

            if (!window.auth?.currentUser) {
                alert('Please log in to render shorts');
                return;
            }

            const renderBtn = document.getElementById('render-btn');
            const mobileCreateBtn = document.getElementById('mobile-create-btn');
            const originalText = renderBtn?.textContent || mobileCreateBtn?.textContent || 'Create';
            
            if (renderBtn) {
                renderBtn.disabled = true;
                renderBtn.textContent = 'Rendering...';
            }
            if (mobileCreateBtn) {
                mobileCreateBtn.disabled = true;
                mobileCreateBtn.textContent = 'Rendering...';
            }

            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Prepare the render payload with proper background structure (optional)
                let background = null;
                
                if (selectedAsset) {
                    const assetUrl = selectedAsset.fileUrl || selectedAsset.url;
                    
                    // Detect type from URL extension
                    const detectTypeFromUrl = (url) => {
                        if (!url) return 'image'; // Default fallback
                        
                        try {
                            // Handle URLs with query parameters or fragments
                            const cleanUrl = url.split('?')[0].split('#')[0];
                            const ext = cleanUrl.toLowerCase().split('.').pop();
                            
                            console.log(`[typeDetection] URL: ${url}`);
                            console.log(`[typeDetection] Clean URL: ${cleanUrl}`);
                            console.log(`[typeDetection] Extension: ${ext}`);
                            
                            if (['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', '3gp', 'flv'].includes(ext)) {
                                return 'video';
                            }
                            if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg', 'tiff'].includes(ext)) {
                                return 'image';
                            }
                            
                            // Default fallback
                            console.log(`[typeDetection] Unknown extension: ${ext}, defaulting to image`);
                            return 'image';
                        } catch (error) {
                            console.error(`[typeDetection] Error parsing URL: ${error.message}`);
                            return 'image'; // Safe fallback
                        }
                    };
                    
                    const detectedType = detectTypeFromUrl(assetUrl);
                    
                    console.log(`[render] Asset URL: ${assetUrl}`);
                    console.log(`[render] Detected type: ${detectedType}`);
                    
                    background = {
                        kind: selectedAsset.provider === 'ai' ? 'ai' : 
                              selectedAsset.provider === 'uploaded' ? 'upload' : 'stock',
                        type: detectedType, // Use detected type from URL
                        url: assetUrl, // Required URL
                        query: selectedAsset.query,
                        // Legacy fields for backward compatibility
                        imageUrl: selectedAsset.provider === 'uploaded' ? selectedAsset.fileUrl : undefined,
                        prompt: selectedAsset.provider === 'ai' ? selectedAsset.query : undefined
                    };
                } else {
                    console.log('[render] No asset selected - will render with black background');
                }

                // Get caption style settings
                const captionStyle = {
                    font: document.getElementById('caption-font').value,
                    weight: document.getElementById('caption-weight').value,
                    sizePx: window.getCaptionPx(),
                    opacity: parseInt(document.getElementById('caption-opacity').value) / 100,
                    placement: document.getElementById('caption-placement').value,
                    showBox: document.getElementById('caption-background').checked,
                    boxOpacity: parseInt(document.getElementById('caption-bg-opacity').value) / 100
                };
                
                // --- BEGIN strictly-typed payload construction ---

                // 1) Get current quote text safely as a string
                const quoteText = ((currentQuote && currentQuote.text) || '').toString();

                // 2) Get mapped and clamped font size
                const sizePx = window.getCaptionPx();

                // 3) Find last generated overlay from preview step
                //    (caption-preview.js should already be writing this)
                const overlay = window.__lastCaptionOverlay;
                // overlay shape we expect: { dataUrl: 'data:image/png;base64,...', width, height, meta: {...} }
                const overlayDataUrl = overlay && typeof overlay.dataUrl === 'string' ? overlay.dataUrl : undefined;

                // 4) Voice handling (don't change existing selection logic‚Äîjust make sure we send strings)
                const voiceId = (currentVoiceId || '').toString();
                const wantVoiceover = !!currentVoiceId; // keep existing toggle, but normalize to boolean

                // 5) Background (use what the page already computed)
                const bg = background; // must be whatever your UI already sets up

                // 6) Build payload with correct conditional logic
                let payload = {
                  mode: 'quote',
                  template: 'calm',
                  durationSec: 8,
                  voiceover: wantVoiceover,
                  includeBottomCaption: true,
                  wantAttribution: true,
                  watermark: true,

                  // strings only
                  text: quoteText,
                  ttsText: wantVoiceover ? quoteText : '',

                  // keep existing background contract
                  background: bg,

                  // pass voice id only if voiceover is on (string type)
                  voiceId: wantVoiceover && voiceId ? voiceId : undefined,
                  
                  // TTS settings for SSOT (normalized to 0-1 range)
                  modelId: wantVoiceover ? 'eleven_multilingual_v2' : undefined,
                  outputFormat: wantVoiceover ? 'mp3_44100_128' : undefined,
                  voiceSettings: wantVoiceover ? {
                    stability: parseFloat(document.getElementById('tts-stability').value),
                    similarity_boost: parseFloat(document.getElementById('tts-similarity').value),
                    style: Math.max(0, Math.min(1, parseInt(document.getElementById('tts-style').value) / 100)), // Normalize 0-100 to 0-1
                    use_speaker_boost: document.getElementById('tts-speaker-boost').checked
                  } : undefined,
                };

                // SSOT: Use saved overlay meta from preview
                if (useOverlayMode && overlaySystemInitialized) {
                  // Validate saved preview before rendering
                  const validation = window.validateBeforeRender ? window.validateBeforeRender() : { valid: false, errors: ['Preview not saved'] };
                  
                  if (!validation.valid) {
                    alert(`Cannot render: ${validation.errors.join(', ')}`);
                    if (renderBtn) {
                        renderBtn.disabled = false;
                        renderBtn.textContent = originalText;
                    }
                    if (mobileCreateBtn) {
                        mobileCreateBtn.disabled = false;
                        mobileCreateBtn.textContent = originalText;
                    }
                    return;
                  }
                  
                  let savedMeta = validation.meta;
                  
                  // Validate ssotVersion and mode for v3 raster
                  const isRaster = savedMeta?.mode === 'raster';
                  if (savedMeta?.ssotVersion !== 3) {
                      console.error('[render-ERROR] Invalid ssotVersion, expected 3, got:', savedMeta?.ssotVersion);
                      alert('Preview data is outdated (wrong version). Please Save Preview again (v3).');
                      if (renderBtn) {
                          renderBtn.disabled = false;
                          renderBtn.textContent = originalText;
                      }
                      if (mobileCreateBtn) {
                          mobileCreateBtn.disabled = false;
                          mobileCreateBtn.textContent = originalText;
                      }
                      return;
                  }
                  
                  // V3 raster mode requires raster fields
                  if (isRaster && !savedMeta?.rasterUrl && !savedMeta?.rasterDataUrl) {
                      console.error('[render-ERROR] Raster mode requires rasterUrl, got:', savedMeta);
                      alert('Raster preview incomplete. Please Save Preview again (v3).');
                      if (renderBtn) {
                          renderBtn.disabled = false;
                          renderBtn.textContent = originalText;
                      }
                      if (mobileCreateBtn) {
                          mobileCreateBtn.disabled = false;
                          mobileCreateBtn.textContent = originalText;
                      }
                      return;
                  }
                  
                  console.log('[v3:client:POST]', {
                      ssotVersion: savedMeta.ssotVersion,
                      mode: savedMeta.mode,
                      hasRaster: !!savedMeta.rasterPng || !!savedMeta.rasterDataUrl || !!savedMeta.rasterUrl
                  });

                  // SSOT: Server is single source of truth - no client corrections
                  // Use saved meta exactly as provided by server
                  
                  // Server validates metrics properly - no need for overly restrictive client bounds
                  // Only check for clearly invalid values (NaN, negative, etc.)
                  if (!Number.isFinite(savedMeta.totalTextH) || savedMeta.totalTextH <= 0) {
                      console.error('[render-ERROR] Invalid totalTextH:', savedMeta.totalTextH);
                      alert('Preview data has invalid metrics. Please regenerate preview.');
                      if (renderBtn) {
                          renderBtn.disabled = false;
                          renderBtn.textContent = originalText;
                      }
                      if (mobileCreateBtn) {
                          mobileCreateBtn.disabled = false;
                          mobileCreateBtn.textContent = originalText;
                      }
                      return;
                  }
                  
                  // CRITICAL: Verify we're sending real numeric values, not undefined
                  console.log('[render-CRITICAL] overlayCaption being sent:', {
                    keys: Object.keys(savedMeta || {}),
                    totalTextH: savedMeta?.totalTextH,
                    totalTextHPx: savedMeta?.totalTextHPx,
                    yPxFirstLine: savedMeta?.yPxFirstLine,
                    lineSpacingPx: savedMeta?.lineSpacingPx,
                    lines: Array.isArray(savedMeta?.lines) ? savedMeta.lines.length : 0
                  });

                  // Guard: fail fast if critical SSOT fields are missing/invalid
                  if (!Number.isFinite(savedMeta?.totalTextH)) {
                    alert('Preview data incomplete (totalTextH missing). Please generate and save preview again.');
                    if (renderBtn) {
                        renderBtn.disabled = false;
                        renderBtn.textContent = originalText;
                    }
                    if (mobileCreateBtn) {
                        mobileCreateBtn.disabled = false;
                        mobileCreateBtn.textContent = originalText;
                    }
                    throw new Error('Missing SSOT field: totalTextH');
                  }

                  if (!Number.isFinite(savedMeta?.yPxFirstLine)) {
                    alert('Preview data incomplete (yPxFirstLine missing). Please generate and save preview again.');
                    if (renderBtn) {
                        renderBtn.disabled = false;
                        renderBtn.textContent = originalText;
                    }
                    if (mobileCreateBtn) {
                        mobileCreateBtn.disabled = false;
                        mobileCreateBtn.textContent = originalText;
                    }
                    throw new Error('Missing SSOT field: yPxFirstLine');
                  }

                  if (!Array.isArray(savedMeta?.lines) || savedMeta.lines.length === 0) {
                    alert('Preview data incomplete (lines missing). Please generate and save preview again.');
                    if (renderBtn) {
                        renderBtn.disabled = false;
                        renderBtn.textContent = originalText;
                    }
                    if (mobileCreateBtn) {
                        mobileCreateBtn.disabled = false;
                        mobileCreateBtn.textContent = originalText;
                    }
                    throw new Error('Missing SSOT field: lines');
                  }
                  
                  // Tiny safety net: Clamp yPct to [0, 1] if somehow still negative (defensive programming)
                  if (Number.isFinite(savedMeta.yPct) && (savedMeta.yPct < 0 || savedMeta.yPct > 1)) {
                    const clamped = Math.max(0, Math.min(1, savedMeta.yPct));
                    console.warn('[render] Safety net: Clamped savedMeta.yPct from', savedMeta.yPct, 'to', clamped);
                    savedMeta.yPct = clamped;
                  }
                  
                  payload.captionMode = 'overlay';
                  payload.overlayCaption = savedMeta; // Use saved meta directly (already normalized by server)
                  
                  // CRITICAL: Use the text from saved preview to ensure exact match
                  payload.text = savedMeta.text || quoteText;
                  payload.ttsText = wantVoiceover ? (savedMeta.text || quoteText) : '';
                  
                  // Verify text matching
                  console.log('[render-text-match] Using saved preview text:', {
                    savedText: savedMeta.text,
                    currentText: quoteText,
                    textMatch: savedMeta.text === quoteText,
                    finalPayloadText: payload.text
                  });
                  
                  // SSOT checkpoint before POST
                  console.log('[ssot/v2:client:POST]', {
                    ssotVersion: savedMeta.ssotVersion,
                    fontPx: savedMeta.fontPx,
                    lineSpacingPx: savedMeta.lineSpacingPx,
                    totalTextH: savedMeta.totalTextH,
                    yPxFirstLine: savedMeta.yPxFirstLine,
                    lines: savedMeta.lines?.length,
                    formula: `${savedMeta.lines?.length}*${savedMeta.fontPx} + ${(savedMeta.lines?.length-1)}*${savedMeta.lineSpacingPx} = ${savedMeta.totalTextH}`
                  });
                  
                  // SSOT v2 logging
                  console.log('[render] outgoing overlayCaption:', { 
                    ssotVersion: savedMeta.ssotVersion, 
                    keys: Object.keys(savedMeta) 
                  });
                  
                  console.log('[render] Using saved preview meta:', {
                    xPct: savedMeta.xPct,
                    yPct: savedMeta.yPct,
                    fontPx: savedMeta.fontPx,
                    totalTextH: savedMeta.totalTextH
                  });
                  
                  // Remove legacy fields when using overlay
                  delete payload.caption;
                  delete payload.captionStyle;
                  delete payload.captionImage;
                } else if (overlayDataUrl) {
                  // Legacy PNG overlay fallback
                  payload.captionImage = overlayDataUrl;
                  delete payload.caption;
                  delete payload.captionStyle;
                } else {
                  // Legacy drawtext fallback
                  payload.caption = sizePx;
                  payload.captionMode = 'static';
                  payload.captionStyle = {
                    placement: captionStyle.placement || 'bottom',
                    align: 'center',
                    opacity: clamp(captionStyle.opacity || 0.8, 0, 1),
                    weight: captionStyle.weight || 'bold',
                    font: captionStyle.font || 'DejaVu Sans Local',
                  };
                }

                // remove undefined keys so contract stays clean
                payload = stripUndefined(payload);

                // 7) Log minimal, type-focused debug
                console.debug('[render] payload.types', {
                  captionMode: payload.captionMode,                   // 'overlay' | 'static' | undefined
                  overlayCaption: !!payload.overlayCaption,           // boolean for debugging
                  caption_type: typeof payload.caption,               // expect 'number' when no overlay, 'undefined' when overlay
                  captionImage_type: typeof payload.captionImage,     // 'string' when overlay present or 'undefined'
                  text_type: typeof payload.text,                     // 'string'
                  ttsText_type: typeof payload.ttsText,               // 'string'
                  voiceId_type: typeof payload.voiceId,               // 'string' or 'undefined'
                  hasOverlay: !!overlayDataUrl,                       // boolean for debugging
                  caption_value: payload.caption,                     // show actual value
                  mappedSizePx: sizePx,                            // show mapped font size
                });

                // --- END strictly-typed payload construction ---

                // CRITICAL: Verify overlayCaption payload before sending
                if (payload.overlayCaption) {
                  console.log('[render-CRITICAL] overlayCaption keys being sent:', Object.keys(payload.overlayCaption));
                  console.log('[render-CRITICAL] overlayCaption sample:', {
                    yPxFirstLine: payload.overlayCaption?.yPxFirstLine,
                    totalTextHPx: payload.overlayCaption?.totalTextHPx,
                    totalTextH: payload.overlayCaption?.totalTextH,
                    lineSpacingPx: payload.overlayCaption?.lineSpacingPx,
                    lines: payload.overlayCaption?.lines?.length,
                    fontPx: payload.overlayCaption?.fontPx,
                    xPct: payload.overlayCaption?.xPct,
                    yPct: payload.overlayCaption?.yPct,
                    wPct: payload.overlayCaption?.wPct,
                    internalPadding: payload.overlayCaption?.internalPadding
                  });
                  
                  // SSOT invariant validation before render
                  const { fontPx, lineSpacingPx, totalTextH, lines } = payload.overlayCaption;
                  if (Number.isFinite(fontPx) && Number.isFinite(lineSpacingPx) && 
                      Number.isFinite(totalTextH) && Array.isArray(lines) && lines.length > 0) {
                    const expectedTotalTextH = (lines.length * fontPx) + ((lines.length - 1) * lineSpacingPx);
                    if (Math.abs(totalTextH - expectedTotalTextH) > 0.5) {
                      console.error('[render-INVARIANT] Client totalTextH mismatch - forcing preview regeneration:', {
                        actual: totalTextH,
                        expected: expectedTotalTextH,
                        formula: `${lines.length}*${fontPx} + ${lines.length-1}*${lineSpacingPx}`,
                        lines: lines.length,
                        fontPx,
                        lineSpacingPx
                      });
                      throw new Error(`SSOT invariant violation: totalTextH=${totalTextH} != expected=${expectedTotalTextH}. Please regenerate preview.`);
                    }
                    console.log('[render-INVARIANT] ‚úÖ Client totalTextH validation passed:', { totalTextH, expectedTotalTextH });
                  }
                }

                console.log('[render] Final payload:', payload);
                
                // AUDIT: Log render POST payload
                if (payload.overlayCaption) {
                    console.info('[AUDIT:CLIENT:render-post]', {
                        ssotVersion: payload.overlayCaption.ssotVersion,
                        previewFontString: payload.overlayCaption.previewFontString,
                        fontFamily: payload.overlayCaption.fontFamily,
                        previewFontHash: payload.overlayCaption.previewFontHash
                    });
                }
                
                // SSOT validation: Log overlay caption meta to verify positioning data
                if (payload.overlayCaption) {
                  const textPreview = payload.overlayCaption.text || '';
                  const hasNewlines = textPreview.includes('\n');
                  const lineCount = hasNewlines ? textPreview.split('\n').length : 1;
                  
                  console.log('[render] overlayCaption contract verification:', {
                    yPct: payload.overlayCaption.yPct,
                    totalTextH: payload.overlayCaption.totalTextH,
                    lineSpacingPx: payload.overlayCaption.lineSpacingPx,
                    fontPx: payload.overlayCaption.fontPx,
                    wPct: payload.overlayCaption.wPct,
                    xPct: payload.overlayCaption.xPct,
                    textLength: textPreview.length,
                    hasNewlines: hasNewlines,
                    lineCount: lineCount,
                    textPreview: textPreview.substring(0, 80) + (textPreview.length > 80 ? '...' : ''),
                    color: payload.overlayCaption.color,
                    opacity: payload.overlayCaption.opacity
                  });
                }
                console.log('[render] Background object:', background);
                console.log('[render] Current voice ID:', currentVoiceId);

                // Final validation before sending
                if (background.url && background.type) {
                    const url = background.url.toLowerCase();
                    const isVideoUrl = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v'].some(ext => url.includes(`.${ext}`));
                    const isImageUrl = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].some(ext => url.includes(`.${ext}`));
                    
                    if (background.type === 'video' && !isVideoUrl) {
                        console.error('[validation] Type mismatch: type is video but URL is not a video');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                    if (background.type === 'image' && !isImageUrl) {
                        console.error('[validation] Type mismatch: type is image but URL is not an image');
                        alert('Error: Selected asset type does not match URL. Please try selecting a different asset.');
                        return;
                    }
                }

                const data = await apiFetch('/shorts/create', {
                    method: 'POST',
                    body: payload
                });

                if (data.success) {
                    // Success! Show the result
                    const result = data.data;
                    alert(`Short created successfully! Job ID: ${result.jobId}`);
                    
                    // Redirect to My Shorts page so user sees result immediately
                    try { window.location.href = `/my-shorts.html?new=${encodeURIComponent(result.jobId)}`; } catch {}
                    
                    // You could redirect to a results page or show the video here
                    // For now, we'll just show success
                    console.log('Render result:', result);
                } else {
                    alert(`Render failed: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Render error:', error); // includes stack trace
                
                const hint = summarizeCreateError(error);
                alert(`Render failed${hint ? ': ' + hint : ': ' + (error?.message || 'Unknown error')}`);
            } finally {
                if (renderBtn) {
                    renderBtn.disabled = false;
                    renderBtn.textContent = originalText;
                }
                if (mobileCreateBtn) {
                    mobileCreateBtn.disabled = false;
                    mobileCreateBtn.textContent = originalText;
                }
            }
        }

        // One-Click status overlay helpers
        function setOneClickStatus(text) {
            const container = document.getElementById('one-click-status');
            const label = document.getElementById('one-click-status-text');
            if (!container || !label) return;
            
            if (!text) {
                container.style.opacity = '0';
                label.textContent = '';
                return;
            }
            
            label.textContent = text;
            container.style.opacity = '1';
        }

        function clearOneClickStatus() {
            setOneClickStatus('');
        }

        // URL detection helper
        function isUrl(text) {
            if (!text || typeof text !== 'string') return false;
            const trimmed = text.trim();
            try {
                const url = new URL(trimmed);
                return url.protocol === 'http:' || url.protocol === 'https:';
            } catch {
                // Check if it looks like a URL even if URL constructor fails
                return /^https?:\/\/.+/.test(trimmed);
            }
        }

        // One-Click Short orchestration function
        async function oneClickShort() {
            console.log('[one-click] Starting one-click short flow');
            
            // Disable buttons during flow
            const oneClickBtn = document.getElementById('one-click-btn');
            const mobileOneClickBtn = document.getElementById('mobile-one-click-btn');
            const originalText = oneClickBtn?.textContent || 'One-Click Short';
            const originalMobileText = mobileOneClickBtn?.textContent || 'One-Click';
            
            try {
                // Get input from quote box
                const quoteInput = document.getElementById('quote-text');
                const inputText = quoteInput?.value?.trim() || '';
                
                if (!inputText) {
                    showError('quote-error', 'Please enter a URL, quote topic, or text first');
                    throw new Error('No input provided');
                }
                
                // Check if input is a URL
                let isLink = isUrl(inputText);
                let urlToUse = inputText;
                
                // If textarea doesn't contain a URL but we have a stored story URL, use that
                if (!isLink && currentStoryUrl && currentStorySessionId) {
                    console.log('[one-click] Textarea has joined text, using stored URL:', currentStoryUrl);
                    isLink = true;
                    urlToUse = currentStoryUrl;
                }
                
                if (isLink) {
                    // Use story service pipeline for links
                    console.log('[one-click] Detected URL, using story service pipeline');
                    await oneClickShortFromLink(urlToUse, oneClickBtn, mobileOneClickBtn);
                } else {
                    // Use existing quote flow for non-URLs
                    console.log('[one-click] Using quote generation flow');
                    await oneClickShortFromQuote(oneClickBtn, mobileOneClickBtn);
                }
                
                console.log('[one-click] One-click flow completed successfully');
                
            } catch (error) {
                console.error('[one-click] Error in one-click flow:', error);
                showError('quote-error', error.message || 'One-click flow failed. Please try again.');
            } finally {
                // Restore button states
                if (oneClickBtn) {
                    oneClickBtn.disabled = false;
                    oneClickBtn.textContent = originalText;
                }
                if (mobileOneClickBtn) {
                    mobileOneClickBtn.disabled = false;
                    mobileOneClickBtn.textContent = originalMobileText;
                }
                // Clear status overlay with a brief delay
                setTimeout(() => {
                    clearOneClickStatus();
                }, 600);
            }
        }

        // Story service pipeline for links
        async function oneClickShortFromLink(url, oneClickBtn, mobileOneClickBtn) {
            const { apiFetch } = await import('./api.mjs');
            
            let sessionId = null;
            
            // Check if we can reuse existing story session
            if (currentStorySessionId && currentStoryUrl && currentStoryUrl === url) {
                console.log('[one-click] Reusing existing story session:', currentStorySessionId);
                sessionId = currentStorySessionId;
                setOneClickStatus('Using existing story‚Ä¶');
                if (oneClickBtn) {
                    oneClickBtn.disabled = true;
                    oneClickBtn.textContent = 'Using existing story...';
                }
                if (mobileOneClickBtn) {
                    mobileOneClickBtn.disabled = true;
                    mobileOneClickBtn.textContent = 'Using story...';
                }
            } else {
                // Step 1: Create new story session
                setOneClickStatus('Extracting article content‚Ä¶');
                if (oneClickBtn) {
                    oneClickBtn.disabled = true;
                    oneClickBtn.textContent = 'Extracting content...';
                }
                if (mobileOneClickBtn) {
                    mobileOneClickBtn.disabled = true;
                    mobileOneClickBtn.textContent = 'Extracting...';
                }
                
                const startResp = await apiFetch('/story/start', {
                    method: 'POST',
                    body: {
                        input: url,
                        inputType: 'link'
                    }
                });
                
                if (!startResp.success || !startResp.data?.id) {
                    throw new Error(startResp.error || 'Failed to create story session');
                }
                
                sessionId = startResp.data.id;
                console.log('[one-click] Story session created:', sessionId);
                
                // Store for potential future reuse
                currentStorySessionId = sessionId;
                currentStoryUrl = url;
            }
            
            // Step 2: Finalize story (runs full pipeline: generate ‚Üí plan ‚Üí search ‚Üí render)
            setOneClickStatus('Generating story‚Ä¶');
            if (oneClickBtn) oneClickBtn.textContent = 'Generating story...';
            if (mobileOneClickBtn) mobileOneClickBtn.textContent = 'Generating...';
            
            // Poll for progress (finalize can take a while)
            const pollInterval = setInterval(() => {
                if (oneClickBtn) {
                    const current = oneClickBtn.textContent;
                    if (current.includes('Generating')) {
                        oneClickBtn.textContent = current.replace('...', '....').replace('....', '...');
                    }
                }
            }, 500);
            
            try {
                const finalizeResp = await apiFetch('/story/finalize', {
                    method: 'POST',
                    body: { sessionId }
                });
                
                clearInterval(pollInterval);
                
                if (!finalizeResp.success) {
                    throw new Error(finalizeResp.error || finalizeResp.detail || 'Failed to finalize story');
                }
                
                const session = finalizeResp.data;
                
                if (!session.finalVideo?.url) {
                    throw new Error('Story generation completed but no video URL found');
                }
                
                // Extract jobId from finalVideo or from URL path
                let jobId = session.finalVideo?.jobId;
                if (!jobId && session.finalVideo?.url) {
                    // Try to extract from URL path: artifacts/{uid}/{jobId}/story.mp4
                    const urlMatch = session.finalVideo.url.match(/artifacts\/[^/]+\/([^/]+)\//);
                    if (urlMatch) {
                        jobId = urlMatch[1];
                    }
                }
                
                if (!jobId) {
                    console.warn('[one-click] Could not extract jobId, using session ID');
                    jobId = session.id || 'unknown';
                }
                
                console.log('[one-click] Story finalized, video URL:', session.finalVideo.url, 'jobId:', jobId);
                
                // Step 3: Display result and redirect to My Shorts
                setOneClickStatus('Complete!');
                if (oneClickBtn) oneClickBtn.textContent = 'Complete!';
                if (mobileOneClickBtn) mobileOneClickBtn.textContent = 'Done!';
                
                // Show success message and redirect to My Shorts
                showError('quote-error', ''); // Clear any errors
                
                // Brief success message, then redirect
                const sentenceCount = session.story?.sentences?.length || 0;
                const durationSec = Math.round(session.finalVideo.durationSec || 0);
                alert(`Story video created successfully! ${sentenceCount} sentences, ${durationSec}s duration.\n\nRedirecting to My Shorts...`);
                
                // Redirect to My Shorts page with the new video
                try {
                    window.location.href = `/my-shorts.html?new=${encodeURIComponent(jobId)}`;
                } catch (e) {
                    console.error('[one-click] Failed to redirect:', e);
                    // Fallback: try to open My Shorts in same tab
                    window.location.href = '/my-shorts.html';
                }
                
            } catch (error) {
                clearInterval(pollInterval);
                throw error;
            }
        }

        // Original quote flow for non-URLs
        async function oneClickShortFromQuote(oneClickBtn, mobileOneClickBtn) {
            setOneClickStatus('Generating quote‚Ä¶');
            
            // Step 1: Generate or reuse quote
            console.log('[one-click] Step 1: Generating or reusing quote...');
            if (oneClickBtn) {
                oneClickBtn.disabled = true;
                oneClickBtn.textContent = 'Generating quote...';
            }
            if (mobileOneClickBtn) {
                mobileOneClickBtn.disabled = true;
                mobileOneClickBtn.textContent = 'Generating...';
            }
            
            let quoteText = '';
            if (currentQuote && currentQuote.text) {
                console.log('[one-click] Reusing existing quote');
                quoteText = currentQuote.text;
            } else {
                const quoteInput = document.getElementById('quote-text');
                quoteText = quoteInput?.value?.trim() || '';
                
                if (!quoteText) {
                    showError('quote-error', 'Please enter a quote topic or text first');
                    throw new Error('No quote text provided');
                }
                
                // Generate quote
                await window.generateQuote();
                
                // Wait a bit for quote to be set
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (!currentQuote || !currentQuote.text) {
                    showError('quote-error', 'Failed to generate quote');
                    throw new Error('Quote generation failed');
                }
                quoteText = currentQuote.text;
            }
            
            setOneClickStatus('Finding background‚Ä¶');
            
            // Step 2: Build asset search query
            console.log('[one-click] Step 2: Building asset search query...');
            if (oneClickBtn) oneClickBtn.textContent = 'Finding background...';
            if (mobileOneClickBtn) mobileOneClickBtn.textContent = 'Finding...';
            
            const assetQueryInput = document.getElementById('asset-query');
            const quoteInput = document.getElementById('quote-text');
            
            let searchQuery = '';
            if (assetQueryInput?.value?.trim()) {
                searchQuery = assetQueryInput.value.trim();
            } else if (quoteInput?.value?.trim()) {
                searchQuery = quoteInput.value.trim();
            } else if (quoteText) {
                // Use first 20 chars of quote text
                searchQuery = quoteText.trim().substring(0, 20);
            } else {
                searchQuery = 'calm'; // Default fallback
            }
            
            console.log('[one-click] Using search query:', searchQuery);
            
            // Step 3: Search and select asset
            console.log('[one-click] Step 3: Searching for assets...');
            
            // Set asset type to videos (prefer videos for shorts)
            if (typeof window !== 'undefined') {
                window.currentAssetType = 'videos';
            }
            currentAssetType = 'videos';
            
            // Update asset query input
            if (assetQueryInput) {
                assetQueryInput.value = searchQuery;
            }
            
            // Load assets
            await window.loadAssets(1);
            
            // Wait for grid to populate (with timeout)
            let attempts = 0;
            let assets = [];
            while (attempts < 10) {
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Try to get assets from cache
                const cacheKey = `${currentAssetType}-${searchQuery}-1`;
                if (assetCache.has(cacheKey)) {
                    const cachedData = assetCache.get(cacheKey);
                    assets = cachedData.items || [];
                    if (assets.length > 0) break;
                }
                
                // Also check DOM grid
                const grid = document.getElementById('asset-grid');
                if (grid && grid.children.length > 0) {
                    // Extract assets from DOM by finding use buttons and their associated asset data
                    // Since assets are in closure, we need to get from cache
                    if (assetCache.has(cacheKey)) {
                        const cachedData = assetCache.get(cacheKey);
                        assets = cachedData.items || [];
                        break;
                    }
                }
                
                attempts++;
            }
            
            console.log('[one-click] Found assets:', assets.length);
            
            // Select best asset (prefer vertical: height >= width)
            let chosenAsset = null;
            if (assets.length > 0) {
                // Prefer vertical assets
                chosenAsset = assets.find(a => a.height && a.width && a.height >= a.width);
                
                // Fallback to first result if no vertical found
                if (!chosenAsset) {
                    chosenAsset = assets[0];
                }
                
                console.log('[one-click] Selected asset:', chosenAsset.id);
                
                // Apply asset to preview
                selectAsset(chosenAsset);
                
                // Wait for preview to update
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Ensure overlay is visible and properly positioned before saving
                if (useOverlayMode && overlaySystemInitialized) {
                    try {
                        const stage = document.querySelector('#stage');
                        const box = stage?.querySelector('.caption-box');
                        if (stage && box) {
                            const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                            ensureOverlayTopAndVisible('#stage');
                            // Wait for layout to settle after positioning
                            await new Promise(resolve => requestAnimationFrame(resolve));
                        } else {
                            console.warn('[one-click] Overlay elements not found, skipping positioning');
                        }
                    } catch (e) {
                        console.warn('[one-click] Overlay positioning failed:', e);
                    }
                } else {
                    console.log('[one-click] Overlay system not initialized, skipping positioning');
                }
            } else {
                console.log('[one-click] No assets found, will use black background');
                selectedAsset = null;
            }
            
            // Step 4: Save preview
            console.log('[one-click] Step 4: Saving preview...');
            setOneClickStatus('Saving preview‚Ä¶');
            if (oneClickBtn) oneClickBtn.textContent = 'Saving preview...';
            if (mobileOneClickBtn) mobileOneClickBtn.textContent = 'Saving...';
            
            // Wait a bit more for preview to stabilize
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Save preview
            await savePreview();
            
            console.log('[one-click] Preview saved successfully');
            
            // Step 5: Render
            console.log('[one-click] Step 5: Rendering short...');
            setOneClickStatus('Rendering‚Ä¶');
            if (oneClickBtn) oneClickBtn.textContent = 'Rendering...';
            if (mobileOneClickBtn) mobileOneClickBtn.textContent = 'Rendering...';
            
            // Render the short
            await renderShort();
        }
        
        // Expose to window scope for ui-actions.js
        window.oneClickShort = oneClickShort;

        // Article mode functions
        async function summarizeArticle() {
            const inputEl = document.getElementById('article-input');
            const errorEl = document.getElementById('article-error');
            const scriptPreviewEl = document.getElementById('article-script-preview');
            const summarizeBtn = document.getElementById('summarize-article-btn');
            
            if (!inputEl || !scriptPreviewEl) {
                console.error('[article] Missing required elements');
                return;
            }
            
            const inputText = inputEl.value.trim();
            if (!inputText) {
                showError('article-error', 'Please paste an article link or text');
                return;
            }
            
            setLoading('summarize-article-btn', true);
            hideError('article-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Detect if input is URL or text
                const inputType = isUrl(inputText) ? 'link' : 'paragraph';
                
                // Read style from dropdown
                const styleKey = document.getElementById('article-style-select')?.value || 'default';
                
                // Step 1: Create story session
                const startResp = await apiFetch('/story/start', {
                    method: 'POST',
                    body: {
                        input: inputText,
                        inputType: inputType,
                        styleKey: styleKey
                    }
                });
                
                if (!startResp.success || !startResp.data?.id) {
                    throw new Error(startResp.error || 'Failed to create story session');
                }
                
                const sessionId = startResp.data.id;
                window.currentStorySessionId = sessionId; // Reuse existing global
                
                // Step 2: Generate story
                const generateResp = await apiFetch('/story/generate', {
                    method: 'POST',
                    body: {
                        sessionId: sessionId
                    }
                });
                
                if (!generateResp.success || !generateResp.data?.story?.sentences) {
                    throw new Error(generateResp.error || 'Failed to generate story');
                }
                
                // Display sentences in script preview (one per line)
                const sentences = generateResp.data.story.sentences;
                const scriptText = Array.isArray(sentences) ? sentences.join('\n') : String(sentences);
                scriptPreviewEl.value = scriptText;
                
                // Store original sentences to detect edits
                window.currentStoryOriginalSentences = Array.isArray(sentences) ? [...sentences] : [String(sentences)];
                
                console.log('[article] Story generated successfully:', sentences.length, 'sentences');
                
            } catch (error) {
                console.error('[article] Summarize failed:', error);
                showError('article-error', error.message || 'Failed to summarize article');
            } finally {
                setLoading('summarize-article-btn', false);
            }
        }
        
        async function prepareStoryboard() {
            const sessionId = window.currentStorySessionId;
            if (!sessionId) {
                showError('article-error', 'Please summarize the article first');
                return;
            }
            
                const scriptPreviewEl = document.getElementById('article-script-preview');
                const prepareBtn = document.getElementById('prepare-storyboard-btn');
                const storyboardEl = document.getElementById('storyboard');
                const scriptSection = document.getElementById('article-script-section');
            
            if (!scriptPreviewEl || !prepareBtn) {
                console.error('[article] Missing required elements');
                return;
            }
            
            setLoading('prepare-storyboard-btn', true);
            hideError('article-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Get current script from textarea
                const currentScript = scriptPreviewEl.value.trim();
                const currentSentences = currentScript.split('\n')
                    .map(s => s.trim())
                    .filter(s => s.length > 0);
                
                if (currentSentences.length === 0) {
                    throw new Error('Script is empty');
                }
                
                // Check if script was edited
                const originalSentences = window.currentStoryOriginalSentences || [];
                const sentencesChanged = originalSentences.length !== currentSentences.length ||
                    originalSentences.some((s, i) => s !== currentSentences[i]);
                
                // Update script if changed
                if (sentencesChanged) {
                    console.log('[article] Script was edited, updating...');
                    const updateResp = await apiFetch('/story/update-script', {
                        method: 'POST',
                        body: {
                            sessionId: sessionId,
                            sentences: currentSentences
                        }
                    });
                    
                    if (!updateResp.success) {
                        throw new Error(updateResp.error || 'Failed to update script');
                    }
                    
                    // Update stored original
                    window.currentStoryOriginalSentences = [...currentSentences];
                }
                
                // Step 1: Plan shots
                const planResp = await apiFetch('/story/plan', {
                    method: 'POST',
                    body: { sessionId: sessionId }
                });
                
                if (!planResp.success) {
                    throw new Error(planResp.error || 'Failed to plan shots');
                }
                
                // Step 2: Search clips
                const searchResp = await apiFetch('/story/search', {
                    method: 'POST',
                    body: { sessionId: sessionId }
                });
                
                if (!searchResp.success) {
                    throw new Error(searchResp.error || 'Failed to search clips');
                }
                
                const session = searchResp.data;
                
                // Store session for clip picker access
                window.currentStorySession = session;
                
                // Render storyboard
                renderStoryboard(session);
                
                // Mobile: collapse script, expand storyboard
                if (window.innerWidth < 768) {
                    if (scriptSection) {
                        scriptSection.classList.add('hidden');
                    }
                }
                
                console.log('[article] Storyboard prepared successfully');
                
            } catch (error) {
                console.error('[article] Prepare storyboard failed:', error);
                showError('article-error', error.message || 'Failed to prepare storyboard');
            } finally {
                setLoading('prepare-storyboard-btn', false);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function renderStoryboard(session) {
            const storyboardRow = document.getElementById('storyboard-row');
            const storyboardEl = document.getElementById('storyboard');
            
            if (!storyboardRow || !storyboardEl) {
                console.error('[article] Storyboard elements not found');
                return;
            }
            
            // Clear existing cards
            storyboardRow.innerHTML = '';
            
            const sentences = session.story?.sentences || [];
            const shots = session.shots || [];
            
            // Guard: handle mismatched counts gracefully
            if (sentences.length !== shots.length) {
                console.warn(`[article] Mismatched counts: ${sentences.length} sentences, ${shots.length} shots`);
            }
            
            sentences.forEach((sentence, idx) => {
                // Find matching shot by sentenceIndex
                const shot = shots.find(s => s.sentenceIndex === idx) || shots[idx];
                
                const card = document.createElement('div');
                card.className = 'relative w-40 h-72 flex-shrink-0 bg-black rounded-lg overflow-hidden border border-gray-700';
                card.setAttribute('data-sentence-index', idx);
                
                if (!shot || !shot.selectedClip) {
                    // Placeholder for missing clip
                    card.innerHTML = `
                        <button
                            class="delete-beat-btn absolute top-1 right-1 w-6 h-6 rounded-full bg-red-600 hover:bg-red-700 text-white text-xs flex items-center justify-center z-10"
                            data-sentence-index="${idx}"
                            title="Delete beat"
                        >‚úï</button>
                        <div class="relative w-full h-40 bg-gray-800 flex items-center justify-center">
                            <p class="text-xs text-gray-400 text-center px-2">No clip found</p>
                        </div>
                        <div 
                            class="beat-text p-2 text-xs text-gray-200 h-24 overflow-hidden cursor-text"
                            data-sentence-index="${idx}"
                            title="Click to edit"
                        >
                            ${escapeHtml(sentence)}
                        </div>
                        <button
                            class="swap-clip-btn mt-1 mx-2 mb-2 w-[calc(100%-1rem)] text-xs py-1 rounded bg-slate-700 hover:bg-slate-600 text-white"
                            data-sentence-index="${idx}"
                        >
                            Swap clip
                        </button>
                    `;
                } else {
                    const clip = shot.selectedClip;
                    const videoUrl = clip.url || '';
                    const thumbUrl = clip.thumbUrl || '';
                    
                    card.innerHTML = `
                        <button
                            class="delete-beat-btn absolute top-1 right-1 w-6 h-6 rounded-full bg-red-600 hover:bg-red-700 text-white text-xs flex items-center justify-center z-10"
                            data-sentence-index="${idx}"
                            title="Delete beat"
                        >‚úï</button>
                        <div class="relative w-full h-40 overflow-hidden">
                            <video
                                src="${videoUrl}"
                                ${thumbUrl ? `poster="${thumbUrl}"` : ''}
                                muted
                                loop
                                preload="none"
                                class="w-full h-full object-cover transition-transform duration-150 storyboard-video"
                                data-index="${idx}"
                                aria-label="Preview for: ${sentence.substring(0, 50)}"
                            ></video>
                        </div>
                        <div 
                            class="beat-text p-2 text-xs text-gray-200 h-24 overflow-hidden cursor-text"
                            data-sentence-index="${idx}"
                            title="Click to edit"
                        >
                            ${escapeHtml(sentence)}
                        </div>
                        <button
                            class="swap-clip-btn mt-1 mx-2 mb-2 w-[calc(100%-1rem)] text-xs py-1 rounded bg-slate-700 hover:bg-slate-600 text-white"
                            data-sentence-index="${idx}"
                        >
                            Swap clip
                        </button>
                    `;
                }
                
                storyboardRow.appendChild(card);
                
                // Add "Add beat" button after each card
                const addBtn = document.createElement('button');
                addBtn.className = 'add-beat-btn mx-2 flex-shrink-0';
                addBtn.setAttribute('data-insert-after-index', idx);
                addBtn.setAttribute('title', 'Add clip');
                addBtn.textContent = '+';
                storyboardRow.appendChild(addBtn);
            });
            
            // Add final "Add beat" button after the last card
            if (sentences.length > 0) {
                const finalAddBtn = document.createElement('button');
                finalAddBtn.className = 'add-beat-btn mx-2 flex-shrink-0';
                finalAddBtn.setAttribute('data-insert-after-index', sentences.length - 1);
                finalAddBtn.setAttribute('title', 'Add clip');
                finalAddBtn.textContent = '+';
                storyboardRow.appendChild(finalAddBtn);
            }
            
            // Show storyboard
            storyboardEl.classList.remove('hidden');
            
            // Setup hover interactions (desktop-only)
            setupStoryboardHover();
            
            // Setup swap button click handlers
            setupSwapButtonHandlers();
        }
        
        function setupSwapButtonHandlers() {
            const storyboardRow = document.getElementById('storyboard-row');
            if (!storyboardRow) return;
            
            // Remove existing listener to avoid duplicates
            storyboardRow.removeEventListener('click', handleSwapButtonClick);
            
            // Add click handler
            storyboardRow.addEventListener('click', handleSwapButtonClick);
        }
        
        function handleSwapButtonClick(e) {
            // Handle swap clip button
            const swapBtn = e.target.closest('.swap-clip-btn');
            if (swapBtn) {
                const sentenceIndex = Number(swapBtn.dataset.sentenceIndex);
                if (isNaN(sentenceIndex)) {
                    console.error('[article] Invalid sentence index:', swapBtn.dataset.sentenceIndex);
                    return;
                }
                openClipPicker(sentenceIndex);
                return;
            }
            
            // Handle add beat button
            const addBtn = e.target.closest('.add-beat-btn');
            if (addBtn) {
                const insertAfterIndex = Number(addBtn.dataset.insertAfterIndex);
                if (isNaN(insertAfterIndex)) {
                    console.error('[article] Invalid insert after index:', addBtn.dataset.insertAfterIndex);
                    return;
                }
                
                const text = prompt('New beat text:');
                if (!text || !text.trim()) {
                    return;
                }
                
                handleInsertBeat(insertAfterIndex, text.trim());
                return;
            }
            
            // Handle delete beat button
            const deleteBtn = e.target.closest('.delete-beat-btn');
            if (deleteBtn) {
                const sentenceIndex = Number(deleteBtn.dataset.sentenceIndex);
                if (isNaN(sentenceIndex)) {
                    console.error('[article] Invalid sentence index:', deleteBtn.dataset.sentenceIndex);
                    return;
                }
                
                if (!confirm('Delete this beat?')) {
                    return;
                }
                
                handleDeleteBeat(sentenceIndex);
                return;
            }
            
            // Handle click on beat text (NEW)
            const textEl = e.target.closest('.beat-text');
            if (textEl) {
                handleEditBeatInline(textEl);
                return;
            }
        }
        
        async function handleInsertBeat(insertAfterIndex, text) {
            const sessionId = window.currentStorySessionId;
            if (!sessionId) {
                showError('article-error', 'Session not found');
                return;
            }
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                const resp = await apiFetch('/story/insert-beat', {
                    method: 'POST',
                    body: {
                        sessionId: sessionId,
                        insertAfterIndex: insertAfterIndex,
                        text: text
                    }
                });
                
                if (!resp.success) {
                    throw new Error(resp.error || 'Failed to insert beat');
                }
                
                // Update local session
                if (window.currentStorySession) {
                    if (!window.currentStorySession.story) {
                        window.currentStorySession.story = {};
                    }
                    window.currentStorySession.story.sentences = resp.data.sentences;
                    window.currentStorySession.shots = resp.data.shots;
                }
                
                // Re-render storyboard
                renderStoryboard(window.currentStorySession);
                
                console.log(`[article] Insert beat: insertAfterIndex=${insertAfterIndex}, new length=${resp.data.sentences.length}`);
            } catch (error) {
                console.error('[article] Insert beat failed:', error);
                showError('article-error', error.message || 'Failed to insert beat');
            }
        }
        
        async function handleDeleteBeat(sentenceIndex) {
            const sessionId = window.currentStorySessionId;
            if (!sessionId) {
                showError('article-error', 'Session not found');
                return;
            }
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                const resp = await apiFetch('/story/delete-beat', {
                    method: 'POST',
                    body: {
                        sessionId: sessionId,
                        sentenceIndex: sentenceIndex
                    }
                });
                
                if (!resp.success) {
                    throw new Error(resp.error || 'Failed to delete beat');
                }
                
                // Update local session
                if (window.currentStorySession) {
                    if (!window.currentStorySession.story) {
                        window.currentStorySession.story = {};
                    }
                    window.currentStorySession.story.sentences = resp.data.sentences;
                    window.currentStorySession.shots = resp.data.shots;
                }
                
                // Re-render storyboard
                renderStoryboard(window.currentStorySession);
                
                console.log(`[article] Delete beat: sentenceIndex=${sentenceIndex}, new length=${resp.data.sentences.length}`);
            } catch (error) {
                console.error('[article] Delete beat failed:', error);
                showError('article-error', error.message || 'Failed to delete beat');
            }
        }
        
        // Inline editing state
        let currentBeatEditing = null; // { el, sentenceIndex, originalText } or null
        
        function handleEditBeatInline(textEl) {
            // Avoid starting multiple edits at once
            if (currentBeatEditing && currentBeatEditing.el !== textEl) {
                // Finish or cancel the other one first
                currentBeatEditing.el.blur();
            }
            
            const sentenceIndex = Number(textEl.dataset.sentenceIndex ?? -1);
            if (sentenceIndex < 0) return;
            
            const sentences = window.currentStorySession?.story?.sentences || [];
            const currentText = sentences[sentenceIndex] ?? textEl.textContent ?? "";
            
            currentBeatEditing = {
                el: textEl,
                sentenceIndex,
                originalText: currentText,
            };
            
            textEl.contentEditable = "true";
            textEl.classList.add("beat-text-editing");
            textEl.focus();
            
            // Place caret at end
            const range = document.createRange();
            range.selectNodeContents(textEl);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            
            // Attach key handler once
            textEl.addEventListener("keydown", handleBeatTextKeydown);
            textEl.addEventListener("blur", handleBeatTextBlur);
        }
        
        async function commitBeatTextEdit() {
            if (!currentBeatEditing) return;
            
            const { el, sentenceIndex, originalText } = currentBeatEditing;
            const newText = (el.textContent || "").trim();
            
            // Clean up editing state UI
            el.contentEditable = "false";
            el.classList.remove("beat-text-editing");
            el.removeEventListener("keydown", handleBeatTextKeydown);
            el.removeEventListener("blur", handleBeatTextBlur);
            
            currentBeatEditing = null;
            
            if (!newText || newText === originalText) {
                // No change ‚Üí nothing to do
                el.textContent = originalText;
                return;
            }
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                const resp = await apiFetch('/story/update-beat-text', {
                    method: 'POST',
                    body: {
                        sessionId: window.currentStorySessionId,
                        sentenceIndex,
                        text: newText,
                    }
                });
                
                if (!resp.success) {
                    console.error("[article] Update beat failed:", resp);
                    showError("article-error", resp.detail || "Failed to update beat");
                    // Revert text if backend failed
                    el.textContent = originalText;
                    return;
                }
                
                const { sentences, shots } = resp.data;
                
                // Keep session in sync
                if (!window.currentStorySession.story) {
                    window.currentStorySession.story = {};
                }
                window.currentStorySession.story.sentences = sentences;
                window.currentStorySession.shots = shots;
                
                console.log(
                    "[article] Update beat: sentenceIndex=%d, newText=%s",
                    sentenceIndex,
                    newText.slice(0, 80)
                );
                
                // Re-render storyboard from canonical data
                renderStoryboard(window.currentStorySession);
            } catch (err) {
                console.error("[article] Update beat error:", err);
                showError("article-error", "Could not update beat. Please try again.");
                el.textContent = originalText;
            }
        }
        
        function handleBeatTextKeydown(e) {
            if (!currentBeatEditing) return;
            
            if (e.key === "Enter") {
                e.preventDefault();
                commitBeatTextEdit();
            } else if (e.key === "Escape") {
                e.preventDefault();
                // Cancel and revert
                const { el, originalText } = currentBeatEditing;
                el.textContent = originalText;
                el.blur(); // will trigger blur handler cleanup
            }
        }
        
        function handleBeatTextBlur(e) {
            // When focus leaves, commit the change
            commitBeatTextEdit();
        }
        
        function renderClipPickerGrid(shot, pageInfo = null) {
            const grid = document.getElementById('clip-picker-grid');
            if (!grid) return;
            
            // Remove existing sentinel if present
            const existingSentinel = document.getElementById('clip-picker-sentinel');
            if (existingSentinel) {
                existingSentinel.remove();
            }
            
            // Show all candidates from current page (backend returns 12 per page)
            const candidates = shot.candidates || [];
            
            if (candidates.length === 0) {
                grid.innerHTML = '<div class="text-sm text-gray-500 dark:text-gray-400 col-span-full text-center py-4">No clips found. Try a different search.</div>';
                // Hide pagination if no results
                const paginationBar = document.getElementById('clip-picker-pagination');
                if (paginationBar) {
                    paginationBar.classList.add('hidden');
                }
                return;
            }
            
            grid.innerHTML = candidates.map(clip => {
                const isSelected = shot.selectedClip?.id === clip.id;
                return `
                    <div
                        class="clip-option rounded overflow-hidden bg-gray-100 dark:bg-gray-800 border ${isSelected ? 'border-blue-500' : 'border-gray-300 dark:border-gray-700'} cursor-pointer hover:border-blue-500 transition"
                        data-clip-id="${clip.id}"
                    >
                        <video
                            class="w-full h-40 object-cover pointer-events-none"
                            src="${clip.url || ''}"
                            ${clip.thumbUrl ? `poster="${clip.thumbUrl}"` : ''}
                            playsinline
                            muted
                            preload="none"
                        ></video>
                        <div class="p-1 text-[11px] truncate text-gray-600 dark:text-gray-300">
                            ${clip.photographer || ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add sentinel element if there are more pages
            if (pageInfo && pageInfo.hasMore) {
                const sentinel = document.createElement('div');
                sentinel.id = 'clip-picker-sentinel';
                sentinel.className = 'h-4 w-full';
                grid.appendChild(sentinel);
            }
            
            // Update pagination controls
            updatePaginationControls(pageInfo);
        }
        
        function updatePaginationControls(pageInfo) {
            const paginationBar = document.getElementById('clip-picker-pagination');
            if (!paginationBar) return;
            
            if (!pageInfo) {
                paginationBar.classList.add('hidden');
                return;
            }
            
            const { currentPage, hasMore } = pageInfo;
            const prevBtn = document.getElementById('clip-picker-prev');
            const nextBtn = document.getElementById('clip-picker-more');
            
            // Show pagination bar
            paginationBar.classList.remove('hidden');
            
            // Update Previous button
            if (prevBtn) {
                if (currentPage === 1) {
                    prevBtn.disabled = true;
                    prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    prevBtn.disabled = false;
                    prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
            
            // Update More clips button
            if (nextBtn) {
                if (!hasMore) {
                    nextBtn.disabled = true;
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    nextBtn.disabled = false;
                    nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }
        
        function openClipPicker(sentenceIndex) {
            const session = window.currentStorySession;
            if (!session || !session.shots) {
                console.error('[article] No session or shots available');
                showError('article-error', 'Please prepare the storyboard first');
                return;
            }
            
            const shot = session.shots.find(s => s.sentenceIndex === sentenceIndex);
            if (!shot) {
                console.error('[article] Shot not found for sentence index:', sentenceIndex);
                return;
            }
            
            // Store current sentence index for swap handler
            window.currentClipPickerSentence = sentenceIndex;
            
            // Initialize pagination state
            window.clipPickerPagination = { currentPage: 1, hasMore: false };
            
            // Get picker elements
            const picker = document.getElementById('clip-picker');
            const searchInput = document.getElementById('clip-search-input');
            const closeBtn = document.getElementById('clip-picker-close');
            
            if (!picker) {
                console.error('[article] Clip picker element not found');
                return;
            }
            
            // Clear search input
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Render grid with existing candidates if available
            renderClipPickerGrid(shot, window.clipPickerPagination);
            
            // Trigger initial search to get pagination metadata (hasMore)
            // This ensures buttons are correctly enabled/disabled from the start
            if (shot.searchQuery && shot.searchQuery.trim()) {
                runClipSearch(1, { append: false });
            } else {
                // Even without initial search, setup observer if sentinel exists
                if (document.getElementById('clip-picker-sentinel')) {
                    setupClipPickerInfiniteScroll();
                }
            }
            
            // Show picker
            picker.classList.remove('hidden');
            
            // Setup close button
            if (closeBtn) {
                closeBtn.onclick = () => {
                    // Clean up infinite scroll observer
                    if (window.clipPickerInfinite?.observer) {
                        window.clipPickerInfinite.observer.disconnect();
                        window.clipPickerInfinite.observer = null;
                    }
                    picker.classList.add('hidden');
                    window.currentClipPickerSentence = null;
                    // Remove click handler when picker is closed
                    picker.removeEventListener('click', handleClipOptionClick);
                };
            }
            
            // Setup hover interactions (delegated on drawer)
            setupClipPickerHover();
            
            // Setup click handler on drawer (not grid) for clip selection
            // (picker already declared above at line 6071)
            if (picker) {
                picker.removeEventListener('click', handleClipOptionClick);
                picker.addEventListener('click', handleClipOptionClick);
            }
            
            // Setup search button and Enter key
            const searchBtn = document.getElementById('clip-search-btn');
            // (searchInput already declared above at line 6072)
            
            if (searchBtn) {
                searchBtn.onclick = () => {
                    // Reset to page 1 for new search
                    if (window.clipPickerPagination) {
                        window.clipPickerPagination.currentPage = 1;
                    }
                    runClipSearch(1, { append: false });
                };
            }
            
            if (searchInput) {
                searchInput.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        // Reset to page 1 for new search
                        if (window.clipPickerPagination) {
                            window.clipPickerPagination.currentPage = 1;
                        }
                        runClipSearch(1, { append: false });
                    }
                };
            }
            
            // Setup pagination buttons
            const prevBtn = document.getElementById('clip-picker-prev');
            const nextBtn = document.getElementById('clip-picker-more');
            
            if (prevBtn) {
                prevBtn.onclick = () => {
                    if (window.clipPickerPagination && window.clipPickerPagination.currentPage > 1) {
                        window.clipPickerPagination.currentPage--;
                        runClipSearch(window.clipPickerPagination.currentPage);
                    }
                };
            }
            
            if (nextBtn) {
                nextBtn.onclick = () => {
                    if (window.clipPickerPagination && window.clipPickerPagination.hasMore) {
                        const nextPage = window.clipPickerPagination.currentPage + 1;
                        runClipSearch(nextPage, { append: true });
                    }
                };
            }
        }
        
        function setupClipPickerHover() {
            const picker = document.getElementById('clip-picker');
            if (!picker) return;
            
            // Remove existing listeners to avoid duplicates
            picker.removeEventListener('mouseenter', handleClipPickerMouseEnter, true);
            picker.removeEventListener('mouseleave', handleClipPickerMouseLeave, true);
            
            // Only enable hover on desktop
            if (window.innerWidth >= 768) {
                picker.addEventListener('mouseenter', handleClipPickerMouseEnter, true);
                picker.addEventListener('mouseleave', handleClipPickerMouseLeave, true);
            }
        }
        
        function handleClipPickerMouseEnter(e) {
            const card = e.target.closest('.clip-option');
            if (!card) return;
            const video = card.querySelector('video');
            if (!video) return;
            video.play().catch(() => {});
        }
        
        function handleClipPickerMouseLeave(e) {
            const card = e.target.closest('.clip-option');
            if (!card) return;
            const video = card.querySelector('video');
            if (!video) return;
            video.pause();
            video.currentTime = 0;
        }
        
        function setClipPickerBusy(busy) {
            const drawer = document.getElementById('clip-picker');
            if (!drawer) return;
            drawer.dataset.busy = busy ? '1' : '0';
            
            // Exclude pagination buttons - they are managed exclusively by updatePaginationControls
            const buttons = drawer.querySelectorAll('button:not(#clip-picker-prev):not(#clip-picker-more), .clip-option');
            buttons.forEach((el) => {
                el.toggleAttribute('disabled', busy);
                if (busy) {
                    el.classList.add('opacity-60', 'pointer-events-none');
                } else {
                    el.classList.remove('opacity-60', 'pointer-events-none');
                }
            });
        }
        
        function setupClipPickerInfiniteScroll() {
            const grid = document.getElementById('clip-picker-grid');
            const sentinel = document.getElementById('clip-picker-sentinel');
            const drawer = document.getElementById('clip-picker');
            if (!grid || !sentinel || !drawer) return;
            
            // Clean up any old observer
            if (window.clipPickerInfinite?.observer) {
                window.clipPickerInfinite.observer.disconnect();
            }
            
            const state = window.clipPickerInfinite || (window.clipPickerInfinite = { loadingNext: false, observer: null });
            
            const observer = new IntersectionObserver((entries) => {
                const entry = entries[0];
                if (!entry.isIntersecting) return;
                
                const busy = drawer.dataset.busy === '1';
                const pagination = window.clipPickerPagination || { currentPage: 1, hasMore: false };
                if (busy || state.loadingNext || !pagination.hasMore) return;
                
                state.loadingNext = true;
                const nextPage = (pagination.currentPage || 1) + 1;
                console.log('[clip-picker] infinite scroll ‚Üí loading page', nextPage);
                runClipSearch(nextPage, { append: true }).finally(() => {
                    state.loadingNext = false;
                });
            }, {
                root: grid,
                rootMargin: '0px 0px 200px 0px',
                threshold: 0.1,
            });
            
            observer.observe(sentinel);
            state.observer = observer;
        }
        
        async function handleClipOptionClick(e) {
            // Only handle clicks when picker is visible
            const picker = document.getElementById('clip-picker');
            if (!picker || picker.classList.contains('hidden')) {
                return;
            }
            
            const card = e.target.closest('.clip-option[data-clip-id]');
            if (!card) return;
            
            // Stop propagation to prevent interfering with other click handlers
            e.stopPropagation();
            
            const clipId = card.getAttribute('data-clip-id');
            const sentenceIndex = window.currentClipPickerSentence;
            
            if (!clipId || sentenceIndex === undefined || sentenceIndex === null) {
                console.error('[article] Missing clipId or sentenceIndex');
                return;
            }
            
            const sessionId = window.currentStorySessionId;
            if (!sessionId) {
                showError('article-error', 'Session not found');
                return;
            }
            
            try {
                setClipPickerBusy(true);
                
                const { apiFetch } = await import('./api.mjs');
                
                // Call API to update selected clip
                const resp = await apiFetch('/story/update-shot', {
                    method: 'POST',
                    body: {
                        sessionId: sessionId,
                        sentenceIndex: sentenceIndex,
                        clipId: clipId
                    }
                });
                
                if (!resp.success) {
                    throw new Error(resp.error || 'Failed to update clip');
                }
                
                // Update local session
                const updatedShot = resp.data.shots?.find(s => s.sentenceIndex === sentenceIndex);
                if (updatedShot && window.currentStorySession && window.currentStorySession.shots) {
                    const idx = window.currentStorySession.shots.findIndex(s => s.sentenceIndex === sentenceIndex);
                    if (idx !== -1) {
                        window.currentStorySession.shots[idx] = updatedShot;
                    }
                }
                
                // Update storyboard card
                if (updatedShot) {
                    updateStoryboardCardForSentence(updatedShot);
                }
                
                // Close picker
                // (picker already declared above at line 6179)
                if (picker) {
                    picker.classList.add('hidden');
                }
                window.currentClipPickerSentence = null;
                
                console.log('[article] Clip swapped successfully');
                
            } catch (error) {
                console.error('[article] Swap clip failed:', error);
                showError('article-error', error.message || 'Failed to swap clip');
            } finally {
                setClipPickerBusy(false);
            }
        }
        
        function updateStoryboardCardForSentence(shot) {
            if (!shot || !shot.selectedClip) return;
            
            const card = document.querySelector(`#storyboard-row [data-sentence-index="${shot.sentenceIndex}"]`);
            if (!card) return;
            
            const video = card.querySelector('video');
            if (!video) return;
            
            const clip = shot.selectedClip;
            video.src = clip.url || '';
            if (clip.thumbUrl) {
                video.setAttribute('poster', clip.thumbUrl);
            } else {
                video.removeAttribute('poster');
            }
            video.load();
        }
        
        async function runClipSearch(pageOverride = null, options = {}) {
            const { append = false } = options;
            const input = document.getElementById('clip-search-input');
            const query = input?.value.trim() || '';
            const sentenceIndex = window.currentClipPickerSentence;
            
            if (sentenceIndex === undefined || sentenceIndex === null) {
                console.error('[article] No sentence index for search');
                return;
            }
            
            const sessionId = window.currentStorySessionId;
            if (!sessionId) {
                showError('article-error', 'Session not found');
                return;
            }
            
            // Initialize pagination state if not exists
            if (!window.clipPickerPagination) {
                window.clipPickerPagination = { currentPage: 1, hasMore: false, lastQuery: null };
            }
            
            // Reset to page 1 if query changed (new search) - but only if not appending
            const lastQuery = window.clipPickerPagination.lastQuery;
            if (!append && lastQuery !== null && lastQuery !== query) {
                window.clipPickerPagination.currentPage = 1;
                window.clipPickerPagination.hasMore = false;
            }
            window.clipPickerPagination.lastQuery = query;
            
            // Use override page if provided, otherwise use current page
            const currentPage = pageOverride !== null ? pageOverride : window.clipPickerPagination.currentPage;
            
            // If appending, save existing candidates before API call
            let existingCandidates = [];
            if (append && window.currentStorySession && window.currentStorySession.shots) {
                const existingShot = window.currentStorySession.shots.find(s => s.sentenceIndex === sentenceIndex);
                if (existingShot && existingShot.candidates) {
                    existingCandidates = existingShot.candidates;
                }
            }
            
            try {
                setClipPickerBusy(true);
                
                const { apiFetch } = await import('./api.mjs');
                
                const resp = await apiFetch('/story/search-shot', {
                    method: 'POST',
                    body: {
                        sessionId: sessionId,
                        sentenceIndex: sentenceIndex,
                        query: query, // can be empty = use original sentence
                        page: currentPage
                    }
                });
                
                if (!resp.success) {
                    throw new Error(resp.error || 'Search failed');
                }
                
                const shot = resp.data.shot;
                const page = resp.data.page || currentPage;
                const hasMore = resp.data.hasMore || false;
                
                // If append mode, merge new candidates with existing ones (dedupe by id)
                if (append && existingCandidates.length > 0) {
                    const existingIds = new Set(existingCandidates.map(c => c.id).filter(id => id != null));
                    const newCandidates = (shot.candidates || []).filter(c => c.id == null || !existingIds.has(c.id));
                    shot.candidates = [...existingCandidates, ...newCandidates];
                }
                
                // Update pagination state
                window.clipPickerPagination.currentPage = page;
                window.clipPickerPagination.hasMore = hasMore;
                
                // Log pagination state for debugging
                console.log(`[clip-picker] page=${page} hasMore=${hasMore} append=${append}`);
                
                // Update session model
                if (window.currentStorySession && window.currentStorySession.shots) {
                    const idx = window.currentStorySession.shots.findIndex(s => s.sentenceIndex === shot.sentenceIndex);
                    if (idx !== -1) {
                        window.currentStorySession.shots[idx] = shot;
                    }
                }
                
                // Re-render candidate grid with pagination info
                renderClipPickerGrid(shot, window.clipPickerPagination);
                
                // Update pagination controls after rendering
                updatePaginationControls(window.clipPickerPagination);
                
                // Re-setup infinite scroll observer if sentinel exists (it may have been removed/re-added)
                if (document.getElementById('clip-picker-sentinel')) {
                    setupClipPickerInfiniteScroll();
                }
                
            } catch (error) {
                console.error('[article] Search failed:', error);
                showError('article-error', error.message || 'Could not search clips. Please try again.');
            } finally {
                setClipPickerBusy(false);
            }
        }
        
        function setupStoryboardHover() {
            // Remove existing listeners to avoid duplicates
            const videos = document.querySelectorAll('.storyboard-video');
            
            videos.forEach(vid => {
                // Remove old listeners by cloning
                const newVid = vid.cloneNode(true);
                vid.parentNode.replaceChild(newVid, vid);
                
                // Only enable hover on desktop
                if (window.innerWidth >= 768) {
                    newVid.addEventListener('mouseenter', () => {
                        newVid.play().catch(e => console.warn('[article] Video play failed:', e));
                        newVid.classList.add('scale-110');
                    });
                    
                    newVid.addEventListener('mouseleave', () => {
                        newVid.pause();
                        newVid.currentTime = 0;
                        newVid.classList.remove('scale-110');
                    });
                } else {
                    // Mobile: tap to play/pause
                    newVid.addEventListener('click', () => {
                        if (newVid.paused) {
                            newVid.play().catch(e => console.warn('[article] Video play failed:', e));
                        } else {
                            newVid.pause();
                        }
                    });
                }
            });
        }
        
        // ========================================
        // Render Status Banner Management
        // ========================================
        // Shows a 3-step progress banner during /api/story/finalize execution:
        // - Immediately: "Preparing video..."
        // - After 3s: "Adding speech..."
        // - After 6s: "Finalizing video..."
        // 
        // To modify timing or messages, update:
        // - showRenderStatus() timeout values (3000ms, 6000ms)
        // - Status text strings in showRenderStatus()
        // - Banner HTML element (#render-status-banner) near end of body
        // ========================================
        
        let renderStatusTimeouts = [];
        let renderStatusActive = false;
        
        function showRenderStatus() {
            // Clear any existing timeouts
            hideRenderStatus();
            
            const banner = document.getElementById('render-status-banner');
            const textEl = document.getElementById('render-status-text');
            
            if (!banner || !textEl) {
                console.warn('[render-status] Banner elements not found');
                return;
            }
            
            renderStatusActive = true;
            
            // Show banner and set initial text
            banner.classList.remove('hidden');
            textEl.textContent = 'Preparing video...';
            
            // After 3 seconds, change to "Adding speech..."
            const timeout1 = setTimeout(() => {
                if (renderStatusActive && textEl) {
                    textEl.textContent = 'Adding speech...';
                }
            }, 3000);
            renderStatusTimeouts.push(timeout1);
            
            // After 6 seconds, change to "Finalizing video..."
            const timeout2 = setTimeout(() => {
                if (renderStatusActive && textEl) {
                    textEl.textContent = 'Finalizing video...';
                }
            }, 6000);
            renderStatusTimeouts.push(timeout2);
        }
        
        function hideRenderStatus() {
            renderStatusActive = false;
            
            // Clear all timeouts
            renderStatusTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            renderStatusTimeouts = [];
            
            // Hide banner
            const banner = document.getElementById('render-status-banner');
            if (banner) {
                banner.classList.add('hidden');
            }
            
            // Reset text
            const textEl = document.getElementById('render-status-text');
            if (textEl) {
                textEl.textContent = 'Preparing video...';
            }
        }
        
        async function renderArticle() {
            const errorEl = document.getElementById('article-error');
            const renderBtn = document.getElementById('render-article-btn');
            const voicePresetEl = document.getElementById('article-voice-preset');
            const resultDiv = document.getElementById('article-render-result');
            const videoEl = document.getElementById('article-render-video');
            const videoUrlEl = document.getElementById('article-video-url');
            
            if (!window.currentStorySessionId) {
                showError('article-error', 'Please summarize the article first');
                return;
            }
            
            const voicePreset = voicePresetEl?.value || 'male_calm';
            
            setLoading('render-article-btn', true);
            hideError('article-error');
            showRenderStatus();
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Call finalize with voice preset
                const finalizeResp = await apiFetch('/story/finalize', {
                    method: 'POST',
                    body: {
                        sessionId: window.currentStorySessionId,
                        options: {
                            voicePreset: voicePreset
                        }
                    }
                });
                
                if (!finalizeResp.success) {
                    throw new Error(finalizeResp.error || finalizeResp.detail || 'Failed to finalize story');
                }
                
                const session = finalizeResp.data;
                
                // Check if video is already ready
                if (session.finalVideo?.url) {
                    // Render complete immediately!
                    if (videoEl) {
                        videoEl.src = session.finalVideo.url;
                    }
                    if (videoUrlEl) {
                        videoUrlEl.href = session.finalVideo.url;
                    }
                    if (resultDiv) {
                        resultDiv.classList.remove('hidden');
                    }
                    console.log('[article] Render complete:', session.finalVideo.url);
                } else {
                    // Poll for completion (similar to oneClickShortFromLink)
                    const sessionId = window.currentStorySessionId;
                    let attempts = 0;
                    const maxAttempts = 60; // 5 minutes max
                    
                    while (attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, 5000)); // Poll every 5 seconds
                        
                        const statusResp = await apiFetch(`/story/${sessionId}`, {
                            method: 'GET'
                        });
                        
                        if (!statusResp.success || !statusResp.data) {
                            throw new Error('Failed to check render status');
                        }
                        
                        const polledSession = statusResp.data;
                        
                        if (polledSession.finalVideo?.url) {
                            // Render complete!
                            if (videoEl) {
                                videoEl.src = polledSession.finalVideo.url;
                            }
                            if (videoUrlEl) {
                                videoUrlEl.href = polledSession.finalVideo.url;
                            }
                            if (resultDiv) {
                                resultDiv.classList.remove('hidden');
                            }
                            
                            console.log('[article] Render complete:', polledSession.finalVideo.url);
                            break;
                        }
                        
                        attempts++;
                    }
                    
                    if (attempts >= maxAttempts) {
                        throw new Error('Render timed out - please try again');
                    }
                }
                
            } catch (error) {
                console.error('[article] Render failed:', error);
                showError('article-error', error.message || 'Failed to render video');
            } finally {
                hideRenderStatus();
                setLoading('render-article-btn', false);
            }
        }
        
        // Expose to window scope for ui-actions.js
        window.summarizeArticle = summarizeArticle;
        window.renderArticle = renderArticle;
        window.prepareStoryboard = prepareStoryboard;

        // Remix quote function
        async function remixQuote(mode) {
            if (!currentQuote) return;
            if (!window.auth?.currentUser) {
                showError('quote-error', 'Please log in to remix quotes');
                return;
            }
            
            setLoading('generate-quote-btn', true);
            hideError('quote-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                const data = await apiFetch('/quotes/remix', {
                    method: 'POST',
                    body: {
                        // Prefer live textarea content so users don't need to hit Save first
                        originalText: (document.getElementById('quote-edit')?.value || currentQuote.text || '').trim(),
                        mode,
                        targetTone: mode === 'tone_shift' ? document.getElementById('quote-tone').value : undefined,
                        maxChars: 120
                    }
                });
                
                if (data.ok) {
                    currentQuote = data.data.quote;
                    await displayQuote(currentQuote, { skipPreview: true }); // Skip preview during remix
                    decRegens();
                    // Keep the editor visible with new text
                    try {
                      document.getElementById('quote-text-display').classList.add('hidden');
                      document.getElementById('quote-edit').classList.remove('hidden');
                      document.getElementById('save-quote-btn').classList.remove('hidden');
                      document.getElementById('cancel-quote-btn').classList.remove('hidden');
                      document.getElementById('edit-quote-btn').classList.add('hidden');
                    } catch {}
                } else {
                    showError('quote-error', data.reason || 'Failed to remix quote');
                }
            } catch (error) {
                showError('quote-error', error.message || 'Network error');
            } finally {
                setLoading('generate-quote-btn', false);
            }
        }

        // Expose to window scope for ui-actions.js
        window.remixQuote = remixQuote;

        // AI Image generation
        async function generateAiImage() {
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            // Check if user has sufficient credits (20 credits for AI generation)
            if (window.currentCredits < 20) {
                showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                return;
            }
            
            const prompt = document.getElementById('ai-prompt').value;
            const styleSlider = document.getElementById('ai-style-slider').value;
            
            if (!prompt.trim()) {
                showError('ai-error', 'Please enter a prompt');
                return;
            }
            
            setLoading('generate-ai-btn', true);
            hideError('ai-error');
            
            try {
                const { apiFetch } = await import('./api.mjs');
                
                // Map slider value to style: 0-0.5 = realistic, 0.5-1 = cartoon
                const style = parseFloat(styleSlider) <= 0.5 ? 'realistic' : 'cartoon';
                
                // Map slider 0..1 ‚Üí ideogram style_type: closer to Realistic at 0, Creative at 1
                const creative = parseFloat(styleSlider);
                const styleType = creative < 0.33 ? 'Photographic' : (creative > 0.66 ? 'Illustration' : 'None');

                const data = await apiFetch('/generate', {
                    method: 'POST',
                    body: {
                        prompt,
                        style, // retained for compatibility
                        count: 1,
                        // ideogram params ride along; backend adapter maps them
                        params: { style_type: styleType },
                        options: {}
                    }
                });
                
                if (data?.ok === true && data?.data?.images) {
                    // Handle successful generation
                    const imgs = data.data.images || [];
                    const first = imgs[0];
                    const url = typeof first === 'string' ? first : (first?.url || first);
                    if (url) {
                        // Update credits display if successful (20 credits deducted by backend)
                        window.currentCredits -= 20;
                        if (window.updateCreditsDisplay) {
                            window.updateCreditsDisplay(window.currentCredits);
                        }
                        
                        const aiAsset = {
                            id: `ai-${Date.now()}`,
                            fileUrl: url,
                            thumbUrl: url,
                            width: 1080,
                            height: 1920,
                            query: prompt,
                            provider: 'ai',
                            type: 'ai-generated'
                        };
                        // Add to asset grid
                        const grid = document.getElementById('asset-grid');
                        const assetElement = createAssetElement(aiAsset);
                        grid.insertBefore(assetElement, grid.firstChild);
                        // Also show next to remix references if present
                        const aiBlock = document.getElementById('ai-result-block');
                        const aiPrev = document.getElementById('ai-result-preview');
                        if (aiBlock && aiPrev) {
                            aiPrev.innerHTML = `<img src="${aiAsset.thumbUrl}" class="w-full h-full object-cover" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.src='/img/placeholder.svg'" />`;
                            aiBlock.classList.remove('hidden');
                        }
                        // Auto-select the generated image
                        selectAsset(aiAsset);
                    } else {
                        showError('ai-error', 'No image URL returned');
                    }
                } else {
                    // Some backends use { ok:false, reason } envelope
                    showError('ai-error', (data && (data.reason || data.error)) || 'Failed to generate AI image');
                }
            } catch (error) {
                if (error?.reason === 'INSUFFICIENT_CREDITS') {
                    showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                } else {
                    showError('ai-error', error.message || 'Network error');
                }
            } finally {
                setLoading('generate-ai-btn', false);
            }
        }

        // Remix button handler: require at least 1 reference, prefer 2
        document.addEventListener('click', (e) => {
            const t = e.target;
            if (!t || t.id !== 'remix-generate-btn') return;
            e.preventDefault();
            
            // Check if user is logged in
            if (!window.auth?.currentUser) {
                showError('ai-error', 'Please log in to generate AI images');
                return;
            }
            
            // Check if user has sufficient credits (20 credits for AI generation)
            if (window.currentCredits < 20) {
                showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                return;
            }
            
            // Collect refs + prompt + style, then call generate endpoint
            const base = document.getElementById('ai-prompt');
            const prompt = (base?.value || '').trim();
            const styleSlider = document.getElementById('ai-style-slider');
            const sVal = parseFloat(styleSlider?.value || '0.5');
            const style = sVal < 0.33 ? 'realistic' : (sVal > 0.66 ? 'creative' : 'realistic');

            const refs = Array.from(document.querySelectorAll('#remix-assets img, #remix-assets video'))
              .map((el)=> el.getAttribute('src') || el.getAttribute('poster'))
              .filter(Boolean)
              .filter((v, i, arr) => arr.indexOf(v) === i)
              .slice(0,2);

            // Fallback to simple text-to-image if no refs
            if (refs.length < 2) {
              generateAiImage();
              return;
            }

            // Use existing assets API for AI image generation (single image)
            // We reuse the /assets/ai-images for now with count:1
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                // Compose a richer prompt mentioning references implicitly
                const styleMap = style === 'creative' ? 'illustration' : 'photographic';
                const data = await apiFetch('/assets/ai-images', { method:'POST', body: { prompt: `${prompt}`.trim(), style: style === 'creative' ? 'creative' : 'realistic', count: 1 } });
                console.log('[AI Image] Response:', data); // Debug log
                if (!data?.ok || !data?.data?.images || data.data.images.length === 0) {
                    console.error('[AI Image] Failed:', data);
                    showError('ai-error', 'AI image generation failed'); 
                    return; 
                }
                
                const firstImage = data.data.images[0];
                const url = firstImage?.url || null;
                if (!url) { showError('ai-error', 'No image URL in response'); return; }
                
                // Update credits display if successful
                if (data?.data?.creditsDeducted) {
                    window.currentCredits -= data.data.creditsDeducted;
                    if (window.updateCreditsDisplay) {
                        window.updateCreditsDisplay(window.currentCredits);
                    }
                }
                
                // Display result
                const aiBlock = document.getElementById('ai-result-block');
                const aiPrev = document.getElementById('ai-result-preview');
                if (aiBlock && aiPrev) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(url)}`;
                  aiPrev.innerHTML = `<img crossOrigin="anonymous" src="${proxied}" class="w-full h-full object-cover block" />`;
                  aiBlock.classList.remove('hidden');
                }
              } catch (err) {
                if (err?.reason === 'INSUFFICIENT_CREDITS') {
                    showError('ai-error', 'You need 20 credits to generate AI images. You have insufficient credits.');
                } else {
                    showError('ai-error', err?.message || 'AI generation error');
                }
              }
            })();
        });

        // Save & Use handler: persists image URL and marks as selected background
        document.addEventListener('click', async (e) => {
            if (e.target?.id !== 'ai-save-use-btn') return;
            e.preventDefault();
            try {
              const imgEl = document.querySelector('#ai-result-preview img');
              const url = imgEl?.getAttribute('src');
              if (!url) return;
              const { apiFetch } = await import('./api.mjs');
              // Store the image in storage and get a tokenized URL
              const reg = await apiFetch('/uploads/register', { method:'POST', body:{ imageUrl: url } });
              const savedUrl = reg?.data?.url || url;
              // Mark selection locally and update preview immediately
              selectedAsset = { id: `ai-${Date.now()}`, provider: 'ai', query: (document.getElementById('ai-prompt')?.value||'').trim(), fileUrl: savedUrl, thumbUrl: savedUrl, width: 1080, height: 1920 };
              updateRenderPreview();
              updateRenderButtonState();
              // Also update dedicated preview nodes if present
              try {
                // Ensure we have a preview <img id="preview-img"> inside live preview
                let previewImg = document.getElementById('preview-img');
                if (!previewImg) {
                  const live = document.getElementById('live-preview-container');
                  if (live) {
                    live.classList.remove('hidden');
                    const holder = live.querySelector('.relative') || live;
                    // Force 9x16 preview aspect
                    try { holder.style.aspectRatio = '9 / 16'; } catch {}
                    try { if (!holder.style.background) holder.style.background = '#000'; } catch {}
                    // Clear holder if it only had a canvas (we'll still keep canvas for other flows)
                    // but append img above it so swap is visible immediately
                    previewImg = document.createElement('img');
                    previewImg.id = 'preview-img';
                    previewImg.style.width = '100%';
                    previewImg.style.height = '100%';
                    previewImg.style.display = 'block';
                    previewImg.style.objectFit = 'cover';
                    holder.prepend(previewImg);
                    // Hide canvas during static image preview to avoid black overlay
                    try { const c = holder.querySelector('#live-preview-canvas'); if (c) c.style.display = 'none'; } catch {}
                  }
                }
                if (previewImg) {
                  try { previewImg.crossOrigin = 'anonymous'; } catch {}
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewImg.src = proxied;
                }
                // Ensure overlay visible for still image preview
                try { const ov = document.getElementById('caption-overlay'); if (ov) ov.style.display = 'block'; } catch {}
                const previewBox = document.getElementById('short-preview');
                if (previewBox) {
                  const proxied = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
                  previewBox.style.backgroundImage = `url("${proxied}")`;
                  previewBox.setAttribute('data-bg', proxied);
                }
                window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentBackgroundUrl = `${getApiBase()}/cdn?u=${encodeURIComponent(savedUrl)}`;
              } catch {}
              // Feedback
              try { showToast('‚úÖ Saved to My Images and selected'); } catch {}
            } catch (err) {
              console.warn('Save & Use failed:', err);
            }
        });

        // Event listeners - generateQuote now handled by ui-actions.js
        const useTextBtn = document.getElementById('use-text-btn');
        if (useTextBtn) {
          useTextBtn.onclick = () => {
            const input = document.getElementById('quote-text').value.trim();
            if (!input) return;
            currentQuote = { text: input };
            displayQuote(currentQuote);
            // Ensure visible in view mode on use
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.classList.add('hidden');
            disp.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            // do not reset regen counter here
            // Persist immediately so it can be used for the short without extra clicks
            (async ()=>{
              try {
                const { apiFetch } = await import('./api.mjs');
                await apiFetch('/quotes/save', { method:'POST', body:{ text: input, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
                try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = input; } catch {}
              } catch (e) {
                console.warn('Use This Text save failed:', e?.message || e);
              }
            })();
            
            // Trigger caption preview immediately after using text
            try {
                updateCaptionOverlay(input, true);
            } catch (e) {
                console.warn('[caption-overlay] auto-preview failed (non-fatal)', e);
            }
          };
        }
        // search-assets-btn now handled by ui-actions.js
        const prevPageBtn = document.getElementById('prev-page-btn');
        if (prevPageBtn) prevPageBtn.onclick = () => loadAssets(currentAssetPage - 1);
        
        const nextPageBtn = document.getElementById('next-page-btn');
        if (nextPageBtn) nextPageBtn.onclick = () => loadAssets(currentAssetPage + 1);
        
        const generateAiBtn = document.getElementById('generate-ai-btn');
        if (generateAiBtn) generateAiBtn.onclick = generateAiImage;
        
        const uploadAssetBtn = document.getElementById('upload-asset-btn');
        if (uploadAssetBtn) uploadAssetBtn.onclick = () => {
            const uploadInput = document.getElementById('asset-upload-input');
            if (uploadInput) uploadInput.click();
        };
        const assetUploadInput = document.getElementById('asset-upload-input');
        if (assetUploadInput) assetUploadInput.onchange = (e) => handleFileUpload(e.target.files);
        
        const clearRemixBtn = document.getElementById('clear-remix-btn');
        if (clearRemixBtn) clearRemixBtn.onclick = () => {
            remixAssets = [];
            updateRemixArea();
        };
        
        const renderBtn = document.getElementById('render-btn');
        if (renderBtn) renderBtn.onclick = createShort;
        
        // Wire mobile Create button to same function
        const mobileCreateBtn = document.getElementById('mobile-create-btn');
        if (mobileCreateBtn) mobileCreateBtn.onclick = createShort;
        
        // Overlay mode toggle event listener (auto-initialize overlay; no extra buttons)
        const overlayModeToggle = document.getElementById('overlay-mode-toggle');
        if (overlayModeToggle) overlayModeToggle.onchange = toggleOverlayMode;
        
        // Overlay control event listeners
        const showOutlineToggle = document.getElementById('show-outline-toggle');
        if (showOutlineToggle) showOutlineToggle.onchange = async () => {
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js');
                    const meta = getCaptionMeta();
                    meta.showBox = document.getElementById('show-outline-toggle').checked;
                    applyCaptionMeta(meta);
                } catch (e) {
                    console.warn('[overlay] outline toggle failed', e);
                }
            }
        };
        
        const responsiveTextToggle = document.getElementById('responsive-text-toggle');
        if (responsiveTextToggle) responsiveTextToggle.onchange = async () => {
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js');
                    const meta = getCaptionMeta();
                    meta.responsiveText = document.getElementById('responsive-text-toggle').checked;
                    applyCaptionMeta(meta);
                } catch (e) {
                    console.warn('[overlay] responsive text toggle failed', e);
                }
            }
        };
        
        // Debug function to check overlay system status
        window.debugOverlaySystem = function() {
            console.log('[debug] Overlay system status:', {
                useOverlayMode,
                overlaySystemInitialized,
                hasGetCaptionMeta: typeof window.getCaptionMeta === 'function',
                hasSetQuote: typeof window.setQuote === 'function',
                stageVisible: document.getElementById('stage').style.display !== 'none',
                legacyOverlayVisible: document.getElementById('caption-overlay').style.display !== 'none'
            });
            
            if (useOverlayMode && overlaySystemInitialized) {
                try {
                    const meta = window.getCaptionMeta();
                    console.log('[debug] Current overlay meta:', meta);
                } catch (error) {
                    console.error('[debug] Failed to get overlay meta:', error);
                }
            }
        };
        
        // Caption style event listeners
        const captionFont = document.getElementById('caption-font');
        if (captionFont) captionFont.onchange = async () => {
            if (useOverlayMode) { try { const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js'); const m = getCaptionMeta(); m.fontFamily = document.getElementById('caption-font').value; applyCaptionMeta(m); } catch(e){ console.warn('[overlay] font apply failed', e);} }
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        const captionWeight = document.getElementById('caption-weight');
        if (captionWeight) captionWeight.onchange = async () => {
            const newWeight = document.getElementById('caption-weight').value;
            console.log('[controls] Weight changed to:', newWeight);
            if (useOverlayMode) { try { const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js'); const m = getCaptionMeta(); m.weightCss = newWeight; applyCaptionMeta(m); } catch(e){ console.warn('[overlay] weight apply failed', e);} }
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        // Legacy caption-size handler removed - now handled by initCaptionSizeUI()
        document.getElementById('caption-opacity').oninput = async () => { 
            const newOpacity = document.getElementById('caption-opacity').value;
            console.log('[controls] Opacity changed to:', newOpacity);
            if (useOverlayMode) { try { const { getCaptionMeta, applyCaptionMeta } = await import('./js/caption-overlay.js'); const m = getCaptionMeta(); m.opacity = parseInt(newOpacity)/100; applyCaptionMeta(m); } catch(e){ console.warn('[overlay] opacity apply failed', e);} }
            updateCaptionStyleValues(); 
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true); 
        };
        const captionPlacement = document.getElementById('caption-placement');
        if (captionPlacement) captionPlacement.onchange = () => {
            const newPlacement = document.getElementById('caption-placement').value;
            console.log('[controls] Placement changed to:', newPlacement);
            
            // Snap box using overlay API
            if (window.OverlayAPI?.snapToPlacement) {
                window.OverlayAPI.snapToPlacement(newPlacement);
            }
            
            updateRenderPreview();
        };
        const captionBackground = document.getElementById('caption-background');
        if (captionBackground) captionBackground.onchange = () => {
            updateRenderPreview();
            updateLivePreview();
            updateCaptionOverlay((currentQuote?.text||'').trim(), true);
            updateOverlayCaption((currentQuote?.text||'').trim(), true);
        };
        document.getElementById('caption-bg-opacity').oninput = () => { updateCaptionStyleValues(); updateCaptionOverlay((currentQuote?.text||'').trim(), true); };
        
        // Voiceover event listeners
        const voiceoverVoice = document.getElementById('voiceover-voice');
        if (voiceoverVoice) voiceoverVoice.onchange = () => {
            const voiceSelect = document.getElementById('voiceover-voice');
            currentVoiceId = voiceSelect.value || null;
            updateRenderPreview();
        };
        const previewVoiceBtn = document.getElementById('preview-voice-btn');
        if (previewVoiceBtn) previewVoiceBtn.onclick = previewVoice;
        
        // TTS Settings event handlers
        document.getElementById('tts-stability').oninput = function() {
            document.getElementById('stability-value').textContent = this.value;
            updateRenderPreview();
        };
        document.getElementById('tts-similarity').oninput = function() {
            document.getElementById('similarity-value').textContent = this.value;
            updateRenderPreview();
        };
        document.getElementById('tts-style').oninput = function() {
            document.getElementById('style-value').textContent = this.value;
            updateRenderPreview();
        };
        const ttsSpeakerBoost = document.getElementById('tts-speaker-boost');
        if (ttsSpeakerBoost) ttsSpeakerBoost.onchange = function() {
            updateRenderPreview();
        };

        // Remix button event listeners now handled by ui-actions.js

        // Inline edit handlers - converted to named functions for ui-actions.js
        function editQuote() {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            ta.value = (currentQuote?.text || '').trim();
            disp.classList.add('hidden');
            ta.classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.remove('hidden');
            document.getElementById('cancel-quote-btn').classList.remove('hidden');
            document.getElementById('edit-quote-btn').classList.add('hidden');
            // While editing, hide caption overlay
            updateCaptionOverlay('', false);
        }

        function cancelEdit() {
            const disp = document.getElementById('quote-text-display');
            const ta = document.getElementById('quote-edit');
            // remain in edit mode but clear contents
            ta.value = '';
            updateCaptionOverlay('', false);
            // do not change regen counter
        }

        async         function saveQuote() {
            const ta = document.getElementById('quote-edit');
            const newText = ta.value.trim().slice(0, 200);
            if (!newText) return;
            currentQuote = { ...(currentQuote||{}), text: newText };
            document.getElementById('quote-text-display').textContent = newText;
            // do not reset regen counter on save
            // switch to locked/solid view after save
            
            // Invalidate saved preview since quote text changed
            if (window.markPreviewUnsaved) {
                window.markPreviewUnsaved();
                updateRenderButtonState();
            }
            ta.classList.add('hidden');
            document.getElementById('quote-text-display').classList.remove('hidden');
            document.getElementById('save-quote-btn').classList.add('hidden');
            document.getElementById('cancel-quote-btn').classList.add('hidden');
            document.getElementById('edit-quote-btn').classList.remove('hidden');
            updateRenderPreview();
            
            // Always show caption after save (even with no media)
            try {
                console.log('[save] caption text:', newText);
                await ensureOverlayActive();
                
                if (useOverlayMode && overlaySystemInitialized) {
                    console.log('[overlay-caption] set:', newText.substring(0,80));
                    await updateOverlayCaption(newText, true);
                    
                    // If no media selected yet, ensure stage stays visible with black background
                    if (!selectedAsset) {
                        const stage = document.getElementById('stage');
                        const previewMedia = document.getElementById('previewMedia');
                        
                        // Ensure stage has minimum dimensions (prevent collapse)
                        if (stage) {
                            stage.style.display = 'block';
                            stage.style.minHeight = '400px';
                            stage.style.backgroundColor = '#000';
                        }
                        
                        if (previewMedia) {
                            // 1x1 black pixel data URL (more deterministic than CSS background)
                            previewMedia.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
                            previewMedia.style.display = 'block';
                            console.log('[overlay-save] text: "' + newText.substring(0, 40) + '...", hasMedia: false');
                        }
                    } else {
                        console.log('[overlay-save] text: "' + newText.substring(0, 40) + '...", hasMedia: true');
                    }
                    
                    // Ensure overlay is visible on top
                    try {
                        const { ensureOverlayTopAndVisible } = await import('./js/caption-overlay.js');
                        ensureOverlayTopAndVisible('#stage');
                    } catch {}
                } else {
                    updateCaptionOverlay(newText, true);
                }
            } catch (e) {
                console.warn('[overlay] save‚Üíoverlay failed', e);
            }

            // Persist to backend so it can be used in the short without CORS issues
            try {
              const { apiFetch } = await import('./api.mjs');
              await apiFetch('/quotes/save', { method: 'POST', body: { text: newText, author: '', toneTag: (document.getElementById('quote-tone')?.value || 'default') } });
              try { window.VAIFORM = window.VAIFORM || {}; window.VAIFORM.currentQuoteText = newText; } catch {}
            } catch (e) {
              console.warn('Quote save failed (non-fatal):', e?.message || e);
            }
        }

        // Expose to window scope for ui-actions.js
        window.editQuote = editQuote;
        window.cancelEdit = cancelEdit;
        window.saveQuote = saveQuote;

        // Character counter for input
        document.getElementById('quote-text').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
        });

        // Also update counter when typing inside the inlaid editor
        document.getElementById('quote-edit').addEventListener('input', (e) => {
            const v = e.target.value || '';
            const n = Math.min(200, v.length);
            document.getElementById('quote-char-count').textContent = `${n}/200`;
            // live overlay while editing
            try { updateCaptionOverlay(v, true); } catch {}
        });

        // Resize listener for zoom/resize scenarios - re-render preview
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Skip overlay positioning if drag is active
                if (!window.__overlayIsDragging) {
                    try { import('./js/caption-overlay.js').then(({ ensureOverlayTopAndVisible }) => ensureOverlayTopAndVisible('#stage')); } catch {}
                }
                if (selectedAsset) {
                    if (_currentPexelsPhoto && selectedAsset?.provider === 'pexels') {
                        // Preserve existing previewUrl when updating selectedAsset
                        const existingPreviewUrl = selectedAsset.previewUrl;
                        selectedAsset = { ...selectedAsset, ..._currentPexelsPhoto };
                        if (existingPreviewUrl) {
                            selectedAsset.previewUrl = existingPreviewUrl;
                        }
                        onPexelsUse(_currentPexelsPhoto);
                    } else {
                        // For non-Pexels assets, just redraw the preview
                        updateLivePreview();
                    }
                }
            }, 150); // Debounce resize events
        });

        // Tab switching is now handled by the delegated router in ui-actions.js
        // No duplicate onclick handlers needed
        

        // Theme toggle functionality
        function initTheme() {
            const themeToggle = document.getElementById('theme-toggle');
            if (!themeToggle) return;

            // Set initial theme
            if (localStorage.getItem("theme") === "dark") {
                document.documentElement.classList.add("dark");
                themeToggle.textContent = "üåô";
            } else {
                document.documentElement.classList.remove("dark");
                themeToggle.textContent = "‚òÄÔ∏è";
            }

            // Theme toggle event listener
            themeToggle.addEventListener("click", () => {
                const isDark = document.documentElement.classList.toggle("dark");
                localStorage.setItem("theme", isDark ? "dark" : "light");
                themeToggle.textContent = isDark ? "üåô" : "‚òÄÔ∏è";
            });
        }

        // Initialize authentication using existing system
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme first
            initTheme();
            
            // Wait for auth system to be ready
            const checkAuth = () => {
                if (window.auth && window.onAuthStateChanged) {
                    // Listen for auth state changes
                    window.onAuthStateChanged(window.auth, async (user) => {
                        const loggedIn = !!user;
                        
                        // Update UI visibility
                        document.querySelectorAll(".logged-in")?.forEach(el => el.classList.toggle("hidden", !loggedIn));
                        document.querySelectorAll(".logged-out")?.forEach(el => el.classList.toggle("hidden", loggedIn));

                        if (!loggedIn) {
                            updateCreditUI(0);
                            updateRenderButtonState();
                            return;
                        }

                        try {
                            // Give api.mjs a brief moment to obtain the token via the bridge
                            if (window.__vaiform_diag__?.tokenWait) { 
                                await window.__vaiform_diag__.tokenWait(4000); 
                            }
                            await refreshCredits(true);
                            
                            // Update render button state after auth changes
                            updateRenderButtonState();
                            
                            // Load voices with a small delay to ensure auth is fully ready
                            setTimeout(() => {
                                loadVoices();
                            }, 500);
                        } catch (e) {
                            console.error("Failed to refresh credits:", e);
                        }
                    });
                } else {
                    // Retry in 100ms if auth not ready yet
                    setTimeout(checkAuth, 100);
                }
            };
            
            checkAuth();

            // Initialize quote editor for manual entry from the start
            try {
                const seedInput = document.getElementById('quote-text');
                const seed = (seedInput?.value || '').trim();
                // Use default caption if no seed text provided
                const defaultCaption = seed || 'Success is the result of persistent effort and unwavering belief in yourself.';
                currentQuote = { text: defaultCaption };
                displayQuote(currentQuote);
                // Switch to edit mode by default so users can type immediately
                const disp = document.getElementById('quote-text-display');
                const ta = document.getElementById('quote-edit');
                disp.classList.add('hidden');
                ta.classList.remove('hidden');
                document.getElementById('save-quote-btn').classList.remove('hidden');
                document.getElementById('cancel-quote-btn').classList.remove('hidden');
                document.getElementById('edit-quote-btn').classList.add('hidden');
                // Do not reset regen counter on init
                // Fix E: Initialize preview system after content is ready
                try { 
                    initPreviewSystem();
                    
                    // Fix E: Add ResizeObserver for canvas resizing
                    const canvas = document.getElementById('live-preview-canvas');
                    const container = document.getElementById('live-preview-container');
                    if (canvas && container) {
                        new ResizeObserver(() => {
                            if (window.__overlayIsDragging) return; // Skip during drag
                            if (sizeCanvasToCSS(canvas)) {
                                // Trigger preview update on resize
                                if (currentQuote?.text && selectedAsset) {
                                    updateLivePreview();
                                    updateCaptionOverlay(currentQuote.text.trim(), true);
                                }
                            }
                        }).observe(container);
                    }
                } catch (e) {
                    console.warn('[preview-init] failed:', e);
                }
                
                // Seed char counter
                const n = Math.min(200, defaultCaption.length);
                const cc = document.getElementById('quote-char-count');
                if (cc) cc.textContent = `${n}/200`;
            } catch {}
        });

        // Fix E: Ensure the first render actually fires
        window.addEventListener('load', () => {
            console.log('[preview-init] Page loaded, initializing preview');
            initPreviewSystem();
            
            // Setup canvas observer for new preview fixes
            if (window.__PREVIEW_FIX__) {
                setupCanvasObserver();
                
                // Re-run render on visibilitychange when tab becomes visible
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && canvasReadyState.ready) {
                        console.log('[preview-init] Tab visible, reinitializing preview');
                        scheduleRender();
                    }
                });
            }
            
            // Also trigger preview if we already have both quote and asset
            if (currentQuote && selectedAsset) {
                console.log('[preview-init] Both quote and asset available, triggering preview');
                updateLivePreview();
                updateCaptionOverlay(currentQuote.text.trim(), true);
            }
        });
        
        // Removed duplicate visibilitychange listener - consolidated into DOMContentLoaded handler above
    </script>

    <script>
      // ========================================
      // AUDIT NOTES (Phase 0 findings):
      // - Router: Single delegated click router in ui-actions.js using [data-action]
      // - Router style: Calls window.* functions (generateQuote, remixQuote, loadAssets, etc.)
      // - DOM selectors: Already correct (#quote-text, #quote-tone, #quote-result, #asset-query, #asset-grid)
      // - Functions exposed: window.generateQuote (line ~1706), window.loadAssets (~1801), window.remixQuote (~3236)
      // - Now also exposed: window.editQuote, window.cancelEdit, window.saveQuote (~3754-3756)
      // - No legacy-gate blocks found
      // - SSOT: One router (ui-actions.js), one set of controllers, one overlay update path
      // - Safe `must()` helper already exists at line ~1046
      // ========================================

      // Accordion behavior - single open section
      (function(){
        const headers = document.querySelectorAll('.accordion-header');
        const bodies = document.querySelectorAll('.accordion-body');
        
        // Check if we're on mobile
        function isMobile() {
          return window.matchMedia('(max-width: 768px)').matches;
        }
        
        function toggleSection(targetSection) {
          const targetHeader = document.querySelector(`[data-section="${targetSection}"]`);
          const targetBody = document.getElementById(`${targetSection}-body`);
          const targetIcon = targetHeader?.querySelector('.accordion-icon');
          
          // Toggle the clicked section
          if (targetHeader?.classList.contains('active')) {
            // Close if already open
            targetHeader.classList.remove('active');
            targetBody?.classList.remove('active');
            targetIcon.textContent = '‚ñ∂';
          } else {
            // Open if closed
            targetHeader.classList.add('active');
            targetBody?.classList.add('active');
            targetIcon.textContent = '‚ñº';
          }
        }
        
        headers.forEach(header => {
          header.addEventListener('click', (event) => {
            // On mobile, accordion headers are handled by mobile tab logic
            if (isMobile()) {
              return; // Let mobile tab logic handle it
            }
            
            // Desktop behavior: only toggle if clicking the header itself, not buttons inside
            if (event.target === header || event.target.closest('.accordion-header') === header) {
              // Don't toggle if clicking on action buttons
              if (event.target.dataset && event.target.dataset.action) {
                return;
              }
              const section = header.dataset.section;
              toggleSection(section);
            }
          });
        });
        
        // Update summaries when state changes
        function updateSummaries() {
          // Quote summary
          const quoteSummary = document.getElementById('quote-summary');
          if (quoteSummary && window.currentQuote?.text) {
            const text = window.currentQuote.text.substring(0, 50);
            quoteSummary.textContent = text + (window.currentQuote.text.length > 50 ? '...' : '');
          }
          
          // Media summary
          const mediaSummary = document.getElementById('media-summary');
          if (mediaSummary && window.selectedAsset) {
            const asset = window.selectedAsset;
            let summary = '';
            if (asset.provider === 'pexels') {
              summary = `Pexels ‚Ä¢ ${asset.query || 'Image'}`;
            } else if (asset.provider === 'ai') {
              summary = `AI ‚Ä¢ ${asset.query || 'Generated'}`;
            } else if (asset.provider === 'uploaded') {
              summary = 'Uploaded file';
            }
            mediaSummary.textContent = summary;
          }
          
          // Voice summary
          const voiceSummary = document.getElementById('voice-summary');
          if (voiceSummary && window.currentVoiceId) {
            const voiceSelect = document.getElementById('voiceover-voice');
            const selectedOption = voiceSelect?.selectedOptions[0];
            const voiceName = selectedOption?.text || window.currentVoiceId;
            voiceSummary.textContent = voiceName;
          }
        }
        
        // Hook into existing state updates
        const originalDisplayQuote = window.displayQuote;
        if (originalDisplayQuote) {
          window.displayQuote = function(quote) {
            originalDisplayQuote(quote);
            updateSummaries();
          };
        }
        
        // Mobile tab switching logic
        (function() {
          let activeMobileTab = null;
          
          // Check if we're on mobile
          function isMobile() {
            return window.matchMedia('(max-width: 768px)').matches;
          }
          
          // Function to switch to a specific tab (reuses existing accordion DOM)
          function switchToTab(section) {
            if (!isMobile()) return;
            
            // Map section names to tab IDs
            const tabIdMap = {
                'quote': 'mobile-tab-quote',
                'media': 'mobile-tab-background',
                'voice': 'mobile-tab-voiceover'
            };
            const tabButton = document.getElementById(tabIdMap[section]);
            const accordionBody = document.getElementById(`${section}-body`);
            const accordionHeader = document.querySelector(`[data-section="${section}"]`);
            const accordionIcon = accordionHeader?.querySelector('.accordion-icon');
            
            // If clicking the same tab, collapse it
            if (activeMobileTab === section) {
              activeMobileTab = null;
              if (tabButton) tabButton.classList.remove('active');
              if (accordionBody) accordionBody.classList.remove('active');
              if (accordionHeader) accordionHeader.classList.remove('active');
              if (accordionIcon) accordionIcon.textContent = '‚ñ∂';
              return;
            }
            
            // Close all other tabs and accordion bodies
            document.querySelectorAll('.mobile-studio-tab').forEach(tab => {
              tab.classList.remove('active');
            });
            document.querySelectorAll('.accordion-body').forEach(body => {
              body.classList.remove('active');
            });
            document.querySelectorAll('.accordion-header').forEach(header => {
              header.classList.remove('active');
              const icon = header.querySelector('.accordion-icon');
              if (icon) icon.textContent = '‚ñ∂';
            });
            
            // Open the selected tab
            activeMobileTab = section;
            if (tabButton) tabButton.classList.add('active');
            if (accordionBody) accordionBody.classList.add('active');
            if (accordionHeader) accordionHeader.classList.add('active');
            if (accordionIcon) accordionIcon.textContent = '‚ñº';
          }
          
          // Set up tab click handlers
          document.querySelectorAll('.mobile-studio-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
              e.preventDefault();
              const section = tab.dataset.section;
              switchToTab(section);
            });
          });
          
          // On mobile, make accordion headers call the same logic as tabs
          // (Note: accordion headers already skip their default behavior on mobile via the check above)
          // We add a separate listener that runs after the desktop check
          headers.forEach(header => {
            header.addEventListener('click', (event) => {
              if (!isMobile()) return; // Desktop behavior unchanged
              
              // Don't interfere with action buttons
              if (event.target.dataset && event.target.dataset.action) {
                return;
              }
              
              // Only handle if clicking the header itself
              if (event.target === header || event.target.closest('.accordion-header') === header) {
                const section = header.dataset.section;
                switchToTab(section);
              }
            });
          });
          
          // Initialize: open Quote tab by default on mobile
          if (isMobile()) {
            switchToTab('quote');
          }
          
          // Handle window resize to sync state
          let resizeTimeout;
          window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              if (!isMobile()) {
                // Reset mobile state when switching to desktop
                activeMobileTab = null;
                document.querySelectorAll('.mobile-studio-tab').forEach(tab => {
                  tab.classList.remove('active');
                });
              } else {
                // Initialize mobile state when switching to mobile
                if (!activeMobileTab) {
                  switchToTab('quote');
                }
              }
            }, 100);
          });
        })();
        
        // Update summaries on load
        setTimeout(updateSummaries, 1000);
        
        // Update preview height based on media selection
        function updatePreviewHeight() {
          const previewContainer = document.getElementById('live-preview-container');
          if (previewContainer) {
            if (window.selectedAsset) {
              previewContainer.classList.add('has-media');
            } else {
              previewContainer.classList.remove('has-media');
            }
          }
        }
        
        // Hook into asset selection to update preview height
        const originalAssetSelection = window.onAssetSelect;
        if (originalAssetSelection) {
          window.onAssetSelect = function(asset) {
            originalAssetSelection(asset);
            updatePreviewHeight();
          };
        }
        
        // Update preview height on load
        setTimeout(updatePreviewHeight, 1000);
        
        // Media buttons are now handled by ui-actions.js delegated event system
      })();
      
      // Debug helper for caption box visibility
      window.debugCaptionBox = function() {
        const stage = document.getElementById('stage');
        const box = stage?.querySelector('.caption-box');
        const container = document.getElementById('live-preview-container');
        const canvas = document.getElementById('live-preview-canvas');
        
        if (!stage) {
          console.warn('[debugCaptionBox] Stage not found');
          return;
        }
        
        if (!box) {
          console.warn('[debugCaptionBox] Caption box not found');
          return;
        }
        
        const stageRect = stage.getBoundingClientRect();
        const boxRect = box.getBoundingClientRect();
        const containerRect = container?.getBoundingClientRect();
        const canvasRect = canvas?.getBoundingClientRect();
        
        console.log('[debugCaptionBox] Stage:', {
          display: window.getComputedStyle(stage).display,
          visibility: window.getComputedStyle(stage).visibility,
          opacity: window.getComputedStyle(stage).opacity,
          rect: { width: stageRect.width, height: stageRect.height, top: stageRect.top, left: stageRect.left },
          clientWidth: stage.clientWidth,
          clientHeight: stage.clientHeight,
          offsetWidth: stage.offsetWidth,
          offsetHeight: stage.offsetHeight
        });
        
        console.log('[debugCaptionBox] Caption Box:', {
          display: window.getComputedStyle(box).display,
          visibility: window.getComputedStyle(box).visibility,
          opacity: window.getComputedStyle(box).opacity,
          position: window.getComputedStyle(box).position,
          zIndex: window.getComputedStyle(box).zIndex,
          rect: { width: boxRect.width, height: boxRect.height, top: boxRect.top, left: boxRect.left },
          styleLeft: box.style.left,
          styleTop: box.style.top,
          offsetWidth: box.offsetWidth,
          offsetHeight: box.offsetHeight,
          clientWidth: box.clientWidth,
          clientHeight: box.clientHeight
        });
        
        console.log('[debugCaptionBox] Container:', {
          display: container ? window.getComputedStyle(container).display : 'N/A',
          rect: containerRect ? { width: containerRect.width, height: containerRect.height } : 'N/A'
        });
        
        console.log('[debugCaptionBox] Canvas:', {
          display: canvas ? window.getComputedStyle(canvas).display : 'N/A',
          rect: canvasRect ? { width: canvasRect.width, height: canvasRect.height } : 'N/A',
          canvasWidth: canvas?.width,
          canvasHeight: canvas?.height
        });
      };
      
      // Debug helper for caption visibility diagnostics
      window.debugCaptionVisibility = function() {
        const container = document.getElementById('live-preview-container');
        const stage = document.getElementById('stage');
        const box = document.querySelector('.caption-box');
        return {
          container: container && {
            classes: container.className,
            styleOpacity: container.style.opacity,
            computedOpacity: getComputedStyle(container).opacity,
          },
          stage: stage && {
            styleDisplay: stage.style.display,
            computedDisplay: getComputedStyle(stage).display,
          },
          box: box && {
            rect: box.getBoundingClientRect(),
            visible: getComputedStyle(box).visibility,
          },
        };
      };
    </script>

    <!-- Render Status Banner -->
    <div id="render-status-banner" class="hidden fixed bottom-8 left-1/2 transform -translate-x-1/2 z-50 bg-gray-900/90 dark:bg-gray-800/90 backdrop-blur-sm text-white px-6 py-3 rounded-lg shadow-lg flex items-center gap-3">
        <svg id="render-status-spinner" class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span id="render-status-text" class="text-sm font-medium">Preparing video...</span>
    </div>

</body>
</html>
